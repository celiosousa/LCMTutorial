<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 1 PART 1 - Basics &amp; Fundamentals | Supervised Land Cover Classification with Google Earth Engine</title>
  <meta name="description" content="Chapter 1 PART 1 - Basics &amp; Fundamentals | Supervised Land Cover Classification with Google Earth Engine" />
  <meta name="generator" content="bookdown 0.22 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 1 PART 1 - Basics &amp; Fundamentals | Supervised Land Cover Classification with Google Earth Engine" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 1 PART 1 - Basics &amp; Fundamentals | Supervised Land Cover Classification with Google Earth Engine" />
  
  
  

<meta name="author" content="Celio Sousa (celio.h.resendedesousa@nasa.gov) and Miroslav Honzak (mhonzak@conservation.org)" />


<meta name="date" content="2024-10-01" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="index.html"/>
<link rel="next" href="part-3-country-specific-applications.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>


<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Classification Tutorial</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introduction and overview</a></li>
<li class="chapter" data-level="1" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html"><i class="fa fa-check"></i><b>1</b> PART 1 - Basics &amp; Fundamentals</a><ul>
<li class="chapter" data-level="1.1" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#programming-and-remote-sensing-basics"><i class="fa fa-check"></i><b>1.1</b> Programming and Remote Sensing Basics</a><ul>
<li class="chapter" data-level="1.1.1" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#remote-sensing-language"><i class="fa fa-check"></i><b>1.1.1</b> Remote Sensing Language</a></li>
<li class="chapter" data-level="1.1.2" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#google-earth-engines-application-programming-interface-api-and-java-script"><i class="fa fa-check"></i><b>1.1.2</b> Google Earth Engine's Application Programming Interface (API) and Java Script</a></li>
<li class="chapter" data-level="1.1.3" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#exploring-image-and-image-collection"><i class="fa fa-check"></i><b>1.1.3</b> Exploring Image and Image Collection</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#image-and-image-collection-manipulation"><i class="fa fa-check"></i><b>1.2</b> Image and Image Collection Manipulation</a><ul>
<li class="chapter" data-level="1.2.1" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#image-math"><i class="fa fa-check"></i><b>1.2.1</b> Image Math</a></li>
<li class="chapter" data-level="1.2.2" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#compositing-and-mosaicking"><i class="fa fa-check"></i><b>1.2.2</b> Compositing and Mosaicking</a></li>
<li class="chapter" data-level="1.2.3" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#spectral-indices"><i class="fa fa-check"></i><b>1.2.3</b> Spectral indices</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#supervised-classification-using-random-forest"><i class="fa fa-check"></i><b>1.3</b> Supervised Classification using Random Forest</a><ul>
<li class="chapter" data-level="1.3.1" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#example-1-land-cover-classification-of-greater-cairo-and-giza-area-egypt---year-2022"><i class="fa fa-check"></i><b>1.3.1</b> Example 1: Land cover classification of Greater Cairo and Giza area, Egypt - Year 2022</a></li>
<li class="chapter" data-level="1.3.2" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#example-2-2015---2022-map-to-map-change-of-greater-cairo-and-giza-area-egypt"><i class="fa fa-check"></i><b>1.3.2</b> Example 2: 2015 - 2022 Map-to-Map change of greater Cairo and Giza area, Egypt</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#post-classification-processing"><i class="fa fa-check"></i><b>1.4</b> Post-classification processing</a><ul>
<li class="chapter" data-level="1.4.1" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#re-classification"><i class="fa fa-check"></i><b>1.4.1</b> Re-classification</a></li>
<li class="chapter" data-level="1.4.2" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#map-spatial-smoothing"><i class="fa fa-check"></i><b>1.4.2</b> Map spatial smoothing</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html"><i class="fa fa-check"></i><b>2</b> PART 3 - Country-specific Applications</a><ul>
<li class="chapter" data-level="2.1" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html#guinea"><i class="fa fa-check"></i><b>2.1</b> Guinea</a><ul>
<li class="chapter" data-level="2.1.1" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html#mangrove-mapping-in-guinea-west-africa"><i class="fa fa-check"></i><b>2.1.1</b> Mangrove mapping in Guinea, West Africa</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html#liberia"><i class="fa fa-check"></i><b>2.2</b> Liberia</a><ul>
<li class="chapter" data-level="2.2.1" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html#anomaly-based-plantation-detection"><i class="fa fa-check"></i><b>2.2.1</b> Anomaly-based plantation detection</a></li>
<li class="chapter" data-level="2.2.2" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html#class-by-class-land-cover-mapping"><i class="fa fa-check"></i><b>2.2.2</b> Class-by-class land cover mapping</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html"><i class="fa fa-check"></i><b>3</b> Part 4 - Ecosystem Accounting</a><ul>
<li class="chapter" data-level="3.1" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#introduction-to-ecosystem-accounting"><i class="fa fa-check"></i><b>3.1</b> Introduction to Ecosystem Accounting</a><ul>
<li class="chapter" data-level="3.1.1" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#essentials"><i class="fa fa-check"></i><b>3.1.1</b> Essentials</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#ecosystem-extent-account"><i class="fa fa-check"></i><b>3.2</b> Ecosystem Extent Account</a><ul>
<li class="chapter" data-level="3.2.1" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#structure-of-ecosystem-extent-account"><i class="fa fa-check"></i><b>3.2.1</b> Structure of ecosystem extent account</a></li>
<li class="chapter" data-level="3.2.2" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#examples-and-exercises"><i class="fa fa-check"></i><b>3.2.2</b> Examples and exercises</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#tools-for-compiling-ecosystem-extent-account-tables"><i class="fa fa-check"></i><b>3.3</b> Tools for Compiling Ecosystem Extent Account Tables</a><ul>
<li class="chapter" data-level="3.3.1" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#platforms-for-running-python-scripts"><i class="fa fa-check"></i><b>3.3.1</b> Platforms for running Python scripts</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#compiling-ecosystem-extent-account-tables"><i class="fa fa-check"></i><b>3.4</b> Compiling Ecosystem Extent Account Tables</a><ul>
<li class="chapter" data-level="3.4.1" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#essentials-1"><i class="fa fa-check"></i><b>3.4.1</b> Essentials</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Supervised Land Cover Classification with Google Earth Engine</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="part-1---basics-fundamentals" class="section level1">
<h1><span class="header-section-number">Chapter 1</span> PART 1 - Basics &amp; Fundamentals</h1>
<div id="programming-and-remote-sensing-basics" class="section level2">
<h2><span class="header-section-number">1.1</span> Programming and Remote Sensing Basics</h2>
<div id="remote-sensing-language" class="section level3">
<h3><span class="header-section-number">1.1.1</span> Remote Sensing Language</h3>
<p><strong>A) Definition</strong></p>
<p>The term <em><strong>Remote sensing</strong></em> has been variously defined. Some of its early definitions include:</p>
<ul>
<li><p>The art or science of telling something about an object without touching it. (Fischer et al., 1976)</p></li>
<li><p>Remote sensing is the acquisition of physical data of an object without touch or contact. (Lintz and Simonett, 1976)</p></li>
<li><p>Remote sensing is the observation of a target by a device separated from it by some distance. (Barrett and Curtis, 1976)</p></li>
<li><p>The term <em>remote sensing</em> in its broadest sense means &quot;reconnaissance at a distance.&quot; (Colwell, 1966)</p></li>
</ul>
<p>Thus, in the context of this training, we can define <em>Remote Sensing</em> as the science of acquiring information about a given target, object or phenomenon on the surface of the Earth by sensors on-board various platforms orbiting our planet.</p>
<p><strong>B) Building blocks of remote sensing</strong></p>
<p>Although the many different methods for collection, processing and interpretation of remotely sense data can vary widely, they will always have the following essential components:</p>
<div class="figure"><span id="fig:FigBuildingBlocks"></span>
<img src="images/BuildingBlocksRemoteSensing.png" alt="Basic components of a remote sensing system." width="1303" />
<p class="caption">
Figure 1.1: Basic components of a remote sensing system.
</p>
</div>
<ol style="list-style-type: upper-roman">
<li>Energy Source</li>
</ol>
<p>The source of the electromagnetic radiation/energy (EMR) is the first requirement of any remote sensing process. The electromagnetic spectrum is used to &quot;classify&quot; the EMR according to its wavelength:</p>
<div class="figure"><span id="fig:FigEMS"></span>
<img src="images/EMS%20copy.png" alt="The Electromagnetic Spectrum" width="1105" />
<p class="caption">
Figure 1.2: The Electromagnetic Spectrum
</p>
</div>
<p>Depending on the source of energy they are using, the different remote sensing systems can be classified as <em><strong>active</strong></em> or <em><strong>passive</strong></em>. <em>Active</em> sensors will produce its own source of energy for the illumination of the target. They will emit the energy toward the target being investigated and the energy reflected by this target is detected and measured by the sensor. Usually, these sensors operate in the microwave range of the electromagnetic spectrum. On the other hand, <em>passive</em> sensors only measures the energy that is naturally available, usually from the sun. These sensors can only be used to detect the energy being reflected during the time when the sun is illuminating the Earth. These sensors usually measure energy from the optical range (visible, near infrared, short-wave infrared and thermal infrared).</p>
<div class="figure"><span id="fig:PassiveAndActive"></span>
<img src="images/PassiveAndActive.png" alt="Remote sensing can be classified as Passive or Active based on the source of energy." width="878" />
<p class="caption">
Figure 1.3: Remote sensing can be classified as Passive or Active based on the source of energy.
</p>
</div>
<p>You can also think about these concepts of <em>active</em> and <em>passive</em> using a handheld photographic camera as an example: When photographing a target in the dark, the camera flash will provide the energy necessary to illuminate the target. Therefore, in that case, the camera is an <em>active</em> sensor. On the other hand, this same camera will be a <em>passive</em> sensor when you are photographing a target or object during the day, when the target being illuminated by sun light and no flash is necessary.</p>
<ol start="2" style="list-style-type: upper-roman">
<li>Interaction with the target/object</li>
</ol>
<p>The most common medium in between the source and target is the atmosphere. This is where the first interaction occurs. As the EMR travel from its source to the target, it will come in contact with and interact different atmosphere constituents: aerosols, water vapor, solid particles, etc. Secondly, once the EMR makes its way through the atmospherethe to the target, it will interact with it depending on the target properties and energy wavelength. The EMR can have different types of interaction when it encounters matter; whether it is gas, solid or liquid: it can be <strong>transmitted</strong> (that is, it passes through the target), <strong>absorbed</strong> (that is, the target absorbs the energy usually increasing its temperature as a result), <strong>emitted</strong> (that is, energy is emitted from all matter at temperatures above the absolute zero of 0 Kelvins), <strong>scattered</strong> (that is, deflected in every direction) and <strong>reflected</strong> (that is, energy bounces off the target's surface and its direction is usually a function of target structure and texture).</p>
<div class="caution">
<p>
Keep in mind: All targets can show different proportions of each of these interactions.
</p>
</div>
<ol start="3" style="list-style-type: upper-roman">
<li>Recording of the energy by the sensor</li>
</ol>
<p>The sensor - often onboard of airplanes or satellites in space - will measure the returning EMR after it has interacted with the target and the atmosphere. This measurement is converted into a digital image with discrete values in units of digital number (DN) for each image pixel. Depending on the sensor, these resulting images will have different characteristics (or <em><strong>resolutions</strong></em>). They are:</p>
<ul>
<li><p><strong>Spatial Resolution</strong>: usually known as pixel size. It refers to the sensor's ability to discriminate different objects/targets. A higher spatial resolution means a smaller pixel size which, in turn, means that smaller objects can be distinguishable as separate targets.</p></li>
<li><p><strong>Spectral Resolution</strong>: Different sensors will measure the EMR at specific ranges (or wavelengths), usually called <em>bands</em>. Thus, the spectral resolution of a sensor usually refers to the number and bandwith of these bands.</p></li>
<li><p><strong>Radiometric Resolution</strong>: Usually measured in <em>bits</em>, it refers to the sensor's ability to detect the smallest change in the spectral reflectance among different targets. For example, a 8-bit image will have 256 levels of brightness while a 16-bit image has 65,536 levels of brightness.</p></li>
<li><p><strong>Temporal resolution</strong> (sensors onboard satellites): is the time required for the satellite to collect two images at the same geographic location on Earth. Higher temporal resolution means less time for revisiting the same location. However, temporal resolution is usually inverselly proportional to spatial resolution: The larger the pixel size, the larger area the sensor will cover which means less time until the next revisit.</p></li>
</ul>
<ol start="4" style="list-style-type: upper-roman">
<li>Transmission, Reception, and Processing</li>
</ol>
<p>The EMR recorded by the sensor is transmitted in an electronic form to a receiving station on Earth where the data is processed and stored.</p>
<ol start="22" style="list-style-type: upper-alpha">
<li>Analysis and Interpretation (we are here!)</li>
</ol>
<p>This is where this training is focused on! The EMR was transformed into a digital dataset where we can use specialized instruments/hardware/software to extract information about the target observed. This extraction is often done through <em><strong>image processing</strong></em> (or digital image processing), which is the process which makes an image interpretable for a given use. There are many methods of image processing, but these are the most common ones:</p>
<ul>
<li><p><strong>Image correction</strong>: The digital image recorded by the sensor on a satellite (or aircraft) may contain errors related to the geometry and brightness values of the pixels. For example, a geometrical correction, also called <em><strong>geo-referencing</strong></em>, is a procedure where the content of image will be assigned a spatial coordinate system (for example, geographical latitude and longitude).</p></li>
<li><p><strong>Image enhancement</strong>: This is related to modification of an image, by changing the pixel brightness values, to improve its visual aspects so that the actual analysis of images will be easier, faster and more reliable.</p></li>
<li><p><strong>Image classification</strong>: The overall goal of this method is to categorize all pixels in an image into themes (or <em><strong>land cover classes</strong></em>). This resulting map with its limited number of classes can be more readily and sucessfully interpreted compared to the raw image and it is often use for planning purposes. There are supervised and unsupervised methods for classification of an image: A <em><strong>supervised classification</strong></em> (human-guided) is based on the idea that a user can select sample pixels in an image that are representative of specific classes and then direct the image processing software to use these training sites as references for the classification of all other pixels in the image. These samples are selected based on the knowledge of the user. On the other hand, an <em><strong>unsupervised classification</strong></em> (computer/software-guided) is where the output classes are based on the software's ability to determine which pixels are related, using several different models and techniques.</p></li>
</ul>
<p>This final component of Remote Sensing (V) is achieved when we apply the extracted information to solve a particular problem.</p>
<p><strong>C) Spectral Signatures: A target's spectral fingerprint</strong></p>
<p>As mentioned before, remote sensing is based on the measurement of reflected (or emitted) radiation from different targets. Objects having different surface features reflect or absorb the sun's radiation in different ways. In order to understand and interpret the information extracted from remotely sensed data, you have to first understand the behavior of the target in respect to the electromagnetic spectrum. Each target will show a distinct reflectance pattern as a function of the wavelength, known as <em><strong>spectral signature</strong></em> (or a spectral fingerprint). This signature will directly (or indirectly) lead to the identification of a target based on its set of values for its reflectance in different spectral ranges:</p>
<div class="figure"><span id="fig:SpectralSignature"></span>
<img src="images/Spectral%20Signature.jpg" alt="Typical spectral signatures of specific land cover types in the visible and infrared region of the electromagnetic spectrum (Source: http://www.seos-project.eu/)" width="1642" />
<p class="caption">
Figure 1.4: Typical spectral signatures of specific land cover types in the visible and infrared region of the electromagnetic spectrum (Source: <a href="http://www.seos-project.eu/" class="uri">http://www.seos-project.eu/</a>)
</p>
</div>
<div class="rmdcomment">
<p>
<em><strong>Reflectance</strong></em> is the ratio of the amount of light leaving a target to the amount of light striking the target. It has no units.
</p>
</div>
<p>The spectral signature of <em>healthy green vegetation</em> has a small reflectance in the visible portion of the electromagnetic spectrum resulting from the pigments in plant leaves. Most of the light is being used in the photosynthesis process. However, the reflectance increases dramatically in the near infrared. The spectral signature of <em>soil</em> is much less variable. Its behavior is affected by soil moisture, texture, surface roughness and they are less dominant than the absorbance features present in vegetation. The <em>water</em>'s spectral signature is characterized by a high absorption at near infrared wavelengths range and beyond. Because of this absorption property, water bodies as well as features containing water can easily be detected, located and delineated with remote sensing data.</p>
<p>These differences make it possible to identify different Earth surface features or materials by analysing their spectral reflectance patterns or spectral signatures. [add more text]</p>
<p><em><strong>References</strong></em></p>
<p>Fischer, W. A., W.R. Hemphill and A. Kover. 1976. Progress in Remote Sensing. <em>Photogrametria</em>, Vol. 32, pp. 33-72</p>
<p>Lintz, J. and D. S. Simonett. 1976. <em>Remote Sensing of Environment</em>. Reading, MA: Addison-Wesley. 694 pp.</p>
<p>Barrett, E. C. and C. F. Curtis. 1976. <em>Introduction to Environmental Remote Sensing</em>. New York: Macmillian, 472 pp.</p>
<p>Colwell, R. N. 1966. Uses and Limitations of Multispectral Remote Sensing. In <em>Proceedings of the Fourth Symposium on Remote Sensing of Environment</em>. Ann Arbor: Institute of Science and Technology, University of Michigan, pp. 71-100.</p>
</div>
<div id="google-earth-engines-application-programming-interface-api-and-java-script" class="section level3">
<h3><span class="header-section-number">1.1.2</span> Google Earth Engine's Application Programming Interface (API) and Java Script</h3>
<p>Google Earth Engine is a cloud-based platform for scientific data analysis and remote sensing data processing. It provides a large catalog of ready-to-use, cloud-hosted datasets. One of Earth Engine's key features is the ability to handle computationally demading processing and analysis very fast by distributing them across a large number of servers. The ability to efficiently use the cloud-hosted datasets and computation is enabled by the Earth Engine API.</p>
<p>An API is a way to communicate with Google Earth Engine servers. It allows you to specify what computation or command you would like to do, and then to receive the results back from the servers. The API is designed so that users do not need to worry about how the computation is distributed across a cluster of machines and the results are assembled. Users of the API simply specify what needs to be done. This greatly simplifies the code by hiding the implementation detail from the users. It also makes Earth Engine simpler for users who are not too familiar with writing code.</p>
<p><strong>JavaScript API and Introduction to the Code Editor</strong></p>
<p>The Earth Engine platform comes with a web-based Code Editor that allows you to start using the Earth Engine JavaScript API without any installation. It also provides additional functionality to display your results on a map, save your scripts, access documentation, manage tasks, and more. It has a one-click mechanism to share your code with other users—allowing for easy reproducibility and collaboration. In addition, the JavaScript API comes with a user interface library, which allows you to create charts and web-based applications with little effort.</p>
<p>The Code Editor is an integrated development environment for the Earth Engine JavaScript API. It offers an easy way to type, debug, run, and manage code. Once you have successfully registered for a Google Earth Engine account, you can visit <a href="https://code.earthengine.google.com/" class="uri">https://code.earthengine.google.com/</a> to open the Code Editor. When you first visit the Code Editor, you will see a screen such as the one shown below:</p>
<div class="figure"><span id="fig:CodeEditor"></span>
<img src="images/PartI-CodeEditor.PNG" alt="Earth Engine Code Editor" width="858" />
<p class="caption">
Figure 1.5: Earth Engine Code Editor
</p>
</div>
<p>The Code Editor allows you to type JavaScript code and execute it. When you are first learning a new language and getting used to a new programming environment, it is customary to make a program to display your name or the words “Hello World.” This is a fun way to start coding that shows you how to give input to the program and how to execute it. It also shows where the program displays the output. Doing this in JavaScript is quite simple. Copy the following code into the center panel:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="st">&#39;Hello World&#39;</span>);</code></pre></div>
<p>The line of code above uses the JavaScript <code>print()</code> function to print the text “Hello World” to the screen. Once you enter the code, click the <strong>Run</strong> button. The output will be displayed on the upper right-hand panel under the <strong>Console</strong> tab:</p>
<div class="figure"><span id="fig:PrintRun"></span>
<img src="images/PartI-PrintRun.png" alt="Running code with GEE" width="858" />
<p class="caption">
Figure 1.6: Running code with GEE
</p>
</div>
<p>You now know where to type your code, how to run it, and where to look for the output. You just wrote your first Earth Engine script and may want to save it. Click the <strong>Save</strong> button to save a script:</p>
<div class="figure"><span id="fig:Save"></span>
<img src="images/PartI-Save.png" alt="Saving a script" width="858" />
<p class="caption">
Figure 1.7: Saving a script
</p>
</div>
<p>If this is your first time using the Code Editor, you will be prompted to create a home folder. This is a folder in the cloud where all your code will be saved:</p>
<div class="figure"><span id="fig:SaveII"></span>
<img src="images/PartI-SaveII.png" alt="Your first home folder" width="396" />
<p class="caption">
Figure 1.8: Your first home folder
</p>
</div>
<div class="caution">
<p>
You can pick a name of your choice, but remember that <strong>it cannot be changed and will permanently be associated with your account</strong>.
</p>
</div>
<p>Once youre home folder is created, you will be prompted to create a <em>new repository</em>. A repository is a like a folder where you can save your scripts. You can also share entire repositories with other users. Your account can have multiple repositories and each one can hold multiple code scripts. Start by creating a repository:</p>
<div class="figure"><span id="fig:Repository"></span>
<img src="images/PartI-Repository.png" alt="Your first repository" width="397" />
<p class="caption">
Figure 1.9: Your first repository
</p>
</div>
<p>Finally, you will be able to save your script inside the newly created repository. Enter a name of your choice and click <strong>OK</strong>:</p>
<div class="caution">
<p>
Spaces are not allowed when naming scripts!
</p>
</div>
<div class="figure"><span id="fig:SaveIII"></span>
<img src="images/PartI-SaveIII.png" alt="Saving a script file" width="429" />
<p class="caption">
Figure 1.10: Saving a script file
</p>
</div>
<p>Once the script is saved, it will appear in the script manager panel. The scripts are saved in the cloud and will always be available to you when you open the Code Editor.</p>
<div class="figure"><span id="fig:Saved"></span>
<img src="images/PartI-Saved.png" alt="Your first script in your repository" width="505" />
<p class="caption">
Figure 1.11: Your first script in your repository
</p>
</div>
<p><strong>JavaScript Basics: Data types</strong></p>
<p>Javascript is the language you will use to construct and set up your commands and analysis. This section covers the basics of the Java Script sintax and some basic data structures. In the following sections, more JavaScript code will be presented. Throughout this document, code will be presented with a distinct colored font and with shaded background. As you encounter code, copy and paste it into the Code Editor and click <strong>Run</strong>.</p>
<p><em><strong><em>A) Variables</em></strong></em></p>
<p>In a programming language, variables are used to store data values. In JavaScript, a variable is defined using the <code>var</code> keyword followed by the name of the variable. For instance, create a <code>var</code> named <code>city</code> that contain the text string <code>'Monrovia'</code>. Text strings in the code must be always in quotes. Google Earth Engine allows you to use single <code>'</code> or double <code>&quot;</code> quotes, as long as they match in the beginning and end of the text string. We also usually end each statement on scripts with a semicolon <code>;</code>, although Earth Engine's code editor does not require it. A 'i' will be shown in the line of the code where a semicolon is missing:</p>
<div class="figure"><span id="fig:Semicolon"></span>
<img src="images/PartI-Semicolon.png" alt="Even though they are not a requirement, Google Earth Engine indicates that a semicolon is missing in the statement. You can hover the mouse cursor over the icon to reveal its meaning." width="801" />
<p class="caption">
Figure 1.12: Even though they are not a requirement, Google Earth Engine indicates that a semicolon is missing in the statement. You can hover the mouse cursor over the icon to reveal its meaning.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var city =<span class="st"> &#39;Monrovia&#39;</span>;</code></pre></div>
<p>If you <code>print</code> the variable <code>city</code>, you will get the string stored in the variable (Monrovia) printed in the <strong>Console</strong>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(city);</code></pre></div>
<p>When you use quotations, the variable is automatically assigned the type <em>string</em>. You can also assign numbers to variables. For example, create the variables <code>population</code> and <code>area</code> and assing a number as their value. When assigning numbers, you do not use commas <code>,</code> for thousand separators. You do, however, use <code>.</code> for decimals:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var population =<span class="st"> </span><span class="dv">939524</span>;
var area =<span class="st"> </span><span class="fl">194.25</span>;</code></pre></div>
<p>Print those variables to the <strong>Console</strong>. You can also add text to describe the variables printed in the <strong>Console</strong>. Simply add a text string within the <code>print</code> function along with the variable being printed separated with <code>,</code>. Use the code below as example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="st">&#39;Number of people in Monrovia:&#39;</span>, population);
<span class="kw">print</span>(area, <span class="st">&#39;km squared&#39;</span>);</code></pre></div>
<p><em><strong><em>B) Lists</em></strong></em></p>
<p>In the previous examples, we created variables holding a single value (text or number). JavaScript provides a data structure called a <em>list</em> that can be used When you want to store multiple values in a single variable. You can create lists using square brackets <code>[]</code> and adding multiple values separated by <code>,</code>. Create a variable called <code>listofcities</code>, add values to it and print it to the <strong>Console</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var listofcities =<span class="st"> </span>[<span class="st">&#39;Monrovia&#39;</span>, <span class="st">&#39;Gbarnga&#39;</span>,<span class="st">&#39;Kakata&#39;</span>, <span class="st">&#39;Bensonville&#39;</span>];
<span class="kw">print</span>(<span class="st">&#39;Largest cities in Liberia&#39;</span>, listofcities);</code></pre></div>
<p>Looking at the output in the <strong>Console</strong>, you will see <code>listofcities</code> with an expander arrow (▹) next to it. Expand the list by clicking on the arrow to show its content. You will notice that along with the items on the list, there will be a number next to each value you added. <strong>This is the index of each item</strong>. It allows you to refer to each item in the list using a numeric value that indicates its position in the list. This is useful when you want to extract a particular item from a list object.</p>
<div class="figure"><span id="fig:List"></span>
<img src="images/PartI-List.png" alt="A JavaScript List." width="542" />
<p class="caption">
Figure 1.13: A JavaScript List.
</p>
</div>
<p><em><strong><em>C) Objects and Dictionaries</em></strong></em></p>
<p>While useful to hold multiple values, <em>lists</em> are not appropriate to hold more structured data. JavaScript allows you to store 'key-value' information in <em>objects</em> or <em>dictionaries</em>. In this type of data structure, you can refer to a value by its key rather than its position - like in <em>lists</em>. You can create objects using curly braces <code>{}</code>. Use the code below as an example of an object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var cityData =<span class="st"> </span>{<span class="st">&#39;city&#39;</span><span class="op">:</span><span class="st"> &#39;Monrovia&#39;</span>, <span class="st">&#39;population&#39;</span><span class="op">:</span><span class="st"> </span><span class="dv">939524</span>, <span class="st">&#39;area&#39;</span><span class="op">:</span><span class="st"> </span><span class="fl">194.25</span>, <span class="st">&#39;coordinates&#39;</span><span class="op">:</span><span class="st"> </span>[<span class="op">-</span><span class="fl">10.790</span>, <span class="fl">6.315</span>]};</code></pre></div>
<p>There are a few important things about the syntax of the code above: As objects tend to hold several keys and values, it can be difficult to read the code if it is written on a continuous string. To improve readability you can use multiple lines instead:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var cityData =<span class="st"> </span>{
  <span class="st">&#39;city&#39;</span><span class="op">:</span><span class="st"> &#39;Monrovia&#39;</span>,
  <span class="st">&#39;population&#39;</span><span class="op">:</span><span class="st"> </span><span class="dv">939524</span>,
  <span class="st">&#39;area&#39;</span><span class="op">:</span><span class="st"> </span><span class="fl">194.25</span>,
  <span class="st">&#39;coordinates&#39;</span><span class="op">:</span><span class="st"> </span>[<span class="op">-</span><span class="fl">10.790</span>, <span class="fl">6.315</span>]
};</code></pre></div>
<p>Note how each key-value pair is on a different line. It is much easier to organize your key-value information this way. Additionally, the code can be more easily read. Second, note that the object above can holds multiple types of types of values (string and numbers) and structure (list)!</p>
<p>If you print <code>cityData</code> to the <strong>Console</strong>, you can see that instead of a numeric index, each value will be identified by its <em>key</em>.</p>
<div class="figure"><span id="fig:Dictionary"></span>
<img src="images/PartI-Dictionary.png" alt="A JavaScript Object." width="536" />
<p class="caption">
Figure 1.14: A JavaScript Object.
</p>
</div>
<p>This key can also be used to retrieve the value of an item within an object or dictionary. If you want to retrieve a particular key from a dictionary, simply use <code>['key']</code>. For example, if you want to retrieve the population value from this object and print it individually to the <strong>Console</strong>, you can use a code like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(cityData[<span class="st">&#39;population&#39;</span>]);</code></pre></div>
<p>The same logic can be applied to <em>lists</em>. Always remember that lists have numeric index. Therefore, when retrieving itens from a list, use the number of its position on the list:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(listofcities[<span class="st">&#39;2&#39;</span>]);</code></pre></div>
<p><em><strong><em>D) Functions</em></strong></em></p>
<p>Functions are often used to group a set of operations and used to repeat the same operation with different set of parameters without having to rewrite the code for every iteration. In other words, you can call a function with different parameters to generate different outputs without changing the code. Functions are defined using <code>function()</code>. They often take parameters which tell the function what to do. These parameters go inside the parentheses <code>()</code>. Below is an example of a function named <code>SumFunction</code> to calculate the sum of two numbers: <code>fistValue</code> and <code>secondValue</code>. The var <code>sum</code> adds those two parameters and <code>return</code> is used to generate the output of that operation</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">function</span> <span class="kw">SumFunction</span> (firstValue, secondValue) {
  var sum =<span class="st"> </span>firstValue <span class="op">+</span><span class="st"> </span>secondValue;
  return sum;
}</code></pre></div>
<p>Note that if you run the code above, nothing happens. This is just a function and it needs to be given the parameters. For example, if you need to add 37 to 584 using this function and print the result into the <strong>Console</strong>, you can use the code below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var result =<span class="st"> </span><span class="kw">SumFunction</span>(<span class="dv">37</span>,<span class="dv">584</span>);
<span class="kw">print</span>(result);</code></pre></div>
<p>When you call <code>SumFunction</code>, it will always perform the operation <code>sum</code> with watever two parameters you define in <code>()</code>. As mentioned, you can perform several operations at once using functions. For example, you can add other operations in the function above and return a list or a dictionary with the results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">function</span> <span class="kw">MathFunction</span> (firstValue, secondValue) {
  var sum =<span class="st"> </span>firstValue <span class="op">+</span><span class="st"> </span>secondValue;
  var sub =<span class="st"> </span>firstValue <span class="op">-</span><span class="st"> </span>secondValue;
  var fraction =<span class="st"> </span>firstValue <span class="op">/</span><span class="st"> </span>secondValue;
  return {<span class="st">&#39;Result Sum&#39;</span><span class="op">:</span>sum, <span class="st">&#39;Result Substraction&#39;</span><span class="op">:</span>sub, <span class="st">&#39;Result Division&#39;</span><span class="op">:</span><span class="st"> </span>fraction};
}</code></pre></div>
<p>Using <code>MathFunction</code> with a pair of parameters (<code>firstValue</code> and <code>SecondValue</code>) will return an object with the results of each operation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var results =<span class="st"> </span><span class="kw">MathFunction</span>(<span class="dv">500</span>,<span class="dv">5</span>);
<span class="kw">print</span>(results);</code></pre></div>
<div class="figure"><span id="fig:Results"></span>
<img src="images/PartI-Results.png" alt="Printed results of MathFunction." width="511" />
<p class="caption">
Figure 1.15: Printed results of MathFunction.
</p>
</div>
<p><strong>Earth Engine Containers and Objects</strong></p>
<p>So far, you learned the different data structure/types you can use within Google Earth Engine. However, if you want to do any computation with the data stored in these different types of structure, you will have to use an Earth Engine container. The <code>ee</code> package is used for formulating requests to Earth Engine. In other words, <code>ee</code> (prefix for Earth Engine) allows you to request Earth Engine servers to perform a certain computation to an variable or object. Each <code>ee</code> object has many different <em>methods</em>. You can think of <em>methods</em> as the many different things and computations that can be done for an specific object. In the Code Editor, you can switch to the <strong>Docs</strong> tab to see the API functions grouped by object types.</p>
<div class="figure"><span id="fig:Docs"></span>
<img src="images/PartI-DocsTab.png" alt="List of available objects in the Docs tab of GEE API." width="502" />
<p class="caption">
Figure 1.16: List of available objects in the Docs tab of GEE API.
</p>
</div>
<p>Below are some examples to ilustrate the concept behind an Earth Engine object:</p>
<p><em><strong>A) Strings</strong></em></p>
<p>You can put strings into a <code>ee.String</code> object to be sent to Earth Engine. Using an object/container allows you to do manipulate them in many different ways. For example, <code>ee.String</code> has the: * <code>toLowerCase()</code> method. This method will convert any string in a <code>ee.String</code> object to lower case; * <code>length()</code> method. This method will count the characters in your string; * <code>cat()</code> method. This method will concatenate two strings into one; * and many others! Make sure to check the <strong>Docs</strong> tab for all the available methods for a given object.</p>
<p>The code below uses some of the methods of <code>ee.String</code> as an example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var string =<span class="st"> </span><span class="kw">ee.String</span>(<span class="st">&#39;HELLO EVERYONE, &#39;</span>);
<span class="kw">print</span>(<span class="kw">string.toLowerCase</span>());
<span class="kw">print</span>(<span class="kw">string.length</span>());
var string2 =<span class="st"> </span><span class="kw">ee.String</span>(<span class="st">&#39;nice to meet you&#39;</span>);
<span class="kw">print</span>(<span class="kw">string.cat</span>(string2));</code></pre></div>
<p>In your console tab you will see that the 'HELLO EVERYONE, ' string is now all in lower case. You will also see that <code>.length()</code> returned 16 as the number of characters for that string.</p>
<p>Consider the code below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var string =<span class="st"> &#39;HELLO EVERYONE&#39;</span>;
var string2 =<span class="st"> &#39;nice to meet you&#39;</span>;
<span class="kw">print</span>(<span class="kw">string.cat</span>(string2));</code></pre></div>
<p>If you try to use a method on a non <code>ee</code> object, you will get an error.</p>
<div class="figure"><span id="fig:Error"></span>
<img src="images/PartI-Error.png" alt="Trying to use a method on non-ee.Object will return an error" width="500" />
<p class="caption">
Figure 1.17: Trying to use a method on non-ee.Object will return an error
</p>
</div>
<p><em><strong>B) Numbers</strong></em></p>
<p><code>ee.Number</code> is just another example of an object from that list. Similarly to <code>ee.String</code>, it will have many methods to be used with. For example, <code>.add()</code>, <code>.subtract()</code>, <code>.divide()</code> and <code>.multiply ()</code> will perform these operations on <code>ee.Number</code> objects. Make sure to consult the <strong>Docs</strong> tab for all the different methods for each object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var value1 =<span class="st"> </span><span class="kw">ee.Number</span>(<span class="dv">100</span>);
var value2 =<span class="st"> </span><span class="kw">ee.Number</span>(<span class="dv">2</span>);
<span class="kw">print</span>(<span class="kw">value1.add</span>(value2));
<span class="kw">print</span>(<span class="kw">value1.subtract</span>(value2));
<span class="kw">print</span>(<span class="kw">value1.divide</span>(value2));
<span class="kw">print</span>(<span class="kw">value1.multiply</span>(value2));
<span class="kw">print</span>(<span class="kw">value1.log10</span>());</code></pre></div>
<p><em><strong>B) Lists</strong></em></p>
<p>You can also make a JavaScript list into an <code>ee.List</code> on Earth Engine server by simply casting your list into the container. There are many other useful methods to use when you have an <code>ee.List</code>. For instance, instead of making a JavaScript list by typing each value, you can use <code>ee.List.sequence()</code> to construct a list. This method will take many arguments, such as the value of the start of the list, the value at the end of the list, steps (increment) and count. Consider the examples below:</p>
<ul>
<li>Making a list with numbers from 0 to 10:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="st">&#39;List 1&#39;</span>, <span class="kw">ee.List.sequence</span>(<span class="dv">0</span>,<span class="dv">10</span>))</code></pre></div>
<ul>
<li>Making a list from 0 to 10 with increments of 2:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="st">&#39;List 2&#39;</span>, <span class="kw">ee.List.sequence</span>(<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">2</span>))</code></pre></div>
<div class="rmdcomment">
<p>
<strong>Remember</strong>: A <code>var string = 'text'</code> is a JavaScript string that does not allow computations. A <code>var string = ee.String('text')</code> is an Earth Engine object that allows computations!
</p>
</div>
</div>
<div id="exploring-image-and-image-collection" class="section level3">
<h3><span class="header-section-number">1.1.3</span> Exploring Image and Image Collection</h3>
<p>Now that you learned the basics of JavaScript and Earth Engine objects, you have the tools at your disposal to start using the Earth Engine API to build scripts for remote sensing analysis. In this section, we explore satellite imagery, which are one of GEE's core capabilities!</p>
<p><em><strong>A) Single band image</strong></em></p>
<p>The first thing you need to know is that when working with images in Earth Engine, you will have to use an <code>ee.Image()</code> container. The argument provided to the constructor is the string ID of an image in the Earth Engine data catalog. (Remember to always see the <strong>Docs</strong> tab for a full list of arguments to this container). To retrieve an image ID, you can search in the Earth Engine catalog using the search tool at the top of the Code Editor:</p>
<div class="figure"><span id="fig:Search"></span>
<img src="images/PartI-Search.png" alt="You can browse through Earth Engine's data catalog with the search tool" width="855" />
<p class="caption">
Figure 1.18: You can browse through Earth Engine's data catalog with the search tool
</p>
</div>
<p>For example, try typing 'elevation' into the search field and note that a list of rasters is returned:</p>
<div class="figure"><span id="fig:SearchII"></span>
<img src="images/PartI-SearchII.png" alt="Typing in the search field. Google Earth Engine will show all datasets available with that criteria." width="855" />
<p class="caption">
Figure 1.19: Typing in the search field. Google Earth Engine will show all datasets available with that criteria.
</p>
</div>
<p>Click in any of the dataset entries to see more information about that dataset. From the list above, explore the dataset 'SRTM Digital Elevation Data Version 4'. You can also find more information about this dataset on the tabs on the top right side of the dataset description screen. On the left side of the dataset description screen, you can find the Image ID, which is what we use with the <code>ee.Image()</code>. Alternatively, you can use the <strong>Import</strong> button on the dataset description. Using the <strong>Import</strong> button, a variable is automatically created in a special section, named 'Imports', at the top of your script. You can rename the variable by clicking on its name in the imports section.</p>
<div class="figure"><span id="fig:DataInfo"></span>
<img src="images/PartI-DataInfo.png" alt="Data description" width="788" />
<p class="caption">
Figure 1.20: Data description
</p>
</div>
<p>Copy the image ID from the screen above and add it to a <code>var</code> elevationImage with the <code>ee.Image()</code> container as shown below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var elevationImage =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;CGIAR/SRTM90_V4&#39;</span>);</code></pre></div>
<p>You can also retrieve the metadata about this image by using <code>print()</code>. In the <strong>Console</strong>, click the expander arrows to show the information. You will discover that the SRTM image has one band called 'elevation'.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(elevationImage);</code></pre></div>
<div class="figure"><span id="fig:ImageInfo"></span>
<img src="images/PartI-ImageInfo.png" alt="Image description using `print()`" width="506" />
<p class="caption">
Figure 1.21: Image description using <code>print()</code>
</p>
</div>
<p>To display the image in the Map Editor, use the <code>Map</code> object's <code>.addLayer()</code> method. When you add an image to a map using <code>Map.addLayer()</code>, Earth Engine needs to determine how to map the values in the image band(s) to colors on the display. If a single-band image is added to a map - which is our case- by default Earth Engine displays the band in grayscale, where the minimum value is assigned to black, and the maximum value is assigned to white. If you don't specify what the minimum and maximum should be, Earth Engine will use default values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(elevationImage);</code></pre></div>
<p><em>Do not worry! You can make it look better with custom visualization parameters!</em></p>
<p>To change the way the data are stretched, you can provide another parameter to the <code>Map.addLayer()</code> call. Specifically, the second parameter, <code>visParams</code>, lets you specify the minimum and maximum values to display. One way of gauging the range of values of an image is by activating the <strong>Inspector</strong> tab and click around on the map. You will be able to see the value of that band for this dataset at that particular location:</p>
<div class="figure"><span id="fig:Inspector"></span>
<img src="images/PartI-Inspector.png" alt="Inspector tab. Click in the image and the inspector tab will display the data for that point" width="862" />
<p class="caption">
Figure 1.22: Inspector tab. Click in the image and the inspector tab will display the data for that point
</p>
</div>
<p>Click around the area of Liberia to have a sense of the range of values for this dataset. Suppose that, through further investigation, you determine that the best range of values to display elevation data in Liberia is [0,1000]. To display the data using this range, you can use a dictionary containing two keys: <code>min</code> and <code>max</code> and their respective values <code>0</code> and <code>1000</code>. A third parameter for <code>Map.addLayer()</code> is the name of the layer that is displayed in the Layer manager. Thus your code should be looking like the one below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(elevationImage, {min<span class="op">:</span><span class="dv">0</span>, max<span class="op">:</span><span class="dv">1000</span>}, <span class="st">&#39;Custom Visualization&#39;</span>);</code></pre></div>
<p>Run the code and you will see something like:</p>
<div class="figure"><span id="fig:ImageVis"></span>
<img src="images/PartI-VisLayer.png" alt="Custom Visualization for the SRTM data based on range of values." width="862" />
<p class="caption">
Figure 1.23: Custom Visualization for the SRTM data based on range of values.
</p>
</div>
<p>You can further improve your image display by using a color palette. Palettes let you set the color scheme for single-band images. A palette is a comma delimited <em>list</em> of color strings which are linearly interpolated between the maximum and minimum values in the visualization parameters.</p>
<p>To display this elevation band using a color palette, add a <code>palette</code> property to the <code>visParams</code> dictionary:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(elevationImage, {min<span class="op">:</span><span class="dv">0</span>, max<span class="op">:</span><span class="dv">1000</span>,palette<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;green&#39;</span>, <span class="st">&#39;yellow&#39;</span>, <span class="st">&#39;red&#39;</span>]}, <span class="st">&#39;Custom Visualization - Color&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:ImageVisColor"></span>
<img src="images/PartI-VisLayerColor.png" alt="Custom Visualization for the SRTM data based on range of values and color palette." width="863" />
<p class="caption">
Figure 1.24: Custom Visualization for the SRTM data based on range of values and color palette.
</p>
</div>
<p>In the next section, you'll learn how to display multi-band imagery.</p>
<p><em><strong>B) Multi band image</strong></em></p>
<p>To ilustrate the concepts and codes in this section, we will use a Landsat 8 image from April 2022 over Cairo, Egypt. Landsat is a set of multispectral satellites developed by the NASA (National Aeronautics and Space Administration of USA), since the early 1970’s. Landsat images are very used for environmental research. These images have from 8 to 11 spectral bands (spectral resolution), with pixels of 30x30 meters (spatial resolution) and with a revisit time of 16 days (temporal resolution).</p>
<p>Copy and paste the code below into the Code Editor:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var ImageL8 =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;LANDSAT/LC08/C02/T1_L2/LC08_176039_20220406&#39;</span>);</code></pre></div>
<p>As learned before, the code above is casting a Landsat 8 image into an <code>ee.Image</code> container using its ID into a <code>var</code> called 'ImageL8'. By clicking <strong>Run</strong>, Earth Engine will retrieve this image from its Landsat image catalog. You will not yet see any output.</p>
<p>As you learned, you can retrieve additional information about this image by using <code>print()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(ImageL8)</code></pre></div>
<p>In the Console panel, you may need to click the expander arrows to show the information. You should be able to read that this image consists of 19 different bands (index 0 to 18). Each band will have 4 properties: <em>name</em>, <em>data type</em> (as in if the value is an integer, float, ect.), <em>projection</em> and <em>dimensions</em> (in rows and columns of pixels). For this example, simply note the first property of the first band:</p>
<div class="figure"><span id="fig:L8Image"></span>
<img src="images/PartI-L8Image.png" alt="Landsat 8 image metadata." width="696" />
<p class="caption">
Figure 1.25: Landsat 8 image metadata.
</p>
</div>
<p>A satellite sensor like Landsat 8 measures the EMR in different portions of the electromagnetic spectrum. Six out of seven first bands in our image (&quot;SR_B2&quot; through &quot;SR_B7&quot;) contain measurements for six different portions of the spectrum:</p>
<div class="figure"><span id="fig:L8bands"></span>
<img src="images/PartI-L8Bands.png" alt="Landsat 8 bands. Source: https://www.usgs.gov/faqs/what-are-band-designations-landsat-satellites" width="1008" />
<p class="caption">
Figure 1.26: Landsat 8 bands. Source: <a href="https://www.usgs.gov/faqs/what-are-band-designations-landsat-satellites" class="uri">https://www.usgs.gov/faqs/what-are-band-designations-landsat-satellites</a>
</p>
</div>
<p>Now, let's visualize <code>ImageL8</code>. First, make sure your map is somewhere near Cairo, Egypt. To do this, click and drag the map towards Cairo, Egypt. (You can also jump there by typing “Cairo” into the <strong>Search panel</strong> at the top of the Code Editor). Add <code>ImageL8</code> to the Map as a <em>layer</em> using the code below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(ImageL8);</code></pre></div>
<p>You probably see a gray image with not a lot of details. From the previous section you learned that <code>Map.addLayer</code> take many parameters. One of them is the <code>visParams</code>, which lets you specify the minimum and maximum values to display. Similarly to the previous section, you can use the <strong>Inspector</strong> tab to investigate the range of values for each location for each of <code>ImageL8</code>'s band. Now, specify a range of values to be displayed. Follow the code example below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(ImageL8, {min<span class="op">:</span><span class="dv">8000</span>, max<span class="op">:</span><span class="dv">20000</span>}, <span class="st">&#39;My First Image&#39;</span>);</code></pre></div>
<p>You should see something like this:</p>
<div class="figure"><span id="fig:L8FalseColor"></span>
<img src="images/PartI-L8FalseColor.png" alt="Landsat 8 image in false color ." width="856" />
<p class="caption">
Figure 1.27: Landsat 8 image in false color .
</p>
</div>
<p>By default, if you do not specify the bands to be displayed within the <code>visParams</code>, Earth Engine will display the first three bands, each band on each RGB (red, green, blue) channel of your monitor screen. In other words, Earth Engine is displaying 'SR_B1' (Landsat 8's coastal aerosol band) in the red channel, 'SR_B2' (Landsat 8's blue band) in the green channel and 'SR_B3 (Landsat 8's green band). This is a case of a <em>false color</em> display, when spectral bands do not match the RGB channels in your screen. <em>False color</em> displays have many advantages and they will be explored later in the tutorial.</p>
<p>For a <em>real color</em> display, you will need to define the bands within <code>visParams</code> to match the RGB channels:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(ImageL8, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>, <span class="st">&#39;SR_B3&#39;</span>, <span class="st">&#39;SR_B2&#39;</span>], min<span class="op">:</span><span class="dv">8000</span>, max<span class="op">:</span><span class="dv">20000</span>}, <span class="st">&#39;Real color&#39;</span>);</code></pre></div>
<p>In the code above, <code>visParams</code> contains a list (<code>bands</code>) with the names of the <code>ImageL8</code>'s bands to be displayed in the RGB channels of your screen. This band set up tells Earth Engine to display the red band in the red channel, the green band in the green channel and the blue band in blue channel. We call this composition a <em>RGB 432</em> or <em>Real color</em> composition. You should see an image like this when running the code above:</p>
<div class="figure"><span id="fig:L8RealColor"></span>
<img src="images/PartI-L8Real.png" alt="Landsat 8 image displayed with a real color composition." width="856" />
<p class="caption">
Figure 1.28: Landsat 8 image displayed with a real color composition.
</p>
</div>
<p>You can easily change these values and settings within <code>visParams</code> by using the Layer setting option in the Map editor. You can find it by hovering your cursor over the Layer List (upper right corner of the Map editor, next to the <em>Map</em> and <em>Satellite</em> buttons) and clicking the <em>gear</em> icon of the layer:</p>
<div class="figure"><span id="fig:L8LayerSetting"></span>
<img src="images/PartI-L8LayerSetting.png" alt="Layer settings window." width="856" />
<p class="caption">
Figure 1.29: Layer settings window.
</p>
</div>
<p>Once you chose your settings, click <strong>Apply</strong>. Earth Engine will automatically apply the new settings and display the layer. Try using different band combinations and range values to see how the image changes. Different color compositions will highlight different features in the image based on their spectral signatures!</p>
<p><em><strong>C) Image collections</strong></em></p>
<p>An image collection refers to a set of Earth Engine images. For example, the collection of all Landsat 8 images! In this case, you will use <code>ee.ImageCollection()</code> instead of <code>ee.Image()</code> to retrieve a particular image collection . Like the SRTM image or the Landsat image you have been working with, image collections also have an ID. Similarly to the single images, you can discover the ID of an image collection by searching the Earth Engine data catalog from the Code Editor.</p>
<p>Start by loading the Landsat 8 image collection into a <code>var</code> called 'collection using the <code>ee.ImageCollection</code> container. Then try to print this collection to the <strong>Console</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var collection =<span class="st"> </span><span class="kw">ee.ImageCollection</span>(<span class="st">&#39;LANDSAT/LC08/C02/T1_L2&#39;</span>);
<span class="kw">print</span>(collection);</code></pre></div>
<p>You will notice that you will get an error when trying to print <code>collection</code> to the <strong>Console</strong>:</p>
<div class="figure"><span id="fig:L8Error"></span>
<img src="images/PartI-ErrorCollection.png" alt="Trying to print an image collection without any filter." width="567" />
<p class="caption">
Figure 1.30: Trying to print an image collection without any filter.
</p>
</div>
<p>It's worth noting that this collection represents every Landsat 8 scene collected, all over the Earth. Thus, Earth Engine is not able to print the information for every scene all over the globe since 2013 (when Landsat 8 started collecting data). In this case we need to filter this collection. Exploring the <strong>Docs</strong> tab of the Code Editor to learn more about <code>ee.ImageCollection</code>, you will notice the methods <code>filterBounds()</code> and <code>filterDate()</code>. These are shortcut methods on a bigger <code>filter()</code> method. In this case, <code>filterBounds()</code> filters a collection by intersection with geometry (or a location) while <code>filterDate()</code> filters a collection by a date range, expressed as strings.</p>
<p><strong>Location Filter</strong>: To filter <code>collection</code> to images that cover a particular location, first define your area of interest with the geometry drawing tools. To create geometries, use the geometry drawing tools in the upper left corner of the map display.</p>
<div class="figure"><span id="fig:Tools"></span>
<img src="images/PartI-GeometryTool.png" alt="The Geometry tools." width="855" />
<p class="caption">
Figure 1.31: The Geometry tools.
</p>
</div>
<p>For drawing points, use the place mark icon, for drawing lines, use the line icon, for drawing polygons, use the polygon icon, for drawing rectangles, use the rectangle icon. Using any of the drawing tools will automatically create a new geometry layer and add an import for that layer to the Imports section (top of the script). Once you finish drawing the geometry, click <strong>Exit</strong>. To rename the geometries that are imported to your script, click the settings icon next to it (or rename it directly in the Imports section).The geometry layer settings tool will be displayed in a dialog where you can change the geometry name.</p>
<p>Use the point mark and create a point geometry named 'aoi' (area of interest) in a location of your interest. For this example, we will use a point mark location over Cairo, Egypt. Use the figure below as a guide: 1) Click on the point mark geometry; 2) Place it in your location of interest, and; 3) rename it 'aoi'.</p>
<div class="figure"><span id="fig:point"></span>
<img src="images/PartI-PointGeometry.png" alt="Creating a point geometry." width="856" />
<p class="caption">
Figure 1.32: Creating a point geometry.
</p>
</div>
<p><strong>Date filter</strong>: Now that you have a location, create two variables <code>startDate</code> and <code>endDate</code> containing a data range expressed as strings. Use a date range of your choice. Dates are expressed as 'YYYY-MM-DD' in Earth Engine. For this example, we will use the first four months of 2022:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var startDate =<span class="st"> &#39;2022-01-01&#39;</span>;
var endDate =<span class="st"> &#39;2022-04-30&#39;</span>;</code></pre></div>
<p>Now that you have both filters for location and date range, you are ready to filter your image collection using <code>filterBounds()</code> and <code>filterDates()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var collectionFiltered =<span class="st"> </span><span class="kw">collection.filterBounds</span>(aoi)<span class="kw">.filterDate</span>(startDate,endDate);
<span class="kw">print</span>(collectionFiltered);</code></pre></div>
<p>When printing <code>collectionFiltered</code> to the <strong>Console</strong> you will notice that now Earth Engine was able to retrieve the information of every Landsat scene based on your filters. Using the date range and the location filters from this example, there are the 13 images in the <code>collectionFiltered</code> for Cairo from January to April, 2022:</p>
<div class="figure"><span id="fig:Collection"></span>
<img src="images/PartI-Collection.png" alt="Filtered collection." width="707" />
<p class="caption">
Figure 1.33: Filtered collection.
</p>
</div>
<p>If you want to retrieve a particular image from this collection you can simply use <code>ee.Image()</code> and the image ID printed in the <strong>Console</strong> tab!</p>
</div>
</div>
<div id="image-and-image-collection-manipulation" class="section level2">
<h2><span class="header-section-number">1.2</span> Image and Image Collection Manipulation</h2>
<p>Now that you know how to load and display an image, it's time to apply a computation to it. In the following sections you will learn some examples of computations for a single-band image and multi-band image (band math and vegetation index calculation) and for an image collection.</p>
<div id="image-math" class="section level3">
<h3><span class="header-section-number">1.2.1</span> Image Math</h3>
<ul>
<li><strong>Single-band image</strong></li>
</ul>
<p>Considering our previous example, we will use the SRTM single-band image <code>elevationImage</code> and create a 'slope' image. Briefly, you calculate the slope by dividing the difference between the elevations of two points by the distance between them, then multiply the quotient by 100. The difference in elevation between points is called the rise. The distance between the points is called the run. Thus, percent slope equals (rise / run) x 100. Intuitively, you can think of doing this calculation manually by applying <code>.divide()</code> and <code>.multiply()</code>. However, as you will learn with this material, Google Earth Engine has specific methods within <code>ee</code> objects to perform computations such as slope, for example. Simply, you can create an the 'slope' image with the <code>slope</code> method of the <code>ee.Terrain</code> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var slope =<span class="st"> </span><span class="kw">ee.Terrain.slope</span>(elevationImage);</code></pre></div>
<p>Note that <code>elevationImage</code> was provided as an argument to the slope method! Add <code>slope</code> to the map and find Mount Nimba, in Liberia. Use a <code>min</code> and <code>max</code> values to reflect a resonable range of % slope.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(slope, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max <span class="op">:</span><span class="dv">50</span>}, <span class="st">&#39;Slope&#39;</span>);</code></pre></div>
<p>Explore the slope image around Mount Nimba, in Liberia. It should look like the figure below:</p>
<div class="figure"><span id="fig:Slope"></span>
<img src="images/PartI-Slope.png" alt="Slope image calculated with the `.slope()` method of the `ee.Terrain` package. Mount Nimba in Liberia is shown in white." width="858" />
<p class="caption">
Figure 1.34: Slope image calculated with the <code>.slope()</code> method of the <code>ee.Terrain</code> package. Mount Nimba in Liberia is shown in white.
</p>
</div>
<p>As mentioned before, there are also methods in the <code>ee.Image</code> container that can be invoked on an image object. We call it <em>band math</em> when you do mathematical operations with image bands. Still considering the previous example, suppose you are interested in further processing the slope image into an aspect image and then perform some trigonometric operations on it. Aspect, in this case, refers to the orientation of a slope, measured clockwise in degrees, from 0 to 360. Similarly to <code>.slope()</code>, <code>.aspect()</code> is also an method from <code>ee.Terrain</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var aspect =<span class="st"> </span><span class="kw">ee.Terrain.aspect</span>(elevationImage);</code></pre></div>
<p>Now, convert the image <code>aspect</code> into radians then calculate its sin:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var sinImage =<span class="st"> </span><span class="kw">aspect.divide</span>(<span class="dv">180</span>)<span class="kw">.multiply</span>(Math.PI)<span class="kw">.sin</span>()</code></pre></div>
<p>It is worth noting that the code above chained multiple methods. This way, you can perform complex mathematical operations. In other words, the code above is simply dividing the aspect by 180 (using the <code>.divide()</code> method), multiplying (with <code>.multiply()</code>) the result of that by π (that can be retrieved using <code>Math.PI</code>), and finally taking the sin (with <code>.sin()</code>). The result should look something like the figure below:</p>
<div class="figure"><span id="fig:Sin"></span>
<img src="images/PartI-Sin.PNG" alt="Aspect image calculated with the `.aspect()` method of the `ee.Terrain` package. The resulting SIN image from aspect reveals Mount Nimba in greater detail." width="858" />
<p class="caption">
Figure 1.35: Aspect image calculated with the <code>.aspect()</code> method of the <code>ee.Terrain</code> package. The resulting SIN image from aspect reveals Mount Nimba in greater detail.
</p>
</div>
<ul>
<li><strong>Band math with multi-band image</strong></li>
</ul>
<p>As mentioned previously, you can do mathematical operations with bands from a given image. One of the most common examples of band math with remote sensing imagery is the calculation of <em>spectral indices</em>. A <em>spectral index</em> is a mathematical equation that is applied on the various spectral bands of an image per pixel, with the objective of highlighting pixels showing the relative abundance or lack of the feature of interest. There are several categories of spectral indices that have been developed, using a variety of spectral bands to highlight different phenomena, such as water, snow, soil and vegetation. For example, <em>Vegetation Indices</em> (VIs) are combinations of surface reflectance at two or more wavelengths designed to highlight a particular property of vegetation.</p>
<p><em>A) NDVI</em></p>
<p>The most used index in this category is the <strong>Normalized Difference Vegetation Index (NDVI)</strong>, which provides an indication of abundance of live green vegetation (or abundance of chlorophyll). The pigment in plant leaves, chlorophyll, strongly absorbs visible light (from 0.4 to 0.7 µm) for use in photosynthesis. The cell structure of the leaves, on the other hand, strongly reflects near-infrared light (from 0.7 to 1.1 µm) (See Figure <a href="part-1-basics-fundamentals.html#fig:SpectralSignature">1.4</a>). Thus, NDVI is calculated by comparing the different reflectance values of the red and near-infrared bands (normalized such that the minimum value is -1.0, and the maximum is +1.0).</p>
<p>Bringing this concept to the context of a Landsat 8 image, we can produce an NDVI image by computing the normalized difference between its bands 5 (near-infrared) and 4 (red) (See Figure <a href="part-1-basics-fundamentals.html#fig:L8bands">1.26</a>).</p>
<p>For this example, we will use <code>ImageL8</code> created in the previous sections to create a NDVI image. We can use the method <code>.select()</code> on a <code>ee.Image</code> object to select any given band. The <code>.select()</code> method will take a string as an argument for the band name you want to select. Then we can use the mathematical operators to perform a normalized difference using these bands:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var nirBand =<span class="st"> </span><span class="kw">ImageL8.select</span>(<span class="st">&#39;SR_B5&#39;</span>);
var redBand =<span class="st"> </span><span class="kw">ImageL8.select</span>(<span class="st">&#39;SR_B4&#39;</span>);
var NDVI =<span class="st"> </span><span class="kw">nirBand.subtract</span>(redBand)<span class="kw">.divide</span>(<span class="kw">nirBand.add</span>(redBand));</code></pre></div>
<p>There is another way of doing the same calculation from the code above. As we seen previously, Earth Engine usually have methods for widely used operations and computations with remote sensing data. In this case, the normalized difference operation is available as a shortcut method <code>.normalizedDifference()</code> for a <code>ee.Image()</code> object. It take as an argument a list with the names of the bands you wish to calculate the normalized difference with. Thus, <code>NDVI</code> can be rewritten as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var NDVI =<span class="st"> </span><span class="kw">ImageL8.normalizedDifference</span>([<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>])</code></pre></div>
<p>You can then visualize this NDVI image by adding it to the Map Editor. Add it to the map and use the <strong>Inspector</strong> tab to investigate the range of values of NDVI around Cairo:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(NDVI, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="fl">0.3</span>, palette<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;a6611a&#39;</span>, <span class="st">&#39;f5f5f5&#39;</span>, <span class="st">&#39;4dac26&#39;</span>]}, <span class="st">&#39;NDVI Image&#39;</span>);</code></pre></div>
<p>You should see something like this:</p>
<div class="figure"><span id="fig:NDVI"></span>
<img src="images/PartI-NDVI.png" alt="NDVI Image highlighting the agricultural area in the Nile Delta. With the visualization parameters provided above, higher values of NDVI (that is, higher content of chlorophyll in live green leaves) is shown in green. " width="856" />
<p class="caption">
Figure 1.36: NDVI Image highlighting the agricultural area in the Nile Delta. With the visualization parameters provided above, higher values of NDVI (that is, higher content of chlorophyll in live green leaves) is shown in green.
</p>
</div>
<p><em>A) EVI</em></p>
<p>EVI, or <strong>Enhanced Vegetation Index</strong>, is similar to NDVI and can be used to quantify vegetation greenness. However, EVI corrects for some atmospheric conditions and canopy background noise and <em>is more sensitive in areas with dense vegetation</em> where NDVI usually saturates. It incorporates an “L” value to adjust for canopy background, “C” values as coefficients for atmospheric resistance, and values from the blue band (B):</p>
<p><strong>EVI = 2.5 * ((Near-infrared - Red) / (Near-infrared + C1 * Red – C2 * Blue + L))</strong>, where C1, C2 and L are usually 6, 7.5 and 1, respectively.</p>
<p>You can see that an expression like this can become hard to be expressed using mathematical operators such as the ones used to calculate a normalized difference. To implement more complex mathematical expressions, consider using the <code>.expression()</code> method for a <code>ee.Image</code> object. the first argument to <code>.expression()</code> is the textual representation (string) of the math operation, the second argument is a dictionary where the <em>keys</em> are variable names used in the expression and the <em>values</em> are the image bands to be used in the operation. Using the same <code>ImageL8</code> as an example, EVI would be defined as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var EVI =<span class="st"> </span><span class="kw">ImageL8.expression</span>(
    <span class="st">&#39;2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))&#39;</span>, {
      <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">ImageL8.select</span>(<span class="st">&#39;SR_B5&#39;</span>),
      <span class="st">&#39;RED&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">ImageL8.select</span>(<span class="st">&#39;SR_B4&#39;</span>),
      <span class="st">&#39;BLUE&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">ImageL8.select</span>(<span class="st">&#39;SR_B2&#39;</span>)
});</code></pre></div>
<p>The code above is able to regonize operators (+, -, *, /, %, **: Add, Subtract, Multiply, Divide, Modulus, Exponent) and the numbers; everything else is defined as keys in the dictionary.</p>
<p>Can you think of how you can calculate the NDVI using the code structure above?</p>
</div>
<div id="compositing-and-mosaicking" class="section level3">
<h3><span class="header-section-number">1.2.2</span> Compositing and Mosaicking</h3>
<p>Compositing is an example of a computation that can be done to a image collection. In general, <em>compositing</em> refers to the process of combining spatially overlapping images into a single image based on an aggregation function while <em>mosaicking</em> usually refers to the assembly of these images to produce a spatially contiguous one. In Earth Engine, when you composite two scenes that do not overlap completely, the resulting composite will be a composited mosaic:</p>
<div class="figure"><span id="fig:Composite"></span>
<img src="images/PartI-Composite.png" alt="Compositing images in Earth Engine. When applying a compositing function to scenes that do not overlap completely (B), the resulting composite will be a spatially contiguous image." width="1000" />
<p class="caption">
Figure 1.37: Compositing images in Earth Engine. When applying a compositing function to scenes that do not overlap completely (B), the resulting composite will be a spatially contiguous image.
</p>
</div>
<p>Thefore, in the context of Earth Engine these terms are used interchangeably. We illustrate these concepts with the examples below.</p>
<ul>
<li><strong>Example 1: Compositing the same scene (100% overlap)</strong></li>
</ul>
<p>In this example, we will use <code>collectionFiltered</code> (a Landsat 8 image collection filtered for Cairo from January to April 2022. <em>See</em> <a href="part-1-basics-fundamentals.html#fig:Collection">1.33</a>). There are several aggregation functions that can be used to composite an image collection, most notably <code>.max()</code> for a maximum value composite and <code>.mendian()</code> for a median value composite. All these functions will aggregate the values on a per-pixel, per-band basis. In other words, <code>.max()</code> will select the maximum value of a given pixel for each image band to create the final composite while <code>.median()</code> will calculate the median value of each band for this pixel.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var compositeMax =<span class="st"> </span><span class="kw">collectionFiltered.max</span>();
var compositeMedian =<span class="st"> </span><span class="kw">collectionFiltered.median</span>();</code></pre></div>
<div class="rmdcomment">
<p>
If you print these composites to the <strong>Console</strong> you will notice that they are a 19-band single image and no longer a collection with 13 images with 19 bands each!
</p>
</div>
<p>Add these composites to the Map Editor to investigate their differences:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(compositeMax, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>, <span class="st">&#39;SR_B3&#39;</span>, <span class="st">&#39;SR_B2&#39;</span>], min<span class="op">:</span><span class="dv">8000</span>, max<span class="op">:</span><span class="dv">30000</span>}, <span class="st">&#39;Composite Max&#39;</span>);
<span class="kw">Map.addLayer</span>(compositeMedian, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>, <span class="st">&#39;SR_B3&#39;</span>, <span class="st">&#39;SR_B2&#39;</span>], min<span class="op">:</span><span class="dv">8000</span>, max<span class="op">:</span><span class="dv">30000</span>}, <span class="st">&#39;Composite Median&#39;</span>);</code></pre></div>
<p><em>Question</em>: What is the most evident difference between these composites?</p>
<p><strong>Answer</strong>: The max value composite is mostly covered by clouds. Clouds and snow are very reflective and will always have high reflectance values for the regions of the electromagnetic spectrum covered by the Landsat spectral bands. Therefore, a maximum value composite will likely highlight these features - which is not desireable in most cases.</p>
<div class="figure"><span id="fig:Composites"></span>
<img src="images/PartI-Composites.png" alt="Maximum and median value composites. Clouds are evident in the maximum value composite due to their high reflectance values." width="1427" />
<p class="caption">
Figure 1.38: Maximum and median value composites. Clouds are evident in the maximum value composite due to their high reflectance values.
</p>
</div>
<div class="rmdcomment">
<p>
Although there are different methods for compositing, the median composite method is the state of the art in Google Earth Engine and has been applied to a multitude of studies using multitemporal remote sensing data.
</p>
</div>
<ul>
<li><strong>Example 2: Compositing (mosaicking) different scenes</strong></li>
</ul>
<p>Consider the need to composite (mosaic) four different Landsat scenes at different locations. For that we will edit the location parameter from <code>.filterBounds()</code> to include extra Landsat scenes from different locations. Use the information from figures <a href="part-1-basics-fundamentals.html#fig:Tools">1.31</a> and <a href="part-1-basics-fundamentals.html#fig:point">1.32</a> to create a geometry covering a larger area. Remember that <code>.filterBounds()</code> will filter an image collection to all the scenes that intercept the boundaries of a geometry, whether it is a line, point mark or polygon. Rename this as 'aoi2'. For this example, we will use the polygon tool to draw a large polygon over a large area in Egypt.</p>
<div class="figure"><span id="fig:aoi2"></span>
<img src="images/PartI-aoi2.png" alt="Area of interest (aoi) for filtering image collection." width="858" />
<p class="caption">
Figure 1.39: Area of interest (aoi) for filtering image collection.
</p>
</div>
<p>We will use this geometry to filter <code>collection</code> to this new spatial filter <code>aoi2</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var collectionFiltered2 =<span class="st"> </span><span class="kw">collection.filterBounds</span>(aoi2)<span class="kw">.filterDate</span>(startDate,endDate);
<span class="kw">print</span>(collectionFiltered2);</code></pre></div>
<div class="rmdcomment">
<p>
Note that if you print <code>collectionFiltered2</code> to the <strong>Console</strong> you will notice that it includes more images than when we filtered for a single location using a point geometry.
</p>
</div>
<p>Using the same compositing functions described earlier in this section, we will composite this new collection to two new composites. Also, we will use the <code>.mosaic()</code> method as a comparison. This method composites overlapping images according to their order in the collection (last on top):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var compositeMax2 =<span class="st"> </span><span class="kw">collectionFiltered2.max</span>();
var compositeMedian2 =<span class="st"> </span><span class="kw">collectionFiltered2.median</span>();
var mosaic =<span class="st"> </span><span class="kw">collectionFiltered2.mosaic</span>();

<span class="kw">Map.addLayer</span>(compositeMax2, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>, <span class="st">&#39;SR_B3&#39;</span>, <span class="st">&#39;SR_B2&#39;</span>], min<span class="op">:</span><span class="dv">8000</span>, max<span class="op">:</span><span class="dv">30000</span>}, <span class="st">&#39;Composite Max 2&#39;</span>);
<span class="kw">Map.addLayer</span>(compositeMedian2, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>, <span class="st">&#39;SR_B3&#39;</span>, <span class="st">&#39;SR_B2&#39;</span>], min<span class="op">:</span><span class="dv">8000</span>, max<span class="op">:</span><span class="dv">30000</span>}, <span class="st">&#39;Composite Median 2&#39;</span>);
<span class="kw">Map.addLayer</span>(mosaic, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>, <span class="st">&#39;SR_B3&#39;</span>, <span class="st">&#39;SR_B2&#39;</span>], min<span class="op">:</span><span class="dv">8000</span>, max<span class="op">:</span><span class="dv">30000</span>}, <span class="st">&#39;Mosaic&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:mosaics"></span>
<img src="images/PartI-Mosaics.png" alt="Composites of an image collection filtered by the bounds of `aoi2`." width="1368" />
<p class="caption">
Figure 1.40: Composites of an image collection filtered by the bounds of <code>aoi2</code>.
</p>
</div>
<p>Whether you are compositing using an aggregation function or mosaicking with <code>.mosaic()</code> the result will be similar in respect to the output type (i.e. an ee.Image object) and spatial extent. Thus, explaining why compositing and mosaicking are used interchangeably in Earth Engine.</p>
<p>Suppose you are only interested in the composite within the bounds of your area of interest. The method <code>.clip()</code> of an <code>ee.Image()</code> allows you to clip (or cut) any image to the shape of a geometry. We will use <code>compositeMedian2</code> and <code>aoi2</code> as an example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var compositeClipped =<span class="st"> </span><span class="kw">compositeMedian2.clip</span>(aoi2);
<span class="kw">Map.addLayer</span>(compositeClipped, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>, <span class="st">&#39;SR_B3&#39;</span>, <span class="st">&#39;SR_B2&#39;</span>], min<span class="op">:</span><span class="dv">8000</span>, max<span class="op">:</span><span class="dv">30000</span>}, <span class="st">&#39;Composite Median 2 clipped&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:clip"></span>
<img src="images/PartI-Clip.png" alt="Median composite clipped by the extent of `aoi2`." width="856" />
<p class="caption">
Figure 1.41: Median composite clipped by the extent of <code>aoi2</code>.
</p>
</div>
<div class="caution">
<p>
You can only clip an ee.Image() object, <strong>never an image collection!</strong> ``
</p>

<h1 id="part-2---advanced-google-earth-engine">
PART 2 - Advanced Google Earth Engine
</h1>
<h2 id="advanced-image-manipulation-pre-classification">
Advanced Image Manipulation: Pre-classification
</h2>
<p>
In this section we will provide functions and lines of code to assist the user to prepare, process and analyze Landsat 8 data for classification purposes.
</p>
<h3 id="cloud-and-cloud-shadow-masking">
Cloud and cloud shadow masking
</h3>
<p>
This sub-section demonstrates a way of masking clouds and cloud shadow pixels from Landsat 8 Surface Reflectance Collection 2 data based on file metadata. You may have noticed when exploring Landsat images in the <strong>Console</strong> tab that these images have a band called <code>QA_PIXEL</code> or <em>Quality Assessment</em> band. Briefly, this band contains values that represent bit-packed combinations of surface, atmospheric, and sensor conditions that can affect the overall usefulness of a given pixel. One of the many bits represented in this band is <em>cloud</em> (bit 3) and <em>cloud shadow</em> (bit 4):
</p>
</div>
<div class="figure"><span id="fig:QA"></span>
<img src="images/PartII-QABand.png" alt="Landsat's Quality Assessment (QA) band." width="884" />
<p class="caption">
Figure 1.42: Landsat's Quality Assessment (QA) band.
</p>
</div>
<p>In essence, these values indicate which pixels might be affected by surface conditions such as cloud contamination. Therefore, this band can be used to construct filters to mask (or remove) pixels flagged as 'affected' by that condition. Here, we will provide a function for masking clouds and cloud shadow from Landsat 8 images based on the information stored in the <em>Quality Assessment</em> band. This function was created based on the documentation available for Landsat 8. Values for pixel bit and pixel band were found <a href="https://www.usgs.gov/core-science-systems/nli/landsat/landsat-collection-1-level-1-quality-assessment-band?qt-science_support_page_related_con=0#qt-science_support_page_related_con" target="_blank"><em>here.</em></a></p>
<p>The cloud masking function is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">function</span> <span class="kw">maskClouds</span>(image) {
  var cloudShadowBitMask =<span class="st"> </span><span class="kw">ee.Number</span>(<span class="dv">2</span>)<span class="kw">.pow</span>(<span class="dv">3</span>)<span class="kw">.int</span>();
  var cloudsBitMask =<span class="st"> </span><span class="kw">ee.Number</span>(<span class="dv">2</span>)<span class="kw">.pow</span>(<span class="dv">4</span>)<span class="kw">.int</span>();
  var QA =<span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;QA_PIXEL&#39;</span>);
  var mask =<span class="st"> </span><span class="kw">QA.bitwiseAnd</span>(cloudShadowBitMask)<span class="kw">.eq</span>(<span class="dv">0</span>)
      <span class="kw">.and</span>(<span class="kw">QA.bitwiseAnd</span>(cloudsBitMask)<span class="kw">.eq</span>(<span class="dv">0</span>));
  return <span class="kw">image.updateMask</span>(mask)<span class="kw">.divide</span>(<span class="dv">100000</span>)<span class="kw">.select</span>(<span class="st">&quot;SR_B[0-9]*&quot;</span>)<span class="kw">.copyProperties</span>(image, [<span class="st">&quot;system:time_start&quot;</span>]);
}</code></pre></div>
<p>Do not worry about the new methods within this function. What you need to know is that this function was constructed in a way that we are selecting the <code>QA_PIXEL</code> band from the Landsat image and creating a mask where only pixels flagged to 0 (indicating clear conditions) for bits 3 and 4 will be included; The function will return <code>image</code> - in this case the Landsat 8 image - masked for pixels that are not flagged 0 for bits 3 and 4. The <code>.divide()</code> was used simply to scale the band values to [0,1] and <code>.select()</code> to only select the spectral bands from Landsat (SR_B1-9). These steps are not necessary for the cloud masking to work! However, we can add these extra steps to further improve our image collection.</p>
<p>Now, to apply a function to every image in an image collection, we use the <code>.map()</code> method from the <code>ee.ImageCollection()</code> object. You can refer to the <strong>Docs</strong> tab for more information on the methods available for <code>ee.ImageCollection()</code>. The only argument to <code>map()</code> is a function which takes one single parameter: an <code>ee.Image()</code>. Using <code>.map(maskClouds)</code> over an image collection will result in a collection where every image is masked for clouds and cloud shadows.</p>
<p>To illustrate this, we will apply <code>maskClouds</code> over <code>collection</code> (created in the previous chapter) along with the same temporal and spatial filters to recreate <code>collectionFiltered</code>. Feel free to use your previous chapter's script and simply add <code>.map()</code> to the collections using the code below as an example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var collection =<span class="st"> </span><span class="kw">ee.ImageCollection</span>(<span class="st">&#39;LANDSAT/LC08/C02/T1_L2&#39;</span>);
var startDate =<span class="st"> &#39;2022-01-01&#39;</span>;
var endDate =<span class="st"> &#39;2022-04-30&#39;</span>;

var collectionFilteredMasked =<span class="st"> </span><span class="kw">collection.filterBounds</span>(aoi)
                                   <span class="kw">.filterDate</span>(startDate,endDate)
                                   <span class="kw">.map</span>(maskClouds);</code></pre></div>
<p>Now, we will create a max value composite and compare it to the previous composite created with an image collection that <strong>was not masked for clouds and cloud shadows</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var compositeMax =<span class="st"> </span><span class="kw">collectionFilteredMasked.max</span>();
<span class="kw">Map.addLayer</span>(compositeMax, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>, <span class="st">&#39;SR_B3&#39;</span>, <span class="st">&#39;SR_B2&#39;</span>], min<span class="op">:</span><span class="dv">0</span>, max<span class="op">:</span><span class="fl">0.25</span>}, <span class="st">&#39;Composite Max Value&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:CompositesMasked"></span>
<img src="images/PartII-CompositesMasked.png" alt="A maximum value composite created with an image collection masked by clouds compared to a composite created using an unmasked collection." width="1264" />
<p class="caption">
Figure 1.43: A maximum value composite created with an image collection masked by clouds compared to a composite created using an unmasked collection.
</p>
</div>
<p>As mentioned in the previous chapter, a maximum value composite will likely highlight clouds as they are very reflective. However, by removing the cloud pixels from the images based on the Quality Assessment band information, the resulting maximum value composite greatly improves.</p>
</div>
<div id="spectral-indices" class="section level3">
<h3><span class="header-section-number">1.2.3</span> Spectral indices</h3>
<p>In the previous sub-section, we presented a function to mask cloud and cloud shadows from Landsat image collections. A function can also be created to perform band math to every image in an image collection. Building on the concepts of vegetation indices presented on the previous chapter, we will create a function that will calculate several vegetation indices for Landsat 8 images. You will recognize the NDVI and EVI indices from the previous chapters. This function includes other commonly used spectral indices to highlight features like open water, moisture, vegetation and soil:</p>
<ul>
<li>NDVI - Normalized Difference Vegetation Index;</li>
<li>NBR - Normalized Burn Ratio;</li>
<li>NDMI - Normalized Difference Mangrove Index;</li>
<li>MNDWI - Modified Normalized Difference Water Index;</li>
<li>SR - Simple Ratio;</li>
<li>BI - Bare soil Index;</li>
<li>GCVI - Green Chlorophyll Vegetation Index;</li>
<li>EVI - Enhanced Vegetation Index, and;</li>
<li>MSAVI - Modified Soil-Adjusted Vegetation Index.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">function</span> <span class="kw">addIndices</span>(image) {
  var ndvi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B4&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NDVI&#39;</span>);
  var nbr =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B7&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NBR&#39;</span>);
  var ndmi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B7&#39;</span>,<span class="st">&#39;SR_B3&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NDMI&#39;</span>);
  var mndwi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B3&#39;</span>,<span class="st">&#39;SR_B6&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;MNDWI&#39;</span>);
  var sr =<span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>)<span class="kw">.divide</span>(<span class="kw">image.select</span>(<span class="st">&#39;SR_B4&#39;</span>))<span class="kw">.rename</span>(<span class="st">&#39;SR&#39;</span>);
  var bare =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B6&#39;</span>,<span class="st">&#39;SR_B7&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;BI&#39;</span>);
  var gcvi =<span class="st"> </span><span class="kw">image.expression</span>(<span class="st">&#39;(NIR/GREEN)-1&#39;</span>,{
    <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>),
    <span class="st">&#39;GREEN&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B3&#39;</span>)
  })<span class="kw">.rename</span>(<span class="st">&#39;GCVI&#39;</span>);
  var evi =<span class="st"> </span><span class="kw">image.expression</span>(
  <span class="st">&#39;2.5 * ((NIR-RED) / (NIR + 6 * RED - 7.5* SR_BLUE +1))&#39;</span>, {
    <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>),
    <span class="st">&#39;RED&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B4&#39;</span>),
    <span class="st">&#39;SR_BLUE&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B2&#39;</span>)
  })<span class="kw">.rename</span>(<span class="st">&#39;EVI&#39;</span>);
  var msavi =<span class="st"> </span><span class="kw">image.expression</span>(
  <span class="st">&#39;(2 * NIR + 1 - sqrt(pow((2 * NIR + 1), 2) - 8 * (NIR - RED)) ) / 2&#39;</span>, {
    <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>), 
    <span class="st">&#39;RED&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;SR_B4&#39;</span>)}
)<span class="kw">.rename</span>(<span class="st">&#39;MSAVI&#39;</span>);
    return image
    <span class="kw">.addBands</span>(ndvi)
    <span class="kw">.addBands</span>(nbr)
    <span class="kw">.addBands</span>(ndmi)
    <span class="kw">.addBands</span>(mndwi)
    <span class="kw">.addBands</span>(sr)
    <span class="kw">.addBands</span>(evi)
    <span class="kw">.addBands</span>(msavi)
    <span class="kw">.addBands</span>(gcvi)
    <span class="kw">.addBands</span>(bare);
}</code></pre></div>
<p>The <code>.addBands()</code> method is used to include an <code>ee.Image()</code> as a band to an existing image. Therefore, this function will calculate each index and include them as extra bands to every image in the image collection.</p>
<p>As in the previous sub-section, we can use <code>.map()</code> to map this function over <code>collection</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var collectionFilteredwithIndex =<span class="st"> </span><span class="kw">collection.filterBounds</span>(aoi)
                                   <span class="kw">.filterDate</span>(startDate,endDate)
                                   <span class="kw">.map</span>(maskClouds)
                                   <span class="kw">.map</span> (addIndices);</code></pre></div>
<p>Then we will create median composite based on this new collection. We will add it to the <strong>Map Editor</strong> and will use the <strong>Inspector</strong> tab to explore its band values at a given location:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var compositeMedian =<span class="st"> </span><span class="kw">collectionFilteredwithIndex.median</span>();
<span class="kw">Map.addLayer</span>(compositeMedian, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>, <span class="st">&#39;SR_B3&#39;</span>, <span class="st">&#39;SR_B2&#39;</span>], min<span class="op">:</span><span class="dv">0</span>, max<span class="op">:</span><span class="fl">0.25</span>}, <span class="st">&#39;Composite Median&#39;</span>);</code></pre></div>
<p>You can toggle the data view from chart to values with the chart/value view button:</p>
<div class="figure"><span id="fig:VIS"></span>
<img src="images/PartII-VIS.png" alt="A median composite created from the `collectionFilteredwithIndex` image collection. The function `addIndices` was used to calculate each index and add them as separate bands to every image in the collection. In this example, the spectral bands and spectral index values for a pixel at an arbitrary location within `compositeMedian`. You can toggle between the chart view and value view using the chart button (red circle)." width="614" />
<p class="caption">
Figure 1.44: A median composite created from the <code>collectionFilteredwithIndex</code> image collection. The function <code>addIndices</code> was used to calculate each index and add them as separate bands to every image in the collection. In this example, the spectral bands and spectral index values for a pixel at an arbitrary location within <code>compositeMedian</code>. You can toggle between the chart view and value view using the chart button (red circle).
</p>
</div>
</div>
</div>
<div id="supervised-classification-using-random-forest" class="section level2">
<h2><span class="header-section-number">1.3</span> Supervised Classification using Random Forest</h2>
<p>As seen in Part 1, <em>Interpretation and Analysis</em> is one of the building blocks of any remote sensing system (see <a href="part-1-basics-fundamentals.html#fig:FigBuildingBlocks">1.1</a>). Image classification is one of the many methods of image processing and it is the sole focus of this training material. So far, you have learned the basics of Java Script and Google Earth Engine and some pre-processing steps to perform an image classification using the Random Forest (RF) Classifier. Briefly, classifier is an ensemble of classification trees, where each tree contributes with a single vote for the assignment of the most frequent class to the input data. Different from Decision Trees, which use the best predictive variables at the split, RF uses a random subset of the predictive variables. To illustrate this concept, we will use a rather simplistic example:</p>
<p>Suppose you were given this list of attributes from three edible fruits:</p>
<div class="figure"><span id="fig:fruit"></span>
<img src="images/PartII-FruitList.png" alt="Simplistic list of predictive variables from three types of fruits." width="676" />
<p class="caption">
Figure 1.45: Simplistic list of predictive variables from three types of fruits.
</p>
</div>
<p>A random forest classifier can be created (or trained) using the sample above as a training sample set:</p>
<div class="figure"><span id="fig:RF"></span>
<img src="images/PartII-RF.png" alt="A Machine Learning Random Forest Classifier with 3 trees trained with the sample set above. Note that algorithm was able to 'learn' about each fruit separate them based on their attributes." width="983" />
<p class="caption">
Figure 1.46: A Machine Learning Random Forest Classifier with 3 trees trained with the sample set above. Note that algorithm was able to 'learn' about each fruit separate them based on their attributes.
</p>
</div>
<p>You can test this classifier and its accuracy using a testing sample set. A testing set is usually a subset of the training set that will be used only for testing the performance of the trained classifier. These testing samples will be run through each tree of the ensemble and the accuracy of the classifier will be based on whether or not it was able to classify that sample correctly:</p>
<div class="figure"><span id="fig:RFTesting"></span>
<img src="images/PartII-RFTesting.png" alt="Testing a trained Random Forest Classifier. A testing sample is used to assess whether or not the classifier is able to correctly classify them. In this example, this sample was correctly classified by 2 out of the 3 trees in the ensenble." width="994" />
<p class="caption">
Figure 1.47: Testing a trained Random Forest Classifier. A testing sample is used to assess whether or not the classifier is able to correctly classify them. In this example, this sample was correctly classified by 2 out of the 3 trees in the ensenble.
</p>
</div>
<p>You can then classify unlabeled samples using the trained classfier. The final classification of a sample is based upon the majority of the votes of the trees in the ensemble:</p>
<div class="figure"><span id="fig:RFClass"></span>
<img src="images/PartII-RFClass.png" alt="The trained RF classifier is used to classify an unlabeled fruit sample. In this case, the majority of the votes (2 out of 3) was BANANA. Therefore, the final classification of this sample is BANANA." width="968" />
<p class="caption">
Figure 1.48: The trained RF classifier is used to classify an unlabeled fruit sample. In this case, the majority of the votes (2 out of 3) was BANANA. Therefore, the final classification of this sample is BANANA.
</p>
</div>
<p>Even though this is a rather simplistic example, it can be easily translated into a land cover classification context: Instead of fruits, each unit being classified is a <strong>Landsat image pixel</strong>. Each pixel from each land cover class will contain different <strong>spectral attributes</strong>. These spectral attributes will be used at each branch of the trees in the ensemble. We can then used a trained Random Forest classifier to label hundreds of thousands Landsat pixels into different land cover classes. The RF is one of the most used and robust classifiers and it is fully implemented in GEE. In the following examples we will present the steps for land cover classification using the RF classifier and present some basic analysis that can be done using the classification output.</p>
<div id="example-1-land-cover-classification-of-greater-cairo-and-giza-area-egypt---year-2022" class="section level3">
<h3><span class="header-section-number">1.3.1</span> Example 1: Land cover classification of Greater Cairo and Giza area, Egypt - Year 2022</h3>
<p>The general steps for an image classification process with Landsat image is:</p>
<ol style="list-style-type: lower-alpha">
<li><p>To use a cloud-masking function to mask clouds on Landsat 8 Imagery;</p></li>
<li><p>To calculate spectral indices that will be used as predictors for the Random Forest;</p></li>
<li><p>To produce a cloud-free composite mosaic using the median reducer, and;</p></li>
<li><p>To select training samples;</p></li>
<li><p>To classify the cloud-free composite mosaic of Landsat 8 scenes using Random Forest.</p></li>
</ol>
<p>In this example we will classify the median composite (<code>compositeMedian</code>) created in the previous section. You can find the code for creating it <a href="https://code.earthengine.google.com/f6d329bb7a6dcec10609c118e0af57e7" target="_blank">here.</a></p>
<div class="rmdcomment">
<p>
You have the option to classify the entire scene or clip it to an area of interest. You can create a geometry <code>AreaOfInterest</code> and clip your composite using <code>.clip(AreaOfInterest)</code>. You can also customize the composite visualization parameters by clicking on the settings icon (gear ⚙) next to the layer name (in this example: 'Composite Median')
</p>
</div>
<p>So far, we have covered the steps <em><strong>a</strong></em>, <em><strong>b</strong></em> and <em><strong>c</strong></em>.</p>
<ul>
<li><strong>Training sample selection</strong></li>
</ul>
<p>For this example, let’s classify the 'composite' into four classes: <em>water</em>, <em>agricultural land</em>, <em>sand and bare areas</em> and <em>urbanization</em>. The first step is to create the training samples set to use into the Random Forest Model.</p>
<p><strong>Step 1</strong> - In the Geometry Imports, click <em><strong>+new layer</strong></em> and make four sets of geometries, each set will represent samples from the classes 'water', 'cropland', 'sand', and 'urban'.</p>
<div class="figure"><span id="fig:my-figGeom"></span>
<img src="images/Geometries.PNG" alt="Geometry sets to hold samples for each of the four classes." width="1550" />
<p class="caption">
Figure 1.49: Geometry sets to hold samples for each of the four classes.
</p>
</div>
<p><strong>Step 2</strong> - For each geometry in the list, click on the settings icon⚙: name them accordingly using the 'Name' box, choose a color for it using the color picker and import each geometry as <em>FeatureCollection</em>. Add a property called <em>landcover</em> by clicking on the <em><strong>+ Property</strong></em> and set a consecutive integer starting from 0 or 1 for each of the classes. You should achieve something similar to this:</p>
<div class="figure"><span id="fig:my-figGeom2"></span>
<img src="images/Geometries2.PNG" alt="Geometries used to create the training sample sets." width="830" />
<p class="caption">
Figure 1.50: Geometries used to create the training sample sets.
</p>
</div>
<p>Your Geometry Imports should look like this:</p>
<div class="figure"><span id="fig:my-figGeom3"></span>
<img src="images/Geo3.PNG" alt="Geometry Imports after creating geometry sets to hold training samples" width="994" />
<p class="caption">
Figure 1.51: Geometry Imports after creating geometry sets to hold training samples
</p>
</div>
<p>Start selecting samples by clicking on the ‘Water’ geometry in the Geometry Imports. Choose the point drawing tool and place some points along the River Nile:</p>
<div class="starcomment">
<p>
Take advantage of the high resolution imagery to help you select samples for each class. You can toggle in between map and Google Earth imagery by using the buttons <em><strong>Map</strong></em> and <em><strong>Satellite</strong></em> in the upper right corner of the Map Editor. You can also toggle the Landsat composite ON and OFF by using the layer manager.
</p>
</div>
<p>Instead of single points (i.e pixels), we can also use polygons containing a variable number of relatively homogenous pixels of a given land cover class. Switch to the polygon drawing tool and draw a few polygons over the River Nile:</p>
<div class="figure"><span id="fig:my-figNile"></span>
<img src="images/Nile.PNG" alt="Sample points and polygons for the Water class" width="1152" />
<p class="caption">
Figure 1.52: Sample points and polygons for the Water class
</p>
</div>
<div class="starcomment">
<p>
Once you finish selecting samples, click the <em><strong>Exit</strong></em> button on the polygon editor dialogue box . Repeat the process for each of the other class. Make sure you select samples that are representative of each land cover class by selecting points and polygons of homogenous pixels.
</p>
</div>
<div class="figure"><span id="fig:my-figAllSamples"></span>
<img src="images/AllSamples.PNG" alt="Example of sample points and polygons for ‘Water’ (blue), ‘Cropland’ (yellow), ‘Urban’ (red) and ‘Sand’ (pink). Each pixel within the polygons will be used as training inputs for the RF classifier." width="1370" />
<p class="caption">
Figure 1.53: Example of sample points and polygons for ‘Water’ (blue), ‘Cropland’ (yellow), ‘Urban’ (red) and ‘Sand’ (pink). Each pixel within the polygons will be used as training inputs for the RF classifier.
</p>
</div>
<p>After selecting the samples, we will merge all the geometries together into an object var classes using the <code>.merge</code> method of the <code>ee.FeatureCollection() object</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var classes =<span class="st"> </span><span class="kw">Water.merge</span>(Cropland)
                   <span class="kw">.merge</span>(Sand)
                   <span class="kw">.merge</span>(Urban);</code></pre></div>
<p><a href="https://code.earthengine.google.com/0666bce96ffb1bd350cfc738f7b2aeab" target="_blank">Code Checkpoint</a></p>
<ul>
<li><strong>Sample sets</strong></li>
</ul>
<p>In this section, we will create the training (and testing) sample sets to be used in the classification with Random Forest. First, we will select the predictors to assign to each sample point in the sample sets. For this example, we will create a list 'bands' with the names of three spectral bands (<code>'SR_B4'</code>,<code>'SR_B5'</code>,<code>'SR_B6'</code>) and the spectral indices (<code>'NDVI'</code>,<code>'NBR'</code>,<code>'MNDWI'</code>,<code>'SR'</code>,<code>'GCVI'</code> and <code>'MSAVI'</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var bands =<span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>,<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B6&#39;</span>,<span class="st">&#39;NDVI&#39;</span>,<span class="st">&#39;NBR&#39;</span>,<span class="st">&#39;MNDWI&#39;</span>,<span class="st">&#39;SR&#39;</span>,<span class="st">&#39;GCVI&#39;</span>,<span class="st">&#39;MSAVI&#39;</span>];</code></pre></div>
<p>Next, we will sample the Landsat pixels by overlaying the geometries with the composite using <code>.sampleRegions()</code>. The main arguments of this method is the image to sample (in this case, <code>compositeMedian</code>), the regions to sample over (in this case, <code>classes</code>) and the list of properties to copy from each geometry (in this case <strong>landcover</strong>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var samples =<span class="st"> </span><span class="kw">compositeMedian.select</span>(bands)<span class="kw">.sampleRegions</span>({
  collection<span class="op">:</span><span class="st"> </span>classes,       
  properties<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;landcover&#39;</span>],
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>                  
})<span class="kw">.randomColumn</span>(<span class="st">&#39;random&#39;</span>);</code></pre></div>
<p>In the <code>samples</code> object we have just created, each sample will include a column with the values from the list <code>bands</code> inherited from the <code>compositeMedian</code> and a column with their respective class label. Optionally, you can perform an accuracy assessment of the classifier by taking advantage of the identifiers assigned to the samples by the <code>.randomColumn('random')</code> within <code>samples</code>. This method adds a column to the feature collection populated with random numbers in the range of 0 to 1. For this example, we will randomly partition the sample set into <code>training</code> (80% of the samples) and <code>testing</code> (20% of the samples) samples by filtering the samples by its random number column using the lower (<code>.lt</code>) and greater than or equal (<code>.gte</code>) filters:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var split =<span class="st"> </span><span class="fl">0.8</span>;
var training =<span class="st"> </span><span class="kw">samples.filter</span>(<span class="kw">ee.Filter.lt</span>(<span class="st">&#39;random&#39;</span>, split));
var testing =<span class="st"> </span><span class="kw">samples.filter</span>(<span class="kw">ee.Filter.gte</span>(<span class="st">&#39;random&#39;</span>, split));</code></pre></div>
<p>For your information, you can inspect the size of a <code>ee.FeatureCollection</code> using the <code>.aggregate_count()</code> method. This method only takes a property of the feature collection being counted as its argument. In this case, we have a property called 'landcover' in our feature collection. <code>.aggregate_count()</code> It is a useful tool to extract the number of features on your sample set:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="st">&#39;Samples n =&#39;</span>, <span class="kw">samples.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));
<span class="kw">print</span>(<span class="st">&#39;Training n =&#39;</span>, <span class="kw">training.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));
<span class="kw">print</span>(<span class="st">&#39;Testing n =&#39;</span>, <span class="kw">testing.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));</code></pre></div>
<div class="rmdcomment">
<p>
If a feature collection do not have a property defined, you can still count its feature by using <code>'.all'</code> as an argument for <code>.aggregate_count()</code>.
</p>
</div>
<p>Using the split value above, roughtly 80% of the features in <code>samples</code> will be <code>training</code> and 20% will be in <code>testing</code>:</p>
<div class="figure"><span id="fig:my-fig39"></span>
<img src="images/Figure39.PNG" alt="Sample sets size for this example. Note that the number will vary based on the number of geometries (polygons and points) and the sample split value." width="628" />
<p class="caption">
Figure 1.54: Sample sets size for this example. Note that the number will vary based on the number of geometries (polygons and points) and the sample split value.
</p>
</div>
<ul>
<li><strong>Classification</strong></li>
</ul>
<p>Next, we will train a Random Forest classifier using the training sample set <code>training</code>. The Random Forest classifier <code>ee.Classifier.smileRandomForest</code> has several user-defined parameters. However, two of them are the most usually defined: the number of trees in the ensemble (a.k.a ‘forest’) and the number of predictors to randomly tested at each tree. Predictors, in this case, are the spectral bands and spectral indices associated to each training sample. If unspecified, it uses the square root of the number of predictors.</p>
<div class="caution">
<p>
<strong>Higher number of trees and number of predictors tested at each node do not mean better performance and overall accuracy</strong>.
</p>
</div>
<p>For this example, we will use <code>200</code> trees and <code>8</code> randomly selected predictors to use in each tree and train Random Forest model called 'classifier' using the <code>.train()</code> method on the <code>.ee.Classifier.smileRandomForest()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var classifier =<span class="st"> </span><span class="kw">ee.Classifier.smileRandomForest</span>(<span class="dv">100</span>,<span class="dv">5</span>)<span class="kw">.train</span>({
  features<span class="op">:</span><span class="st"> </span>training,
  classProperty<span class="op">:</span><span class="st"> &#39;landcover&#39;</span>, 
  inputProperties<span class="op">:</span><span class="st"> </span>bands
});</code></pre></div>
<p>In the <code>features</code> argument of the code above, make sure to select the predictors you want to use from the sample set (in this example, <code>training</code>) to train the model. In this case we are providing all of them. However, if you want to select a particular group of variables, you can use <code>.select(['variableName1','variableName2',..])</code>. Also, you must include the class property (<code>classProperty</code>) in which the class label is stored (in this example <code>'landcover'</code>).</p>
<p>You can test the accuracy of classifier by classifying the <code>testing</code> samples using <code>.classify()</code> method. Then, you can compute a 2D error matrix for the classified testing samples using <code>.errorMatrix()</code>. This method will output an <code>ee.ConfusionMatrix()</code> object by comparing the two columns of the classified testing samples: one containing the actual labels (in our case, the property called 'landcover'), and one containing predicted values by the classifier (which defaults to 'classification'). Finally, you can use <code>.accuracy()</code> method of the <code>ee.ConfusionMatrix()</code> object to compute the overall accuracy of the classifier:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var validation =<span class="st"> </span><span class="kw">testing.classify</span>(classifier);
var testAccuracy =<span class="st"> </span><span class="kw">validation.errorMatrix</span>(<span class="st">&#39;landcover&#39;</span>, <span class="st">&#39;classification&#39;</span>);

<span class="kw">print</span>(<span class="st">&#39;Validation error matrix RF: &#39;</span>, testAccuracy);
<span class="kw">print</span>(<span class="st">&#39;Validation overall accuracy RF in %: &#39;</span>, <span class="kw">testAccuracy.accuracy</span>()<span class="kw">.multiply</span>(<span class="dv">100</span>));</code></pre></div>
<p>As explained earlier, the trained classifier can be used to classify the <code>compositeMedian</code>. Google Earth Engine will run each pixel through each of the 200 trees in the classifier and assing it the label which had the majority of votes among all the tree:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var classification =<span class="st"> </span><span class="kw">compositeMedian.select</span>(bands)<span class="kw">.classify</span>(classifier);</code></pre></div>
<p>For visualization of the resulting classification output, we will create a color palette object <code>paletteMAP</code> with a list of colors for each class of the map. The order of the colors in the palette will follow the order of the classes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var paletteMAP =<span class="st"> </span>[
  <span class="st">&#39;#0040ff&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="kw">Water</span> (Class value <span class="dv">0</span>)
  <span class="st">&#39;#00ab0c&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Croplands <span class="op">/</span><span class="st"> </span>Cultivated <span class="kw">Areas</span> (Class value <span class="dv">1</span>)
  <span class="st">&#39;#fbf2ad&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Sand and bare <span class="kw">areas</span> (Class value <span class="dv">2</span>)
  <span class="st">&#39;#878587&#39;</span>   <span class="op">/</span><span class="er">/</span><span class="st"> </span>Built<span class="op">-</span>up and Urban <span class="kw">Areas</span> (Class value <span class="dv">3</span>)
];</code></pre></div>
<p>Finally, we will add <code>classification</code> to the map using <code>Map.addLayer()</code>: use <code>min: 0</code> (first class), <code>max: 3</code> (last class), add the color palette <code>paletteMAP</code> and a name for the layer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span> (classification, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">3</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Classification&#39;</span>);</code></pre></div>
<p>After several seconds, you should see something similar to the figure below:</p>
<div class="figure"><span id="fig:ClassificationResult"></span>
<img src="images/PartII-ClassificationResult.png" alt="Random Forest classification output for 2022." width="857" />
<p class="caption">
Figure 1.55: Random Forest classification output for 2022.
</p>
</div>
<p><a href="https://code.earthengine.google.com/0444f1f7cc9783f36f6f6cb9626713c5" target="_blank">Code Checkpoint</a></p>
<p>As an optional step, you can export your classification output as a Google Earth Engine asset. You can save geospatial datasets and analysis outputs into your Google Earth Engine account through the <strong>Assets</strong> tab and the left side of the code Editor.</p>
<div class="figure"><span id="fig:Assets"></span>
<img src="images/PartII-Assets.png" alt="Assets manager. Your Google Earth Engine account will be able to host around 200GB worth of assets. Externally imported assets as well as datasets exported from Earth Engine scripts will be found here." width="354" />
<p class="caption">
Figure 1.56: Assets manager. Your Google Earth Engine account will be able to host around 200GB worth of assets. Externally imported assets as well as datasets exported from Earth Engine scripts will be found here.
</p>
</div>
<div class="starcomment">
<p>
You can also upload external datasets into your Google Earth Engine Assets with the <strong>NEW</strong> button. (See Earth Engine's <a href="https://developers.google.com/earth-engine/guides/image_upload" target="_blank">Importing Raster Data</a> for instructions on uploading an image to your assets or <a href="https://developers.google.com/earth-engine/guides/table_upload" target="_blank">Importing Table/Shapefile Data</a> for more details).
</p>
</div>
<p>We will export <code>classification</code> with the <code>Export.image.toAsset()</code> method. This method takes a dictionary with several parameters such as:</p>
<ul>
<li><p><code>image</code>: the image object you want to export;</p></li>
<li><p><code>description</code>: a description to be showing on the <strong>Task</strong> tab. No spaces allowed;</p></li>
<li><p><code>assetId</code>: A name for your asset. No spaces allowed;</p></li>
<li><p><code>scale</code>: A scale to export;</p></li>
<li><p><code>region</code>: the region or area of your <code>image</code> you want to export. It takes a geometry/ feature collection;</p></li>
<li><p><code>maxPixels</code>: This is somewhat important argument. In order to avoid memory errors, the Earth Engine detault is 1x10e8 pixels. If you do not define your max pixels and your exports exceeds the default, you will get an error.</p></li>
</ul>
<p>We will create a geometry 'region' to encompass the entire classified scene in order to export the entire area. The code below will export the classification:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>classification,
  description<span class="op">:</span><span class="st"> &#39;ClassificationOutput&#39;</span>, 
  assetId<span class="op">:</span><span class="st"> &#39;Cairo2022&#39;</span>,
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>,
  region<span class="op">:</span><span class="st"> </span>region,
  maxPixels<span class="op">:</span><span class="fl">1e12</span>
});</code></pre></div>
<p>Running the code above, will create the exporting task named <em><strong>ClassificationOutput</strong></em> in the <strong>Tasks</strong> tab.</p>
<div class="figure"><span id="fig:Tasks"></span>
<img src="images/PartII-Tasks.png" alt="Tasks manager." width="540" />
<p class="caption">
Figure 1.57: Tasks manager.
</p>
</div>
<p>Clicking the <strong>Run</strong> button will start exporting your classification. You can check some of the parameters of the <code>Export.image.toAsset()</code> one more time before exporting the asset. You are allowed to change some of these parameters at this point. For our example, everything will follow the parameters we defined previously.</p>
<div class="figure"><span id="fig:ExportingAssets"></span>
<img src="images/PartII-ExportingAsset.png" alt="Tasks manager: Image Export." width="634" />
<p class="caption">
Figure 1.58: Tasks manager: Image Export.
</p>
</div>
<p>The time elapsed of your exporting task will be shown in the <strong>Tasks</strong> tab.</p>
<div class="figure"><span id="fig:TimeElapsed"></span>
<img src="images/PartII-TimeElapsed.png" alt="Once a task has started the time elapsed will be shown in the __Tasks__ tab." width="798" />
<p class="caption">
Figure 1.59: Once a task has started the time elapsed will be shown in the <strong>Tasks</strong> tab.
</p>
</div>
<p>I may take several minutes to export your classification image to your assets. Once your task is completed, it will be shown at the <strong>Task</strong> tab as:</p>
<div class="figure"><span id="fig:Exported"></span>
<img src="images/PartII-Exported.png" alt="Exported asset." width="800" />
<p class="caption">
Figure 1.60: Exported asset.
</p>
</div>
<p>Finally, your export will be available as an Earth Engine asset:</p>
<div class="figure"><span id="fig:ExportedAsset"></span>
<img src="images/PartII-FirstAsset.png" alt="Assets will be available through the __Assets__ tab. If they are not showing, try refreshing the folder with the refresh button." width="740" />
<p class="caption">
Figure 1.61: Assets will be available through the <strong>Assets</strong> tab. If they are not showing, try refreshing the folder with the refresh button.
</p>
</div>
</div>
<div id="example-2-2015---2022-map-to-map-change-of-greater-cairo-and-giza-area-egypt" class="section level3">
<h3><span class="header-section-number">1.3.2</span> Example 2: 2015 - 2022 Map-to-Map change of greater Cairo and Giza area, Egypt</h3>
<p>In this example, we will use the codes from <em><strong>Example 1</strong></em> to create a land cover classification for the year 2015 period. Following are the changes to be made on the codes from <em><strong>Example 1</strong></em>:</p>
<ol style="list-style-type: lower-alpha">
<li>The <code>year</code> object will have a value of <code>'2015'</code>;</li>
<li>Repeat the training sample selection to make sure the samples reflect the correct land cover class for the L8 composite in the year 2015.</li>
</ol>
<div class="rmdcomment">
<p>
You can access the edited script for two steps above <a href="https://code.earthengine.google.com/f2291692f2d12a7d6d80813e0436bad9" target="_blank">here.</a>
</p>
</div>
<p>After following the 2 steps above, you should achieve a similar output as before:</p>
<div class="figure"><span id="fig:Cairo2015"></span>
<img src="images/PartII-Cairo2015.png" alt="Random Forest classification output for 2015." width="858" />
<p class="caption">
Figure 1.62: Random Forest classification output for 2015.
</p>
</div>
<p>Export this new classification to you assets. Next, <a href="https://code.earthengine.google.com/" target="_blank">open a new code editor page</a> and add the classification exports to this script by clicking the <em><strong>Import into script</strong></em> button (blue arrow) for both classification assets in the <strong>Assets</strong> tab:</p>
<div class="figure"><span id="fig:imports"></span>
<img src="images/PartII-Imports.png" alt="Assets tab with classification maps. Clicking in the __Import into script__ button will add the assets to the script." width="764" />
<p class="caption">
Figure 1.63: Assets tab with classification maps. Clicking in the <strong>Import into script</strong> button will add the assets to the script.
</p>
</div>
<p>Finally, rename each import by clicking on their names at the <em><strong>Imports</strong></em> header:</p>
<div class="figure"><span id="fig:importsheader"></span>
<img src="images/PartII-ImportsHeader.png" alt="Imports header. You can rename imported assets by clicking on its name." width="756" />
<p class="caption">
Figure 1.64: Imports header. You can rename imported assets by clicking on its name.
</p>
</div>
<p>Alternatively, you can import assets to your scripts by using <code>ee.Image()</code> and their respective asset directory. For this example, you can use:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var Cairo2015 =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&quot;users/capacityBuilding/Cairo2015&quot;</span>);
var Cairo2022 =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&quot;users/capacityBuilding/Cairo2022&quot;</span>);</code></pre></div>
<p>Add <code>Cairo2015</code> and <code>Cairo2022</code> to the map using the code below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var paletteMAP =<span class="st"> </span>[
  <span class="st">&#39;#0040ff&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Water <span class="op">-</span><span class="st"> </span>pixel value =<span class="st"> </span><span class="dv">0</span>
  <span class="st">&#39;#00ab0c&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Croplands <span class="op">/</span><span class="st"> </span>Cultivated Areas <span class="op">-</span><span class="st"> </span>pixel value =<span class="st"> </span><span class="dv">1</span>
  <span class="st">&#39;#fbf2ad&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Sand and bare areas <span class="op">-</span><span class="st"> </span>pixel value =<span class="st"> </span><span class="dv">2</span>
  <span class="st">&#39;#878587&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Built<span class="op">-</span>up and Urban Areas <span class="op">-</span><span class="st"> </span>pixel value =<span class="st"> </span><span class="dv">3</span>
];

<span class="kw">Map.addLayer</span>(Cairo2015, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">3</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Cairo2015&#39;</span>);
<span class="kw">Map.addLayer</span>(Cairo2022, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">3</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Cairo2022&#39;</span>);</code></pre></div>
<p>You can examine both layers on the map and try to identify areas where classes have changed in the 7 years period. However, we can use a transition error matrix to quickly quantify these changes. This matrix can be used to assess how much each class has changed and to what they have changed based on sampling design of your choosing. To do that, we will start by stacking both maps <code>Cairo2015</code> and <code>Cairo20222</code> into a single object <code>stackedClassifications</code> and rename Cairo2015 and Cairo2022 as <code>'before'</code> and <code>'later'</code>, respectively:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var stackedClassifications =<span class="st"> </span><span class="kw">Cairo2018.rename</span>(<span class="st">&#39;later&#39;</span>)<span class="kw">.addBands</span>(<span class="kw">Cairo2000.rename</span>(<span class="st">&#39;before&#39;</span>));</code></pre></div>
<p>Next, we will create a testing sample set with 1000 points for each class using a stratified random sampling design. In this sampling design each class has the same weight. Therefore, the same number of points will be placed in each class, regardless of its relative extent. This is important to consider as some classes may have very small area extent to be captured by a random sampling design. In this example, water bodies is relatively small compared to the other three land cover classes. Thus, a stratified sampling design will ensure that this class will have the same number of points. We can used <code>.stratifiedSample()</code> method. This method takes a dictionary with several parameters such as:</p>
<ul>
<li><p><code>numPoints</code>: Number of points you want to select by each class;</p></li>
<li><p><code>classBand</code>: The classification you want the sample points to inherit the class labels from;</p></li>
<li><p><code>scale</code>: Always remember to set the scale to match Landsat nomimal spatial resolution (30 m)</p></li>
</ul>
<div class="rmdcomment">
<p>
Always remember to check the <strong>Docs</strong> tab for more information on the parameters each method takes!
</p>
</div>
<p>Using the information above, a stratified sample set can be created as following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var samples =<span class="st"> </span><span class="kw">stackedClassifications.stratifiedSample</span>({
numPoints<span class="op">:</span><span class="st"> </span><span class="dv">1000</span>,        
classBand<span class="op">:</span><span class="st"> &quot;before&quot;</span>,   
scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>,             
geometries<span class="op">:</span><span class="st"> </span>true
});</code></pre></div>
<p>Once the points are placed, they will inherit the class label (pixel value) from <code>Cairo2015</code> (<code>'before'</code>):</p>
<p>We can add the samples to the map using <code>Map.addLayer()</code>. To colorize geometries, you use the <code>color</code> paramenter instead of <code>palette</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(samples, {color<span class="op">:</span><span class="st">&#39;black&#39;</span>}, <span class="st">&#39;Stratified samples&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:StratSamples"></span>
<img src="images/PartII-StratSamples.png" alt="Stratified samples. 1000 samples were randomly selected within each strata (class)." width="855" />
<p class="caption">
Figure 1.65: Stratified samples. 1000 samples were randomly selected within each strata (class).
</p>
</div>
<p>Next, we will create a transition matrix using the samples above. This matrix will show how many of these 1000 remained the same land cover class 7 years later (<code>Cairo2022</code>) and how many of them changed to a given class. You can use <code>.accuracy()</code> to calculate the % of these samples remained unchanged between the two periods:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var transitionMatrix =<span class="st"> </span><span class="kw">samples.errorMatrix</span>({
  actual<span class="op">:</span><span class="st"> &#39;before&#39;</span>,
  predicted<span class="op">:</span><span class="st"> &#39;later&#39;</span>
});

<span class="kw">print</span>(<span class="st">&#39;Transition Matrix&#39;</span>, transitionMatrix);
<span class="kw">print</span>(<span class="st">&#39;% of Unchanged Samples: &#39;</span>, <span class="kw">transitionMatrix.accuracy</span>()<span class="kw">.multiply</span>(<span class="dv">100</span>));</code></pre></div>
<p>The matrix will be printed to the <em><strong>Console</strong></em> tab. The code above should produce something similar to figure below:</p>
<div class="figure"><span id="fig:matrix"></span>
<img src="images/PartII-Matrix.png" alt="Transition matrix based on the 4000 (1000 for each class) samples." width="800" />
<p class="caption">
Figure 1.66: Transition matrix based on the 4000 (1000 for each class) samples.
</p>
</div>
<p>In the transition matrix above you can draw information about how many samples transitioned to each class from 2015 to 2022. For example, from the 1000 samples of agriculture class (pixel value 1), 4 was classified (or ‘transitioned’) to water, 8 to sand and 53 to urban areas in 2022. 935 of them remained unchanged. Overall, 87% of these samples from all classes remained unchanged.</p>
<ul>
<li><strong>Cropland area expansion and conversion in the Nile Delta from 2015-2022</strong></li>
</ul>
<p>Another quick analysis that can be done with land cover class maps in two points in time is highlighting areas in which a particular class has changed. In this example, we will assess the cultivated/cropland change between the 2015 and 2022. First, we will isolate the agricultural land class (pixel value <code>1</code>) from both years into separate objects <code>class2015</code> and <code>class2022</code> using the <code>.select()</code> and <code>.eq()</code> methods. Secondly, we will calculate the change by simply subtracting both objects:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var class2015 =<span class="st"> </span><span class="kw">Cairo2015.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>);
var class2022 =<span class="st"> </span><span class="kw">Cairo2022.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>);
var change =<span class="st"> </span><span class="kw">class2022.subtract</span>(class2015);</code></pre></div>
<p>By default, the new objects <code>class2015</code> and <code>class2022</code> will have values of 1 where the <code>'classification'</code> has the label equals (<code>.eq</code>) to 1 (agriculture) in the land cover map. <strong>This will be the case regardless of the label value</strong>. By using the <code>.select()</code> and <code>.eq()</code>, the new image object will default to value of 1 where that condition was met. Thus, the object <code>change</code> will have values of <code>-1</code>, <code>0</code> and <code>1</code>, that represents loss/conversion, no change and gains, respectively:</p>
<ul>
<li><p><code>-1</code> = No crops in 2022 - crops in 2015 (0 - 1 = -1);</p></li>
<li><p><code>0</code> = crops in 2022 - crops in 2015 (1 - 1 = 0);</p></li>
<li><p><code>1</code> = crops in 2022 - no crops in 2015 (1 - 0 = 1)</p></li>
</ul>
<p>We will add <code>change</code> to the map.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var paletteCHANGE =<span class="st"> </span>[
  <span class="st">&#39;red&#39;</span>,    <span class="op">/</span><span class="er">/</span><span class="st"> </span>Loss<span class="op">/</span>conversion
  <span class="st">&#39;white&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>No Change
  <span class="st">&#39;green&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Gain<span class="op">/</span>Expansion
];

<span class="kw">Map.addLayer</span>(change, {palette<span class="op">:</span><span class="st"> </span>paletteCHANGE}, <span class="st">&#39;Change 2015-2022&#39;</span>);</code></pre></div>
<p>The resulting change map will look similar to figure below. Green pixels represent 'gains' while red pixels represent 'conversions':</p>
<div class="figure"><span id="fig:change"></span>
<img src="images/PartII-Change.png" alt="Subset of the 2015-2022 Change Map. Conversion/loss of classifiedagricultural areas." width="1460" />
<p class="caption">
Figure 1.67: Subset of the 2015-2022 Change Map. Conversion/loss of classifiedagricultural areas.
</p>
</div>
<p>This code can easily be used to investigate the other classes as well. Simply change the class value within <code>.select(['classification']).eq(classValueHere)</code>.</p>
<p>In the example below, we changed the value from <code>1</code> to <code>3</code> to highlight the expansion of urban/built up areas.</p>
<div class="figure"><span id="fig:change2"></span>
<img src="images/PartII-Change2.png" alt="Subset of the 2015-2022 Change Map. Expansion of the future capital of Egypt, New Cairo City." width="1452" />
<p class="caption">
Figure 1.68: Subset of the 2015-2022 Change Map. Expansion of the future capital of Egypt, New Cairo City.
</p>
</div>
<p>You can calculate the area of expansion/conversion by isolating the pixels of gain/loss from the <code>change</code> object into <code>gain</code> and <code>loss</code>. Then, calculate the area of each pixel using <code>ee.Image.pixelArea()</code> and multiplying by the count of pixels in <code>gain</code> and <code>loss</code> using <code>multiply</code>. The default unit is square meters (m²). You can use <code>.divide()</code> to transform into square kilometers (<code>.divide(1000000)</code>) or hectares (<code>.divide(10000)</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var gainArea =<span class="st"> </span><span class="kw">gain.multiply</span>(<span class="kw">ee.Image.pixelArea</span>()<span class="kw">.divide</span>(<span class="dv">1000000</span>));
var lossArea =<span class="st"> </span><span class="kw">loss.multiply</span>(<span class="kw">ee.Image.pixelArea</span>()<span class="kw">.divide</span>(<span class="dv">1000000</span>));</code></pre></div>
<p>These objects will hold the area calculation for a single pixel. Then, we can use <code>.reduceRegion()</code> method, from the <code>ee.Image()</code> container. This will apply a reducer to all the pixels in a specific region. This method will take the <code>reducer</code> parameter, which will contain the type of mathematical operation you wish to compute for all these pixels. In this case, we will use <code>ee.Reducer.sum()</code>, to sum up all the single area values for all the pixels within <code>gainArea</code> and <code>lossArea</code>:</p>
<div class="starcomment">
<p>
Make sure to create a geometry around an area of interest in order to calculate the area (extent) for the pixels of a given class within that geometry! In this example, we used a geometry around New Cairo City called 'AOI'.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var statsgain =<span class="st"> </span><span class="kw">gainArea.reduceRegion</span>({
  reducer<span class="op">:</span><span class="st"> </span><span class="kw">ee.Reducer.sum</span>(), <span class="op">/</span><span class="er">/</span><span class="st"> </span>Sum of all the area values.
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>,                 <span class="op">/</span><span class="er">/</span><span class="st"> </span>Landsat scale.
  geometry<span class="op">:</span><span class="st"> </span>AOI,
  maxPixels<span class="op">:</span><span class="st"> </span><span class="fl">1e14</span>
});

var statsloss =<span class="st"> </span><span class="kw">lossArea.reduceRegion</span>({
  reducer<span class="op">:</span><span class="st"> </span><span class="kw">ee.Reducer.sum</span>(),
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>,
  geometry<span class="op">:</span><span class="st"> </span>AOI,
  maxPixels<span class="op">:</span><span class="st"> </span><span class="fl">1e14</span>
});</code></pre></div>
<p>Finally, you can print these values using the code below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">statsgain.get</span>(<span class="st">&#39;classification&#39;</span>), <span class="st">&#39;km² of new built up areas in New Cairo City&#39;</span>); </code></pre></div>
<div class="figure"><span id="fig:AreaCairo"></span>
<img src="images/PartII-AreaCairo.png" alt="Subset of the 2015-2022 Change Map. Expansion of the future capital of Egypt, New Cairo City. The `.reduceRegion()` method was used to calculate the extent of gains for the urban/built up class. Finally `print()` was used to print the result to the __Console__ tab. " width="1015" />
<p class="caption">
Figure 1.69: Subset of the 2015-2022 Change Map. Expansion of the future capital of Egypt, New Cairo City. The <code>.reduceRegion()</code> method was used to calculate the extent of gains for the urban/built up class. Finally <code>print()</code> was used to print the result to the <strong>Console</strong> tab.
</p>
</div>
</div>
</div>
<div id="post-classification-processing" class="section level2">
<h2><span class="header-section-number">1.4</span> Post-classification processing</h2>
<p>So far you have learned the basics of creating a classification output using a machine learning algorithm such as Random Forest. The objective of this section is to provide useful post-classification steps for corrections and general improvement of a random forest classification output.</p>
<div id="re-classification" class="section level3">
<h3><span class="header-section-number">1.4.1</span> Re-classification</h3>
<p>Classification outputs often times will need some degree of correction or adjustment. Some of these corrections and adjustments include, for example, the Correction for missclassification erros in specific areas and changing class labels (pixel values) or class order. In this section we will explore the function <code>remap()</code>. This function maps from input values to output values, represented by two parallel lists: one includes the original number of classes and their value; the other represents which class (or classes) is being remapped and what it is being remapped to. To ilustrate this concept, consider the following example:</p>
<ul>
<li>The previously produced land cover maps include four classes: Water (pixel value = 0), Cropland / Cultivated Areas (pixel value = 1), Sand and bare areas (pixel value = 2) and Built-up and Urban Areas (pixel value = 3) (List 1). If any of these class values needs to be changed, the new value for that class is placed in the <em>List 2</em>, in the position of the class that needs changing (Figure 1).</li>
</ul>
<div class="figure"><span id="fig:my-remap"></span>
<img src="images/remap.PNG" alt="The `remap` function for the land cover classification of the Greater Cairo. " width="881" />
<p class="caption">
Figure 1.70: The <code>remap</code> function for the land cover classification of the Greater Cairo.
</p>
</div>
<p>To test this function, start by <a href="https://code.earthengine.google.com/" target="_blank">opening a new code editor page</a> and importing one of the classification assets you used <a href="part-1-basics-fundamentals.html#example-1-land-cover-classification-of-greater-cairo-and-giza-area-egypt---year-2022">in the previous section</a>. In this example, we will importe the latest land cover map from the year 2022 as a variable called 'Cairo2022' and we will add it to the map editor using the same color scheme from <code>paletteMAP</code> used in the previous section:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var Cairo2022 =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&quot;users/capacityBuilding/Cairo2022&quot;</span>);
var paletteMAP =<span class="st"> </span>[
  <span class="st">&#39;#0040ff&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Water
  <span class="st">&#39;#00ab0c&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Croplands <span class="op">/</span><span class="st"> </span>Cultivated Areas
  <span class="st">&#39;#fbf2ad&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Sand and bare areas
  <span class="st">&#39;#878587&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Built<span class="op">-</span>up and Urban Areas
];

<span class="kw">Map.centerObject</span>(Cairo2022);
<span class="kw">Map.addLayer</span>(Cairo2022, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">3</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Cairo2022&#39;</span>);</code></pre></div>
<div class="starcomment">
<p>
Using <code>Map.centerObject()</code> will center the map view on a given object you click the <strong>Run</strong> button. It is always a good practice to set the center on your main object so you can always come back to it! In this example you can center the map view to your classification object <code>Cairo2022</code>.
</p>
</div>
<p>Now, to illustrate the <code>.remap()</code> method, let's consider the following scenarios:</p>
<p>*<strong>Scenario 1</strong></p>
<p>A new version of the <code>Cairo2022</code> map where <em><strong>Sand and bare areas (pixel value = 2)</strong></em> and <em><strong>Built-up and Urban Areas (pixel value = 3)</strong></em> switch orders in the final map. In this case, we can use the <code>.remap()</code> method to change the pixel value of <em>Built-up and Urban Areas</em> to <strong>2</strong> and <em>Sand and bare areas</em> to <strong>3</strong> in their respective position on list 2:</p>
<div class="figure"><span id="fig:my-remap2"></span>
<img src="images/remap2.PNG" alt="Sand (2) and Cities (3) changing orders in the image output using `.remap` " width="877" />
<p class="caption">
Figure 1.71: Sand (2) and Cities (3) changing orders in the image output using <code>.remap</code>
</p>
</div>
<p>As a guide, the figure above can be used to create a new variable <code>CairoV1</code> with the new order for the classes using <code>.remap()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var CairoV1 =<span class="st"> </span><span class="kw">Cairo2022.remap</span>([<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]);</code></pre></div>
<p>Add the <code>CairoV1</code> to the the map using the original color scheme <code>paletteMAP</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(CairoV1, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">3</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Cairo V1&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:my-CairoV1"></span>
<img src="images/CairoV1.png" alt="`Cairo2022` and `CairoV1` maps using the original `paletteMap`. Note that Sand and bare areas and Built-up and Urban areas switched colors as we switched their order.  " width="1202" />
<p class="caption">
Figure 1.72: <code>Cairo2022</code> and <code>CairoV1</code> maps using the original <code>paletteMap</code>. Note that Sand and bare areas and Built-up and Urban areas switched colors as we switched their order.
</p>
</div>
<p>*<strong>Scenario 2</strong></p>
<p>A new version of the <code>Cairo2022</code> map where <em><strong>Sand and bare areas (pixel value = 2)</strong></em> and <em><strong>Built-up and Urban Areas (pixel value = 3)</strong></em> are merged into a new class called <em><strong>Barren land and Articicial Surfaces (pixel value = 2)</strong></em>. Note that this new class can assume any value when merging, as long as both classes have the same value:</p>
<div class="figure"><span id="fig:my-remap3"></span>
<img src="images/remap3.PNG" alt="Sand and bare areas merging with Built-up and Urban area into a new class value (2). New classes can assume any value when merging, as long as these values are the same for both classes." width="874" />
<p class="caption">
Figure 1.73: Sand and bare areas merging with Built-up and Urban area into a new class value (2). New classes can assume any value when merging, as long as these values are the same for both classes.
</p>
</div>
<p>For this example, we will keep the value <em><strong>2</strong></em> for this new class in a new variable <code>CairoV2</code> for the new map:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var CairoV2 =<span class="st"> </span><span class="kw">Cairo2022.remap</span>([<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>]);</code></pre></div>
<p>We will add the <code>CairoV2</code> to the the map using the original color scheme <code>paletteMAP</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(CairoV2, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">3</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Cairo V2&#39;</span>);</code></pre></div>
<div class="rmdcomment">
<p>
Note that the <code>min</code> and <code>max</code> range of values changed from 0-3 (4 classes) to 0-2 (three classes) in <code>CairoV2</code>. You can still maintain the original <code>min</code> and <code>max</code> range of values in this particular case because <code>Map.addLayer()</code> would only map the color scheme to the first three values of<code>Cairov2</code> (0, 1 and 2). However, it is always good practice to set the <code>min</code> and <code>max</code> range of values to match the actual number of classes along with editing the color palette to have the same number of colors as the number of classes in your map.
</p>
</div>
<div class="figure"><span id="fig:my-CairoV2"></span>
<img src="images/CairoV2.png" alt="`Cairo2022` and `CairoV2` maps using the original `paletteMap`. Note that *Sand and bare areas* and *Built-up and Urban areas* have the same color as they were merged under the same pixel value (2)." width="1202" />
<p class="caption">
Figure 1.74: <code>Cairo2022</code> and <code>CairoV2</code> maps using the original <code>paletteMap</code>. Note that <em>Sand and bare areas</em> and <em>Built-up and Urban areas</em> have the same color as they were merged under the same pixel value (2).
</p>
</div>
<p>*<strong>Scenario 2</strong></p>
<p>A new version of the <code>Cairo2022</code> map where only a portion of it is remapped to a given class. This scenario is one of the most commonly used post-classification procedure where the goal is to remap specific areas to fix for classification errors. To ilustrate, we will consider the following example:</p>
<p><em>Upon close inspection, the <code>Cairo2022</code> map showed some cropland/cultivated areas within zones of dense urbanization of New Cairo City. A team on the ground went to the area and confirmed that is indeed dense urbanization and no agricultural land was found in that area. Therefore, that portion of the map needs to be rectified in order to reflect the actual land cover. In this case, the <code>.where()</code> method of an <code>ee.Image()</code> object is used. This function performs conditional replacement of values, following the formula <code>input.where(test,value)</code>. For each pixel in each band of <code>input</code>, if the corresponding pixel in <code>test</code> is nonzero, Google Earth Engine will output the corresponding pixel in <code>value</code>, otherwise it will output the <code>input</code> pixel. Translating this function to this example, <code>input</code> is the land cover map in which we aim to perform the reclassification - in this case <code>Cairo2020</code>; <code>test</code> is the area or region of the map <code>value</code> will take place, and; <code>value</code> is the correct classification that will be included in the final map:</em></p>
<div class="figure"><span id="fig:my-where"></span>
<img src="images/WhereFunction.PNG" alt=" The `.where` function applied to this example." width="899" />
<p class="caption">
Figure 1.75:  The <code>.where</code> function applied to this example.
</p>
</div>
<p>In your own version of <code>Cairo2022</code> map, create an new geometry over an area of your interest and name it <code>aoi</code>:</p>
<div class="figure"><span id="fig:my-regionwhere"></span>
<img src="images/RegionWhere.png" alt="A geometry over an area of `Cairo2020` highlighting cultivated areas next to urbanization." width="864" />
<p class="caption">
Figure 1.76: A geometry over an area of <code>Cairo2020</code> highlighting cultivated areas next to urbanization.
</p>
</div>
<p>The method <code>.where()</code> only uses <code>ee.Image()</code> objects as <code>test</code>. Therefore, using the geometry/feature <code>aoi</code> is not allowed. An easy and effective way to go around this rule is to create an image with <code>ee.Image()</code> and clip it for the region of interest:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var region =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>)<span class="kw">.clip</span>(aoi);</code></pre></div>
<p>The function above will create an image with value of 1 and will clip it for the area of interest <code>aoi</code>. Next, using the same approach from <em>Scenario 1</em> and <em>2</em>, we will create a new version of <code>Cairo2022</code> called ''subistitute', where the <em><strong>Cropland/Cultivated Areas</strong></em> class is remapped to <em><strong>Built-up and Urban Areas</strong></em>: the position 2 on list 2 (belonging to agricultural/cultivated areas) receives the value <em><strong>3</strong></em> from <em><strong>Built-up and Urban Areas</strong></em> on list 1:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var substitute =<span class="st"> </span><span class="kw">Cairo2020.remap</span>([<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">3</span>]);</code></pre></div>
<p>Now, using <code>.where()</code> we will create a new map <code>CairoV3</code> following the formula (<a href="part-1-basics-fundamentals.html#fig:my-where">1.75</a>) and add it to the map editor:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var CairoV3 =<span class="st"> </span><span class="kw">Cairo2022.where</span>(region,substitute);
<span class="kw">Map.addLayer</span>(CairoV3, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">3</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Cairo V3&#39;</span>);</code></pre></div>
<p>Compare the two classification objects: you will notice that every pixel of <em><strong>Cropland/Cultivated Areas</strong></em> (green, pixel value = 2) within the <code>aoi</code> in <code>Cairo2022</code> is now remapped to <em><strong>Built-up and Urban Areas</strong></em> (grey, pixel value = 3) in <code>CairoV3</code>:</p>
<div class="figure"><span id="fig:my-cairov3"></span>
<img src="images/CairoV3.png" alt="`CairoV3` showing the pixels of Cropland/Cultivated Areas remapped as Built-up and Urban Areas within `aoi`." width="850" />
<p class="caption">
Figure 1.77: <code>CairoV3</code> showing the pixels of Cropland/Cultivated Areas remapped as Built-up and Urban Areas within <code>aoi</code>.
</p>
</div>
</div>
<div id="map-spatial-smoothing" class="section level3">
<h3><span class="header-section-number">1.4.2</span> Map spatial smoothing</h3>
<p>Spatial smoothing is another post-classification procedure to enhance the quality of a land cover classification output. A common issue that arises from the pixel-based classification of fine/medium spatial resolution imagery is the “salt-and-pepper” effect. This happens when individual pixels are classified differently from their neighbors, creating speckles of isolated pixels of different classes. There are several ways to minimize this issue, such as:</p>
<ul>
<li><p>image pre-processing, such as low-pass filter and texture analysis;</p></li>
<li><p>contextual classification, and;</p></li>
<li><p>post-classification processing, such as median and mode filtering.</p></li>
</ul>
<p>In this section, we will focus on a post-classification technique to reduce the salt and pepper effect and edge roughness of land cover maps using focal median filtering (<code>ee.Image.focal_median()</code>).</p>
<p>We will apply the <code>.focal_median()</code> method to <code>Cairo2022</code>. This method is a simple sliding-window spatial filter that replaces the center value (or class) in the window with the median of all the pixel values in the window. The window, or kernel, is usually square but can be any shape. The <code>.focal_median()</code> method usually is expressed as:</p>
<div class="figure"><span id="fig:my-focal"></span>
<img src="images/focal.PNG" alt="`.focal_median` spatial filter." width="1015" />
<p class="caption">
Figure 1.78: <code>.focal_median</code> spatial filter.
</p>
</div>
<p>In the function above, the <code>radius</code> parameter specifies the number of pixels from the center that the kernel will cover. This radius value can be expressed as number of pixels or meters. The <code>kernelType</code> specifies the type of kernel to use.</p>
<div class="rmdcomment">
<p>
Either <code>.focal_median(1, 'square', 'pixels')</code> or <code>.focal_median(30, 'square', 'meters')</code> will produce a 3x3 pixel sliding-window, as you are specifing 1 pixel (or 30 meters which is equal to one Landsat pixel) in each direction from the center pixel. Similarly, a <code>radius</code> of 2 pixels or 60 meters will produce a 5x5 sliding-window: a center pixel plus 2 pixels in each direction.
</p>
</div>
<p>Following Figure <a href="part-1-basics-fundamentals.html#fig:my-focal">1.78</a> and the example above, we will apply the <code>.focal_median()</code> filtering with two <code>radius</code> sizes (30 and 60 meters) to <code>Cairo2022</code>, add <code>Cairo30</code> and <code>Cairo60</code> to the map editor and compare the results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var Cairo30 =<span class="st"> </span><span class="kw">Cairo2022.focal_median</span>(<span class="dv">30</span>,<span class="st">&#39;square&#39;</span>, <span class="st">&#39;meters&#39;</span>);
var Cairo60 =<span class="st"> </span><span class="kw">Cairo2022.focal_median</span>(<span class="dv">60</span>,<span class="st">&#39;square&#39;</span>, <span class="st">&#39;meters&#39;</span>);
<span class="kw">Map.addLayer</span>(Cairo30, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">3</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Cairo 3x3&#39;</span>);
<span class="kw">Map.addLayer</span>(Cairo60, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">3</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Cairo 5x5&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:my-smooth1"></span>
<img src="images/cairosmooth1b.png" alt="`Cairo2022` processed with `.focal_median` spatial filter two radius sizes." width="1208" />
<p class="caption">
Figure 1.79: <code>Cairo2022</code> processed with <code>.focal_median</code> spatial filter two radius sizes.
</p>
</div>
<div class="caution">
<p>
<strong>IMPORTANT:</strong> The <code>.focal_median(1, 'square', 'pixels')</code>* and <code>.focal_median(30, 'square', 'meters')</code> will only achieve the intended final result if you reproject it back to the original scale and projection from the original map. Note that this technique while effective in removing the &quot;salt-and-pepper&quot; effect from the original map, it creates edges that are not in the same resolution and projection as the original map. Therefore, creating fairly rounded boundaries for the classes. This is not ideal as it is usually intended for these maps to keep the same resolution as the original map, as well as to preserve the boundaries between classes. To account for this issue, you can reproject this output back the original scale so it is formed by 30 x 30 meter pixels. To do that, simply use <code>.reproject(projection.atScale(scale))</code> within the <code>.focal_median</code> filter. The <code>.reproject</code> function will take two arguments: projection and scale. You can extract this information from the original map with <code>.projection()</code> and <code>.nominalScale()</code>:
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var projection =<span class="st"> </span><span class="kw">Cairo2022.projection</span>();
var scale =<span class="st"> </span><span class="kw">projection.nominalScale</span>();</code></pre></div>
<p>Then, we re-aply the <code>.focal_median()</code> filter with <code>.reproject(projection.atScale(scale))</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var newCairo30 =<span class="st"> </span><span class="kw">Cairo2022.focal_median</span>(<span class="dv">1</span>,<span class="st">&#39;square&#39;</span>, <span class="st">&#39;pixels&#39;</span>)
                       <span class="kw">.reproject</span>(<span class="kw">projection.atScale</span>(scale));
                       
var newCairo60 =<span class="st"> </span><span class="kw">Cairo2022.focal_median</span>(<span class="dv">60</span>,<span class="st">&#39;square&#39;</span>, <span class="st">&#39;meters&#39;</span>)
                       <span class="kw">.reproject</span>(<span class="kw">prj.atScale</span>(scale));</code></pre></div>
<div class="figure"><span id="fig:my-smooth2"></span>
<img src="images/cairosmooth2.png" alt="`Cairo2022` processed with `.focal_median` spatial filter with 3x3 and 5x5 pixel windows. Note that the function was reprojected to match `Cairo2022`'s projection and scale. Now the discrete boundaries of classes are pixelated back to 30 meters." width="1234" />
<p class="caption">
Figure 1.80: <code>Cairo2022</code> processed with <code>.focal_median</code> spatial filter with 3x3 and 5x5 pixel windows. Note that the function was reprojected to match <code>Cairo2022</code>'s projection and scale. Now the discrete boundaries of classes are pixelated back to 30 meters.
</p>
</div>
<p>Note that even though the boundaries of the classes are smoother, they are formed by the 30 x 30 meter pixels. Usually, a <code>radius</code> of 1 (3x3 square window) removes most of the salt-and-pepper effect, smoothens the boundaries in between classes while preserving the overall shape of the classes.</p>
<p>Access the full scrip for this section <a href="https://code.earthengine.google.com/c1151eecd2e21f2ae43aa37cf1fd80d2" target="_blank">here.</a></p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="index.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="part-3-country-specific-applications.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/celiosousa/LCMTutorial/edit/master/01-PART_I.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": "https://github.com/celiosousa/LCMTutorial/blob/master/01-PART_I.Rmd",
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
