[["index.html", "Supervised Classification with Google Earth Engine Chapter 1 Introduction and overview", " Supervised Classification with Google Earth Engine Celio Sousa 2021-11-11 Chapter 1 Introduction and overview "],["auxiliary-functions.html", "Chapter 2 Auxiliary functions 2.1 Cloud and cloud shadow masking 2.2 Spectral indices 2.3 Compositing", " Chapter 2 Auxiliary functions Objective: To provide the initial functions and lines of code to assist the user to prepare, process and analyze Landsat 8/7 data for classification purposes. 2.1 Cloud and cloud shadow masking Section Snapshot at GEE This section demonstrates a way of masking clouds and cloud shadow pixels from Landsat 8/7 Surface Reflectance data based on file metadata. This function was created based on the documentation available for Landsat 8/7. Values for pixel bit and pixel band were found here. The cloud masking function is as follows: function maskL8sr(image) { // #Bits 3 and 5 are cloud shadow and cloud, respectively. var cloudShadowBitMask = ee.Number(2).pow(3).int(); var cloudsBitMask = ee.Number(2).pow(5).int(); // #Get the pixel QA band. var qa = image.select(&#39;pixel_qa&#39;); // #Both flags should be set to zero, indicating clear conditions. var mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0) .and(qa.bitwiseAnd(cloudsBitMask).eq(0)); // #Return the masked image, scaled to [0, 1]. return image.updateMask(mask).divide(10000).copyProperties(image, [&quot;system:time_start&quot;]); }; 2.2 Spectral indices This section demonstrates how to calculate and add spectral indices to each scene of a Landsat 8 image collection. The function below calculates and add spectral indices to an image collection taking into account the Landsat 8 spectral bands and their respective wavelengths: The function used to calculate several commonly used spectral indices follows this format: var addIndicesL8 = function(img) { //# NDVI (Normalized Difference Vegetation Index) var ndvi = img.normalizedDifference([&#39;B5&#39;,&#39;B4&#39;]).rename(&#39;NDVI&#39;); //# NDMI (Normalized Difference Mangrove Index - Shi et al 2016 ) var ndmi = img.normalizedDifference([&#39;B7&#39;,&#39;B3&#39;]).rename(&#39;NDMI&#39;); //# MNDWI (Modified Normalized Difference Water Index - Hanqiu Xu, 2006) var mndwi = img.normalizedDifference([&#39;B3&#39;,&#39;B6&#39;]).rename(&#39;MNDWI&#39;); //# SR (Simple Ratio) var sr = img.select(&#39;B5&#39;).divide(img.select(&#39;B4&#39;)).rename(&#39;SR&#39;); //# Band Ratio 6/5 var ratio65 = img.select(&#39;B6&#39;).divide(img.select(&#39;B5&#39;)).rename(&#39;R65&#39;); //# Band Ratio 4/6 var ratio46 = img.select(&#39;B4&#39;).divide(img.select(&#39;B6&#39;)).rename(&#39;R46&#39;); //# GCVI (Green Chlorophyll Vegetation Index) var gcvi = img.expression(&#39;(NIR/GREEN)-1&#39;,{ &#39;NIR&#39;:img.select(&#39;B5&#39;), &#39;GREEN&#39;:img.select(&#39;B3&#39;) }).rename(&#39;GCVI&#39;); return img .addBands(ndvi) //# The .addBands will add each spectral index to each Landsat scene .addBands(ndmi) .addBands(mndwi) .addBands(sr) .addBands(ratio65) .addBands(ratio46) .addBands(gcvi); }; Note that the function above shows several ways of doing band math operations. First, normalized difference indices can be calculated using img.normalizedDifference. For more intricate expressions, You can use the expression format as shown with the Green Chlorophyll Vegetation Index example. IMPORTANT: The function above is also applicable to Landsat 7 image collections. However, be mindful that these sensors have slightly different bands and wavelengths. Therefore, the name of the bands on the above function for each spectral index will not match Landsat 7s spectral bands. Make sure to select the appropriate Landsat 7 spectral band for each spectral index. Use Table 2 for reference. 2.3 Compositing Section Snapshot at GEE In the previous sections, we learn two useful functions: cloud masking and spectral indices calculation. In this section, we will learn about compositing and mosaicking Landsat scenes. In the next chapter, we will use all three functions covered in here to produce a cloud-free mosaic of Landsat 8 scenes and how to perform a random forest classification. You can composite any object containing an image collection using on a per-pixel, per- band basis using .median() or using quality bands such as NDVI with .qualityMosaic(NDVI). The .median() will composite all the images in the collection to a single image using the median values of each band, at the pixel level; .qualityMosaic(NDVI) will composite all the images in the collection and set each pixel in the composite based on which image in the collection has a maximum value for the specified band, in this case NDVI. Although there are different methods for compositing, the median composite method is the state of the art in Google Earth Engine and it has been widely used in classification and change analysis studies. For instance, it was used in a recent publication of September 2019 mapping cropland extent over southeast and northeast Asia using Landsat 8 and GEE. Median was also the compositing method chosen in this study to showcase GEEs array-based computational approach. The authors of this study mapping land cover change in Namibia also used median composities in their analysis. The same approach was used here to produce a land cover map for the entire Southeast Asia and here to map land cover and land cover change over continental Africa. Additionally, methods such as maximum NDVI would present issues, especially over cloudy areas. As you composite using maximum values of NDVI, water bodies will be completely covered by clouds in the resulting composite as clouds have slightly higher NDVI than water. A second cleaning or compositing procedure would be necessary to avoid this issue over water bodies, which in this case is not ideal. Figure 2.1: Median (left) and Maximum NDVI (Greenest Pixel) (right) composites of Landsat 8 images over Lake Piso in Liberia. Clouds have slightly higher NDVI than water. Therefore, cloudy pixels over water bodies often occur with this compositing method. "],["supervised-classification-of-landsat-8-oli-imagery.html", "Chapter 3 Supervised classification of Landsat 8 OLI imagery 3.1 Example 1: Land cover classification of Greater Cairo and Giza area, Egypt - Year 2020 3.2 Example 2: 2000 - 2020 Map-to-Map change of greater Cairo and Giza area, Egypt", " Chapter 3 Supervised classification of Landsat 8 OLI imagery Objectives: Use the cloud-masking function (See Chapter 2's Cloud and cloud shadow masking section) to mask clouds on Landsat 8 Imagery; To produce a cloud-free composite mosaic using the median reducer (Compositing), and; To classify the cloud-free composite mosaic of Landsat 8 scenes using Random Forest. 3.1 Example 1: Land cover classification of Greater Cairo and Giza area, Egypt - Year 2020 We will start by opening a new code editor page 3.1.1 Temporal and spatial parameters for compositing In this example, we are going to create a 2020 annual composite. For this, lets create three objects (var): year, startDay and endDay. var year = 2020; //# Year var startDay = (year)+&#39;-01-01&#39;; //# beginning of date filter | month-day var endDay = (year)+&#39;-12-30&#39;; //# end of date filter | month-day Additionally, we need to define an area of interest for the composite. Google Earth Engine allows you to import your own shapefiles of your area of interest (through the New button in the Assets tab) as well as to direcly create your geometry in the code editor. For this example, draw a rectangle around the metropolitan area of Cairo, Egypt (Figure 3.1): Figure 3.1: Geometry drawn over the Greater Cairo area Now, let's create an object var aoi that will contain the geometry AreaOfInterest: var aoi = AreaOfInterest; 3.1.2 Landsat 8 Pre-classification steps Auxiliary Functions In this step, we will used the functions from Chapter 2 to create a cloud-free mosaic of Landsat scenes over our area of interest. First, the function maskL8sr will be used to mask all clouds and cloud shadows from the Landsat scenes: var maskL8sr = function (image) { //# Bits 3 and 5 are cloud shadow and cloud, respectively. var cloudShadowBitMask = 1 &lt;&lt; 3; var cloudsBitMask = 1 &lt;&lt; 5; //# Get the pixel QA band. var qa = image.select(&#39;pixel_qa&#39;); //# Both flags should be set to zero, indicating clear conditions. var mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0) .and(qa.bitwiseAnd(cloudsBitMask).eq(0)); //# Return the masked image, scaled to reflectance, without the QA bands. return image.updateMask(mask).divide(10000) .select(&quot;B[0-9]*&quot;) .copyProperties(image, [&quot;system:time_start&quot;]); }; Second, for a Random Forest type classifier, predictor variables must be used. Usually, different spectral indices are good predictors for the Random Forest Model. The function addIndicesL8 below can be used to calculate several spectral indices and add them to each scene of the Landsat image collection: var addIndicesL8 = function(img) { //# NDVI (Normalized Difference Vegetation Index) var ndvi = img.normalizedDifference([&#39;B5&#39;,&#39;B4&#39;]).rename(&#39;NDVI&#39;); //# NDMI (Normalized Difference Mangrove Index - Shi et al 2016 ) var ndmi = img.normalizedDifference([&#39;B7&#39;,&#39;B3&#39;]).rename(&#39;NDMI&#39;); //# MNDWI (Modified Normalized Difference Water Index - Hanqiu Xu, 2006) var mndwi = img.normalizedDifference([&#39;B3&#39;,&#39;B6&#39;]).rename(&#39;MNDWI&#39;); //# SR (Simple Ratio) var sr = img.select(&#39;B5&#39;).divide(img.select(&#39;B4&#39;)).rename(&#39;SR&#39;); //# Band Ratio 6/5 var ratio65 = img.select(&#39;B6&#39;).divide(img.select(&#39;B5&#39;)).rename(&#39;R65&#39;); //# Band Ratio 4/6 var ratio46 = img.select(&#39;B4&#39;).divide(img.select(&#39;B6&#39;)).rename(&#39;R46&#39;); //# GCVI (Green Chlorophyll Vegetation Index) var gcvi = img.expression(&#39;(NIR/GREEN)-1&#39;,{ &#39;NIR&#39;:img.select(&#39;B5&#39;), &#39;GREEN&#39;:img.select(&#39;B3&#39;) }).rename(&#39;GCVI&#39;); return img .addBands(ndvi) // This will add each spectral index to each Landsat scene .addBands(ndmi) .addBands(mndwi) .addBands(sr) .addBands(ratio65) .addBands(ratio46) .addBands(gcvi); }; Landsat 8 image collection and cloud free-mosaic In this section we will load the Landsat 8 Surface Reflectance data archive into an object var collection by using the container ee.ImageCollection and the collection ID 'LANDSAT/LC08/C01/T1_SR'. Secondly, we will filter this image collection so it only contains the Landsat scenes acquired within the period we selected previously (see Section Temporal and spatial parameters for compositing) by using the container filterDate. Finally, we will map the cloud-masking and spectral indices functions (Landsat 8 Pre-classification steps) to the collection: var collection = ee.ImageCollection(&#39;LANDSAT/LC08/C01/T1_SR&#39;) //# Load the Landsat 8 SR Collection .filterDate(startDay, endDay) //# Filter the scenes based on the time period selected .map(maskL8sr) //# Masks for clouds and cloud-shadows using the function we created .map(addIndicesL8); //# Add the indices using the function we created The object collection will now contain all the Landsat 8 scenes from January to December for the year 2020. Each scene in this collection is masked for clouds and cloud shadows and will have additional bands for each spectral index included in the addIndicesL8 function. Next, we will reduce this image collection into a composite. This can be done by a single median composite on a per-pixel, per- band basis using .median() or using quality bands such as NDVI with .qualityMosaic(NDVI) (See Compositing for more information). In an object called var composite, lets reduce the collection using the container .median() and clip the composite to our area of interest aoi using the container .clip: var composite = collection .median() //# Uses the median reducer .clip(aoi); //# Clips the composite to our area of interest Now, the object composite will contain a single multi-band image that is clipped to our area of interest aoi. We can add this composite layer to the map by using Map.addLayer. The arguments for Map.addLayer container are (but not limited to): The object you want to display; The visualization parameters, and; A name for the layer of your choosing. In this example, we are displaying a Landsat composite. Thus, lets add to the map a real color image called 'Composite' by selecting the bands 'B4', 'B3', 'B2' to display in the RGB channels and the setting the minimum and maximum values to 0 and 0.3: //# Display the results. Map.centerObject(aoi,9); //# Set the map center to match the location of aoi Map.addLayer(composite, {bands: [&#39;B4&#39;, &#39;B3&#39;, &#39;B2&#39;], min: 0, max: 0.3}, &#39;Composite&#39;); Click Run (or use Ctrl+Enter). You should see something like this: Figure 3.2: Landsat median composite for the area of interested displayed with a real color composition (RGB 432) You can customize the composite visualization parameters by clicking on the settings icon (gear ) next to the layer name (in this example: Composite. You can also toggle in between map and Google Earth imagery by using the buttons Map and Satellite as seen in Figure 3.3. Figure 3.3: Layer settings. 3.1.3 Supervised Classification with Random Forest Training sample selection For this example, lets classify the 'composite' into four classes: water, agricultural land, sand and bare areas and urbanization. The first step is to create the training samples set to use into the Random Forest Model. Step 1 - In the Geometry Imports, click +new layer and make four sets of geometries, each set will represent samples from the classes 'water', 'cropland', 'sand' and 'urban'. Figure 3.4: Geometry sets to hold samples for each of the four classes. Step 2 - For each geometry in the list, clicking on the settings icon (gear ): name them accordingly using the 'Name' box, choose a color for it using the color picker and import each geometry as FeatureCollection. Add a property called landcover by clicking on the + Property and set a consecutive integer starting from 0 or 1 for each of the classes. You should achieve something similar to this: Figure 3.5: Geometries used to create the training sample sets. Your Geometry Imports should look like this: Figure 3.6: Geometry Imports after creating geometry sets to hold training samples Start selecting samples by clicking on the Water geometry in the Geometry Imports. Choose the point drawing tool and place some points along the River Nile: Instead of single points (i.e pixels), we can also use polygons containing a variable number of relatively homogenous pixels of a given land cover class. Switch to the polygon drawing tool and draw a few polygons over the River Nile: Figure 3.7: Sample points and polygons for the Water class Once you finish selecting samples, click the Exit button on the polygon editor dialogue box . Repeat the process for each of the other class. Make sure you select samples that are representative of each land cover class by selecting points and polygons of homogenous pixels (Figure 3.8). Figure 3.8: Example of sample points and polygons for Water (blue), Cropland (yellow), Urban (red) and Sand (pink). Each pixel within the polygons will be used as training inputs for the RF classifier. After selecting the samples, we will merge all the geometries together into an object var classes using the .merge container: var classes = Water.merge(Cropland) .merge(Sand) .merge(Urban); Sample sets In this section, we will create the training (and testing) sample sets to be used in the classification with Random Forest. First, we will select the predictors to assign to each sample point in the sample sets. For this example, lets create an object var bands with three spectral bands ('B5','B6','B7') and four spectral indices ('NDVI','MNDWI','SR','GCVI'). var bands = [&#39;B5&#39;,&#39;B6&#39;,&#39;B7&#39;,&#39;NDVI&#39;,&#39;MNDWI&#39;,&#39;SR&#39;,&#39;GCVI&#39;]; Next, we will sample the Landsat pixels by overlaying the geometries with the composite using the code below: var samples = composite.select(bands).sampleRegions({ collection: classes, #// Set of geometries ~classes~ created in the previous properties: [&#39;landcover&#39;], #// Label from each geometry from the feature property scale: 30 #// Make each sample the same size as Landsat pixel }).randomColumn(&#39;random&#39;); #// creates a column with random numbers for the next step In the sample object we have just created, each sample will include a column with the values from the object bands inherited from the composite and a column with their respective class label. Optionally, you can perform an accuracy assessment of the classifier by taking advantage of the identifiers assigned to the samples by the .randomColumn('random') within samples. For this example, we will randomly partition the sample set into training (80% of the samples) and testing (20% of the samples) samples using the code below: var split = 0.8; #// Roughly 80% for training, 20% for testing. var training = samples.filter(ee.Filter.lt(&#39;random&#39;, split)); var testing = samples.filter(ee.Filter.gte(&#39;random&#39;, split)); For your information, you can inspect the size (Figure 3.9) of the samples, training and testing objects using the code below: print(&#39;Samples n =&#39;, samples.aggregate_count(&#39;.all&#39;)); print(&#39;Training n =&#39;, training.aggregate_count(&#39;.all&#39;)); print(&#39;Testing n =&#39;, testing.aggregate_count(&#39;.all&#39;)); Figure 3.9: Sample sets size for this example. Note that the number will vary based on the number of geometries (polygons and points) and the sample split value Classification Next, we will train a Random Forest classifier using the training sample set training. The Random Forest classifier ee.Classifier.smileRandomForest has several user-defined parameters. However, two of them are the most usually defined: the number of trees in the ensemble (a.k.a forest) and the number of predictors to randomly tested at each tree. Note:Higher number of trees and number of predictors tested at each node do not mean better performance and overall accuracy. For this example, lets use 100 trees and 5 randomly selected predictors to use in each tree in a Random Forest model called classifier: var classifier = ee.Classifier.smileRandomForest(100,5).train({ features: training.select([&#39;B5&#39;,&#39;B6&#39;,&#39;B7&#39;,&#39;NDVI&#39;,&#39;MNDWI&#39;,&#39;SR&#39;,&#39;GCVI&#39;, &#39;landcover&#39;]), #// training classProperty: &#39;landcover&#39;, inputProperties: bands }); In the features argument of the code above, make sure to select the predictors you want to use from the sample set (in this example, training) to train the model. Most importantly, you must include the class property (classProperty) in which the class label is stored (in this example 'landcover'). You can assess the accuracy of the Random Forest model using the testing samples and print the results to the console using the code below: var validation = testing.classify(classifier); var testAccuracy = validation.errorMatrix(&#39;landcover&#39;, &#39;classification&#39;); print(&#39;Validation error matrix RF: &#39;, testAccuracy); print(&#39;Validation overall accuracy RF: &#39;, testAccuracy.accuracy()); Now, you can classify the composite using the Random Forest model classifier: var classifiedrf = composite.select(bands) #// select the predictors .classify(classifier); #// apply the Random Forest For visualization of the resulting classification output, lets first create a color palette object paletteMAP with colors for each class of the map and a legend object legend. The order of the colors in the palette will follow the order of the classes: var paletteMAP = [ &#39;#0040ff&#39;, #// Water (Class value 0) &#39;#00ab0c&#39;, #// Croplands / Cultivated Areas (Class value 1) &#39;#fbf2ad&#39;, #// Sand and bare areas (Class value 2) &#39;#878587&#39;, #// Built-up and Urban Areas (Class value 3) ]; var legend = ui.Panel({ style: { position: &#39;bottom-left&#39;, #// Position in the map padding: &#39;8px 15px&#39; #// Padding (border) size } }); var makeRow = function(color, name) { #// Create the label that is actually the colored boxes that represent each class var colorBox = ui.Label({ style: { backgroundColor: &#39;#&#39; + color, #// Use padding to give the label color box height and width. padding: &#39;8px&#39;, margin: &#39;0 0 4px 0&#39; } }); #// Create the label filled with the description text. var description = ui.Label({ value: name, style: {margin: &#39;0 0 4px 6px&#39;} }); return ui.Panel({ widgets: [colorBox, description], layout: ui.Panel.Layout.Flow(&#39;horizontal&#39;) }); }; legend.add(makeRow(&#39;0040ff&#39;, &#39;Water&#39;)); legend.add(makeRow(&#39;00ab0c&#39;, &#39;Croplands / Cultivated areas&#39;)); legend.add(makeRow(&#39;fbf2ad&#39;, &#39;Sand and bare areas&#39;)); legend.add(makeRow(&#39;878587&#39;, &#39;Artificial Surfaces&#39;)); Now, add the classification classifiedrf to the map using Map.addLayer: set the min: 0 (first class), max: 3 (last class), add the color palette paletteMAP and a name for the layer 'name'. Finally, add the legend to the map using Map.add: Map.addLayer (classifiedrf, {min: 0, max: 3, palette:paletteMAP}, &#39;Classification&#39;); Map.add (legend); Click Run (or ctrl+Enter). After several seconds, you should see something similar to the figure below: Figure 3.10: Random Forest classification output for 2020 Finally, export your classification output as a Google Earth Engine asset using the Export.image.toAsset function: Export.image.toAsset({ image: classifiedrf, #// Classification you want to export description: &#39;ClassificationOutput&#39;, #// Name showing on the task list (no space allowed) assetId: &#39;Cairo2020&#39;, #// Asset name (No spaces allowed) scale: 30, #// Scale (30m Landsat) region: AreaOfInterest, #// Region that you want to export - requires a geometry maxPixels:1e12 #// Default: if the export exceeds 1e8 = error! }); Running the code above will create the exporting task named ClassificationOutput in the task manager tab. Click Run at this task to start exporting your classification. 3.2 Example 2: 2000 - 2020 Map-to-Map change of greater Cairo and Giza area, Egypt Access the full scrip for this example here. In this example, we will use the codes from Example 1 to create a land cover classification for the year 2000 period. In this case, we have to use the Landsat 7 ETM+ image collection instead, as Landsat 8 OLI is only available after April 2013. Following are the changes to be made on the codes from Example 1: The year object will have a value of 2000; The addIndicesL8 function will have different names for the spectral bands. See Section 2 from Chapter 2; The collection object will have the Landsat 7 'LANDSAT/LE07/C01/T1_SR' image collection; Repeat the training sample selection (See Sample sets from previous example) to make sure the samples reflect the correct land cover class for the L7 composite in the year 2000. You can access the edited script for four steps above here. After following the 4 steps above, you should achieve a similar output as before: Figure 3.11: Random Forest classification output for 2000 Export this new classification to you assets. Next, open a new code editor page and add the classification exports to this script by clicking the Import into script button (blue arrow) for both classification assets in the Assets tab as shown in the figure 3.12: Figure 3.12: Assets tab with classification maps. Rename each import by clicking on their names at the Imports header: Figure 3.13: Imports header. Alternatively, you can import assets to your scripts by using ee.Image and their respective asset directory: var Cairo2000 = ee.Image(&quot;users/celiohelder/TutorialAssets/Cairo2000&quot;); var Cairo2020 = ee.Image(&quot;users/celiohelder/TutorialAssets/Cairo2020&quot;); Add Cairo2000 and Cairo2020 to the map using the code below: var paletteMAP = [ &#39;#0040ff&#39;, #// Water - pixel value = 0 &#39;#00ab0c&#39;, #// Croplands / Cultivated Areas - pixel value = 1 &#39;#fbf2ad&#39;, #// Sand and bare areas - pixel value = 2 &#39;#878587&#39;, #// Built-up and Urban Areas - pixel value = 3 ]; Map.addLayer(Cairo2000, {min: 0, max: 3, palette:paletteMAP}, &#39;Cairo2000&#39;); Map.addLayer(Cairo2018, {min: 0, max: 3, palette:paletteMAP}, &#39;Cairo2018&#39;); You can examine both layers on the map and try to identify areas where classes have changed in the 21 years period. However, we can use a transition error matrix to quickly quantify these changes. This matrix can be used to assess how much each class has changed and to what they have changed based on sampling design of your choosing. To do that, start by stacking both maps Cairo2000 and Cairo2020 into a single object stackedClassifications and rename Cairo2000 and Cairo2020 as 'before' and 'later', respectively: var stackedClassifications = Cairo2018.rename(&#39;later&#39;).addBands(Cairo2000.rename(&#39;before&#39;)); Next, create a testing sample set with 500 points for each class using a stratified random sampling design. In this sampling design each class has the same weight. Therefore, the same number of points will be placed in each class, regardless of its relative extent. This is important to consider as some classes may have very small area extent to be captured by a random sampling design. In this example, water bodies is relatively small compared to the other three land cover class. Thus, a stratified sampling design will ensure that this class will have the same number of points. Once the points are placed, they will inherit the class label (pixel value) from Cairo2000 ('before'): var sample = stackedClassifications.stratifiedSample({ numPoints: 500, #// Number of points you want to select by each class classBand: &quot;before&quot;, #// Map you want the points to inherit the class labels from scale: 30, #// Alsways remember to set the scale to match Landsat nomimal spatial resolution geometries: true }); Then add the samples to the map. You should see something similar to figure 3.14: Map.addLayer(sample, {}, &#39;Stratified samples&#39;); Figure 3.14: 2000 stratified random samples - 500 points by class. Next, create a transition matrix using the samples above. This matrix will show how many of these 500 remained the same land cover class 20 years later (Cairo2018) and how many of them changed to a given class. You can use .accuracy() to calculate the % of these samples remained unchanged between the two periods: var transitionMatrix = sample.errorMatrix({ actual: &#39;before&#39;, #// Cairo 2000 - rows predicted: &#39;later&#39; #// Cairo 2020  columns }); print(&#39;Transition Matrix&#39;, transitionMatrix); print(&#39;% of Unchanged Samples: &#39;, transitionMatrix.accuracy()); The matrix will be printed to the Console tab. The code above should produce something similar to Figure 3.15: Figure 3.15: Transition matrix based on the 2000 samples In the transition matrix above you can draw information about how many samples transitioned to each class from 2000 to 2020. For example, from the 500 samples of agriculture class (pixel value 1), 1 was classified (or transitioned) to water, 70 to sand and 106 to urban areas in 2020. Overall, 78% of these samples remained unchanged. Cropland area expansion and conversion in the Nile Delta from 2000-2020 Another quick analysis that can be done with land cover class maps in two points in time is highlighting areas in which a particular class has changed. In this example, we will assess the cultivated/cropland change between the 2000 and 2020. First, isolate the agricultural land class (pixel value 1) from both years into separate objects crop2000 and crop2020. Secondly, we calculate the change by simply subtracting both objects: var crop2000 = Cairo2000.select([&#39;classification&#39;]).eq(1); var crop2020 = Cairo2020.select([&#39;classification&#39;]).eq(1); #// Calculate the change by subtracting the two objects var change = crop2020.subtract(crop2000); By default, the new objects crop2000 and crop2020 will have values of 1 where the 'classification' has the label equals (.eq) to 1 (agriculture) in the land cover map. This will be the case regardless of the label value. Thus, the object change will have values of -1, 0 and 1, that represents loss/conversion, no change and gains, respectively: -1 = No crops in 2020 - crops in 2000 (0 - 1 = -1); 0 = crops in 2020 - crops in 2000 (1 - 1 = 0); 1 = crops in 2020 - no crops in 2000 (1 - 0 = 1) Add change to the map. Optionally, add a legend to the map using the code from Example 1 var paletteCHANGE = [ &#39;red&#39;, // Loss/conversion &#39;white&#39;, // No Change &#39;green&#39;, // Gain/Expansion ]; Map.addLayer(change, {palette: paletteCHANGE}, &#39;Change 2000-2018&#39;) The resulting change map will look similar to Figure 3.16: Figure 3.16: 2000-2020 Change Map. Conversion/loss west of the Nile Delta are likely due to harvest while the circle shaped areas in the center of the delta are related to expansion of cities and villages. You can calculate the area of expansion/conversion by isolating the pixels of gain/loss from the change into gain and loss. Then, calculate the area of each pixel using ee.Image.pixelArea and multiplying by the count of pixels in gain and loss using multiply. The default unit is square meters (mÂ²). You can use .divide() to transform into square kilometers (.divide(1000000)) or hectares (.divide(10000)) var gain = change.eq(1); // Isolate the gain pixels from the change var loss = change.eq(-1); // Isolate the loss pixels from the change // Calculate the area of each pixel var gainArea = gain.multiply(ee.Image.pixelArea().divide(1000000)); var lossArea = loss.multiply(ee.Image.pixelArea().divide(1000000)); Figure 3.17: Cultivated area gains and losses in the 2000-2020 period. "],["post-classification-processing.html", "Chapter 4 Post-classification processing 4.1 Re-classification 4.2 Map spatial smoothing", " Chapter 4 Post-classification processing Objective: To provide useful post-classification steps for corrections and general improvement of a random forest classification output. 4.1 Re-classification Classification outputs often times will need some degree of correction or adjustment. Some of these corrections and adjustments include, for example, the Correction for missclassification erros in specific areas and changing class labels (pixel values) or class order. In this section we will explore the function remap. This function maps from input values to output values, represented by two parallel lists: one includes the original number classes and their value; the other represents which class (or classes) is being remapped and to what it is being remapped to. To ilustrate this concept, consider the following example: The previously produced land cover map of Greater Cairo includes four classes: Water (pixel value = 0), Cropland / Cultivated Areas (pixel value = 1), Sand and bare areas (pixel value = 2) and Built-up and Urban Areas (pixel value = 3) (List 1). If any of these class values needs to be changed, the new value for that class is placed in the List 2, in the position of the class that needs changing (Figure 1). Figure 4.1: The remap function for the land cover classification of the Greater Cairo. To test this function, start by opening a new code editor page and importing one of the classification assets you used in the previous chapter. In this example, we will importe the latest land cover map from the year 2020 as a variable called Cairo2020 and we will add it to the map editor using the same color scheme from paletteMAP used in the previous chapter: var Cairo2020 = ee.Image(&quot;users/celiohelder/TutorialAssets/Cairo2020&quot;); var paletteMAP = [ &#39;#0040ff&#39;, #// Water &#39;#00ab0c&#39;, #// Croplands / Cultivated Areas &#39;#fbf2ad&#39;, #// Sand and bare areas &#39;#878587&#39;, #// Built-up and Urban Areas ]; Map.addLayer(Cairo2020, {min: 0, max: 3, palette:paletteMAP}, &#39;Cairo2000&#39;); Now, let's consider the following scenarios: Access the full scrip for the three scenarios here. 4.1.1 Scenario 1 A new version of the Cairo2020 map where Sand and bare areas (pixel value = 2) and Built-up and Urban Areas (pixel value = 3) switch orders in the final map. In this case, we can use the remap function to change the pixel value of Built-up and Urban Areas to 2 and Sand and bare areas to 3 in their respective position on list 2 (Figure 2): Figure 4.2: Sand (2) and Cities (3) changing orders in the image output using .remap As a guide, the figure above can be used to create a new variable CairoV1 with the new order for the classes using remap: var CairoV1 = Cairo2020.remap([0,1,2,3],[0,1,3,2]); Add the CairoV1 to the the map using the original color scheme paletteMAP: Map.addLayer(CairoV1, {min: 0, max: 3, palette:paletteMAP}, &#39;Cairo V1&#39;); Figure 4.3: Cairo2020 and CairoV1 maps using the original paletteMap. Note that Sand and bare areas and Built-up and Urban areas switched colors as we switched their order. 4.1.2 Scenario 2 A new version of the Cairo2020 map where Sand and bare areas (pixel value = 2) and Built-up and Urban Areas (pixel value = 3) are merged into a new class called Barren land and Articicial Surfaces (pixel value = 2). Note that this new class can assume any value when merging, as long as both classes have the same value: Figure 4.4: Sand and bare areas merging with Built-up and Urban area into a new class value (2). New classes can assume any value when merging, as long as these values are the same for both classes. For this example, keep the value 2 for this new class following Figure 4 and create a new variable CairoV2 for the new map: var CairoV2 = Cairo2020.remap([0,1,2,3],[0,1,2,2]); Similarly, Add the CairoV2 to the the map using the original color scheme paletteMAP. Map.addLayer(CairoV2, {min: 0, max: 2, palette:paletteMAP}, &#39;Cairo V1&#39;); Note that the min and max range of values changed from 0-3 (4 classes) to 0-2 (three classes). Even if the original range was mainted, Map.addLayer would only map the color scheme to the first three values ofCairov2 (0, 1 and 2). However, it is always good practice to set the min and max range of values to match the actual number of classes. Alternatively, you can also edit the color palette to have the same number of colors as the number of classes in your map: Figure 4.5: Cairo2020 and CairoV2 maps using the original paletteMap. Note that Sand and bare areas and Built-up and Urban areas have the same color as they were merged under the same pixel value (2). 4.1.3 Scenario 3 A new version of the Cairo2020 map where only a portion of it is remapped to a given class. This scenario is one of the most commonly used post-classification procedure where the goal is to remap specific areas to fix for classification errors. To ilustrate, consider the following example: Upon close inspection, the Cairo2020 map showed some cropland/cultivated areas within zones of dense urbanization. A team on the ground went to the area and confirmed that is indeed dense urbanization and no agricultural land was found in that area. Therefore, that portion of the map needs to be rectified in order to reflect the actual land cover. In this case, the .where function is used. This function performs conditional replacement of values, following the formula input.where(test,value). For each pixel in each band of input, if the corresponding pixel in test is nonzero, Google Earth Engine will output the corresponding pixel in value, otherwise it will output the input pixel. Translating this function to this example, input is the land cover map in which we aim to perform the reclassification - in this case Cairo2020; test is the area or region of the map value will take place, and; value is the correct classification that will be included in the final map (Figure 6): Figure 4.6: The .where function applied to this example. In your own version of Cairo2020 map, create an new geometry over an area of your interest and name it aoi: Figure 4.7: A geometry over an area of Cairo2020 highlighting cultivated areas next to urbanization. The function .where only uses images as test. Therefore, using the geometry/feature aoi is not allowed. An easy and effective way to go around this rule is to create an image with ee.Image() and clip it for the region of interest: var region = ee.Image(1).clip(aoi); The function above will create an image of 30 m pixels with value of 1 and will clip it for the area of interest aoi. Next, using the same approach from Scenario 1 and 2, create a new version of Cairo2020 called subistitute, where the Cropland/Cultivated Areas class is remapped to Built-up and Urban Areas: the position 2 on list 2 (belonging to agricultural/cultivated areas) receives the value 3 from Built-up and Urban Areas on list 1: var substitute = Cairo2020.remap([0,1,2,3],[0,3,2,3]); Now, using .where create a new map CairoV3 following the formula seen on Figure 6 and add it to the map editor: var CairoV3 = Cairo2020.where(region,substitute); Map.addLayer(CairoV3, {min: 0, max: 3, palette:paletteMAP}, &#39;Cairo V3&#39;); Figure 4.8: CairoV3 showing the pixels of Cropland/Cultivated Areas remapped as Built-up and Urban Areas within aoi. Notice that every pixel of Cropland/Cultivated Areas (green, pixel value = 2) within the aoi in Cairo2020 is now remapped to Built-up and Urban Areas (grey, pixel value = 3) in CairoV3. 4.2 Map spatial smoothing Spatial smoothing is another post-classification procedure to enhance the quality of a land cover classification output. A common issue that arises from the pixel-based classification of fine/medium spatial resolution imagery is the salt-and-pepper effect. This happens when individual pixels are classified differently from their neighbors, creating speckles of isolated pixels of different classes. There are several ways to minimize this issue, such as: image pre-processing, such as low-pass filter and texture analysis; contextual classification, and; post-classification processing, such as median and mode filtering. In this section, we will focus on a post-classification technique to reduce the salt and pepper effect and edge roughness of land cover maps using focal median filtering (ee.Image.focal_median). First, open a new code editor page and add one the classification exports to this script by clicking the Import into script button (blue arrow) for the classification asset of your choosing. For this example, we will use Cairo2020. // Color palette for the original map var paletteMAP = [ &#39;#0040ff&#39;, // Water &#39;#00ab0c&#39;, // Croplands / Cultivated Areas &#39;#fbf2ad&#39;, // Sand and bare areas &#39;#878587&#39;, // Built-up and Urban Areas ]; Map.setCenter(31.42217, 29.99157,10); // Set the center over Cairo Map.addLayer(Cairo2020, {min: 0, max: 3, palette:paletteMAP}, &#39;Cairo2000&#39;); Next, we will apply the .focal_median function to Cairo2020. This function is a simple sliding-window spatial filter that replaces the center value (or class) in the window with the median of all the pixel values in the window. The window, or kernel, is usually square but can be any shape. The focal_median function usually is expressed as: Figure 4.9: .focal_median spatial filter. In the function above, the radius parameter specifies the number of pixels from the center that the kernel will cover. This radius value can be expressed as number of pixels or meters. The kernelType specifies the type of kernel to use. For instance, consider the example below: Either .focal_median(1, 'square', 'pixels') or .focal_median(30, 'square', 'meters') will produce a 3x3 pixel sliding-window, as you are specifing 1 pixel (or 30 meters which is equal to one Landsat pixel) in each direction from the center pixel. Similarly, a radius of 2 pixels or 60 meters will produce a 5x5 sliding-window: a center pixel plus 2 pixels in each direction. Following Figure 9 and the example above, apply the .focal_median filtering with two radius sizes (30 and 60 meters) to Cairo2020, add Cairo30 and Cairo60 to the map editor and compare the results: var Cairo30 = Cairo2020.focal_median(1,&#39;square&#39;, &#39;pixels&#39;); var Cairo60 = Cairo2020.focal_median(30,&#39;square&#39;, &#39;meters&#39;); #// Add the new maps to the map editor Map.addLayer(Cairo30, {min: 0, max: 3, palette:paletteMAP}, &#39;Cairo 3x3&#39;); Map.addLayer(Cairo60, {min: 0, max: 3, palette:paletteMAP}, &#39;Cairo 5x5&#39;); Figure 4.10: Cairo2020 processed with .focal_median spatial filter with 3x3 and 5x5 pixels square kernels. IMPORTANT: The .focal_median(1, 'square', 'pixels') and .focal_median(30, 'square', 'meters') will only achieve the intended final result if you reproject it back to the original scale and projection from the original map. Note that this technique while effective in removing the &quot;salt-and-pepper&quot; effect from the original map, it creates edges that are not in the same resolution and projection as the original map. Therefore, creating fairly rounded boundaries for the classes. This is not ideal as it is usually intended for these maps to keep the same resolution as the original map, as well as to preserve the boundaries between classes. To account for this issue, you can reproject this output back the original scale so it is formed by 30 x 30 meter pixels. To do that, simply use .reproject(projection.atScale(scale)) within the .focal_median filter. The .reproject function will take two arguments: projection and scale. You can extract this information from the original map with .projection() and .nominalScale(): var prj = Cairo2020.projection(); var scale = prj.nominalScale(); Then, re-aply the .focal_median filter with .reproject(projection.atScale(scale)): var Cairo30 = Cairo2020.focal_median(1,&#39;square&#39;, &#39;pixels&#39;) .reproject(prj.atScale(scale)); var Cairo60 = Cairo2020.focal_median(30,&#39;square&#39;, &#39;meters&#39;) .reproject(prj.atScale(scale)); Figure 4.11: Cairo2020 processed with .focal_median spatial filter with 3x3 and 5x5 pixels square kernels. Note that the function was reprojected to match Cairo2020's projection and scale Note that even though the boundaries of the classes are smoother, they are formed by the 30 x 30 meter pixels. Usually, a radius of 1 (3x3 square window) removes most of the salt-and-pepper effect, smoothens the boundaries in between classes while preserving the overall shape of the classes. Access the full scrip for this section here. "],["country-specific-analyses.html", "Chapter 5 Country-specific analyses 5.1 Mangrove mapping in Guinea - West Africa", " Chapter 5 Country-specific analyses In this chapter we will explore examples of class-specific classification using previously used functions as well as useful land cover classification-based analysis. Objectives: To classify a cloud-free composite mosaic of Landsat 8 scenes for single class mapping in countries of interest in West Africa; To introduce the use of other datasets in the classification workflow. 5.1 Mangrove mapping in Guinea - West Africa In this example, we will use the codes from the previous chapters and adapt portions of them for mangrove mapping in Guinea, in West Africa. We will also introduce the use of other datasets for masking and sample selection to assist in the classification workflow. Start by opening a new code editor page and by defining the spatial and temporal parameters of the composite you wish to classify, just like the other examples. For the temporal parameters, lets use an annual 2020 composite: var year = 2020; #// Year var startDay = (year)+&#39;-01-01&#39;; #// beginning of date filter | month-day var endDay = (year)+&#39;-12-30&#39;; #// end of date filter | month-day For the spatial parameters, you can use the Large Scale International Boundary (LSIB) dataset and select Guineas national border. First, load the dataset into an object countries using the ee.FeatureCollection container and the feature collection ID 'USDOS/LSIB/2013'. Secondly, filter the dataset using .filterMetadata and select Guinea from the list of countries and storing it in aoi: var countries = ee.FeatureCollection(&#39;USDOS/LSIB/2013&#39;); var nationalborder = countries.filterMetadata(&#39;name&#39; , &#39;equals&#39;, &#39;GUINEA&#39;); Note that you can select a any country border by filtering 'USDOS/LSIB/2013' dataset by using .filterMetadata('name' , 'equals', 'NAME OF THE COUNTRY IN CAPITAL LETTERS'). Alternatively, you can use any previously uploaded Guinea's boundary datasets available here. Select a dataset from the list, copy its Asset ID and load it with ee.FeatureCollection into aoi. Figure 5.1: Examples of Guinea's administrative borders. In this example, we aim to map of Guinea's mangroves. Therefore, we chose prefecures5k as it emcompasses the entirety of Guinea's coast: var aoi = ee.FeatureCollection(&#39;users/celiohelder/Guinea/Borders/CoastalPrefectures5k&#39;); Important: All these datasets were made available through our collaboration with the Guinea and the World Bank and they were modified with a GIS software for the sole purpose of this exercise. You can upload any geographical dataset (both raster or shapefile) into GEE with the NEW button in the Assets table. As auxiliary functions for cloud masking and spectral index calculation, we will use the same functions provided in Chapter 2: var maskL8sr = function (image) { var cloudShadowBitMask = 1 &lt;&lt; 3; var cloudsBitMask = 1 &lt;&lt; 5; var qa = image.select(&#39;pixel_qa&#39;); var mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0) .and(qa.bitwiseAnd(cloudsBitMask).eq(0)); return image.updateMask(mask).divide(10000) .select(&quot;B[0-9]*&quot;) .copyProperties(image, [&quot;system:time_start&quot;]); }; var addIndicesL8 = function(img) { #// NDVI (Normalized Difference Vegetation Index) var ndvi = img.normalizedDifference([&#39;B5&#39;,&#39;B4&#39;]).rename(&#39;NDVI&#39;); #// NDMI (Normalized Difference Mangrove Index - Shi et al 2016 ) var ndmi = img.normalizedDifference([&#39;B7&#39;,&#39;B3&#39;]).rename(&#39;NDMI&#39;); #// MNDWI (Modified Normalized Difference Water Index - Hanqiu Xu, 2006) var mndwi = img.normalizedDifference([&#39;B3&#39;,&#39;B6&#39;]).rename(&#39;MNDWI&#39;); #// SR (Simple Ratio) var sr = img.select(&#39;B5&#39;).divide(img.select(&#39;B4&#39;)).rename(&#39;SR&#39;); #// Band Ratio 6/5 var ratio65 = img.select(&#39;B6&#39;).divide(img.select(&#39;B5&#39;)).rename(&#39;R65&#39;); #// Band Ratio 4/6 var ratio46 = img.select(&#39;B4&#39;).divide(img.select(&#39;B6&#39;)).rename(&#39;R46&#39;); #// GCVI (Green Chlorophyll Vegetation Index) var gcvi = img.expression(&#39;(NIR/GREEN)-1&#39;,{ &#39;NIR&#39;:img.select(&#39;B5&#39;), &#39;GREEN&#39;:img.select(&#39;B3&#39;) }).rename(&#39;GCVI&#39;); return img .addBands(ndvi) // This will add each spectral index to each Landsat scene .addBands(ndmi) .addBands(mndwi) .addBands(sr) .addBands(ratio65) .addBands(ratio46) .addBands(gcvi); }; 5.1.1 Masking In this example, we will focus on mangrove mapping. Therefore, other known classes can be masked from the analysis. Water mask The objective of this mask is to remove water pixels from the Landsat composite as we are only focusing on Mangroves. We will create a water mask using the JRCs Global Surface Water dataset: var globalwater = ee.Image(&#39;JRC/GSW1_0/GlobalSurfaceWater&#39;); The Global Water Dataset 'JRC/GSW1_0/GlobalSurfaceWater' has different bands: one of them 'occurrence'. This band shows how many times (expressed as %) a given pixel was classified as water relative to the total time span of the dataset. Lets isolate the 'occurrence' band from the globalwater object: var occurence = globalwater.select(&#39;occurrence&#39;); #// Select the occurrence band Masks are composed by zeros and non-zero values. When you set or apply a mask to an image, the output image will keep its original values where the mask has non-zero values and pixels will be masked where the mask has zeros: Figure 5.2: Masking procedure. In this figure, the mask was applied to the raster image generating an output image where pixels are visible only where the correspondent mask pixel has non-zero values. For this example, we want to create a water mask. Thus, the water mask has to have zeros where there is water and non-zero values for non-water pixels. Consequently, when we apply this mask to a Landsat image, pixels of water will be invisible (transparent) while all the other pixels will remain visible in the composite. For the mask using the JRC Global Water dataset, make sure you are selecting &quot;permanent&quot; water. One way of doing this is by filtering the dataset for water pixels that occurred more than 50% of the time over the 35 years time spam for this dataset. You can be more or less restrictive with the water extent by changing the 50% threshold. var waterMask = occurrence.lt(50) #// Selects lower than 50% .unmask(1); #// unmkask all other areas and set the values to 1 Note that .lt(50) was used to select pixels from occurrence that are smaller than 50%. Automatically, the values above 50% will be set to 0 which is what is needed for this mask. In this particular case, we use .unmask(1) to set to 1(or unmask) all the other areas that were originally masked in the JRC Global Water dataset. Figure 5.3: Global water mask produced with JRCs Global Surface Water dataset and Guinea's coastal prefectures (aoi) in red for reference. You can add this mask to the map editor (and clip for aoi) using Map.addLayer(waterMask.clip(aoi), {}, 'Water Mask'). Areas in black (0) will be masked in the composite while areas in white (1) will remain. Elevation mask The purpose of this mask is to further remove pixels that are unlikely to be mangrove based on altitude values. Generally, mangroves will occur near shore where elevation and slope are relatively low. Similar to the water mask, we will create a mask using the SRTM Elevation Data: var srtm = ee.Image(&#39;USGS/SRTMGL1_003&#39;); Similarly to the previous dataset, select the band of interest by using .select. The altitude values for the SRTM dataset are stored in the elevation band 'elevation'. Create a mask elevMask where pixels that have elevation values greater than 25 meters are removed. For that, you select everything that is lower than (.lte) 25 meters; any other value above 25 meters will be set to 0 automatically. var elevation = srtm.select(&#39;elevation&#39;); var elevMask = elevation.lte(25); Figure 5.4: Global elevation (&gt; 25 m) mask produced with the Shuttle Radar Topography Mission dataset and Guinea's coastal prefectures (aoi) in red for reference. You can add this mask to the map editor (and clip for aoi) using Map.addLayer(elevMask.clip(aoi), {}, 'Elevation Mask'). Areas in black (0) will be masked in the composite while areas in white (1) will remain. 5.1.2 Landsat 8 Image Collection and Cloud-free Mosaic Similarly to the examples from Chapter 3, load the Landsat 8 Surface Reflectance data archive into an object collection by using the container ee.ImageCollection and the collection ID 'LANDSAT/LC08/C01/T1_SR'. Secondly, filter this image collection for the temporal parameters by using the container .filterDate. Finally, map the cloud-masking and spectral indices functions to the collection: var collection = ee.ImageCollection(&#39;LANDSAT/LC08/C01/T1_SR&#39;) .filterDate(startDay, endDay) .map(maskL8sr) .map(addIndicesL8); In an object called composite, reduce collection using the container .median(). Next, mask the composite using the masks waterMask and elevMask using .mask() for the first mask and then .updateMask() for the second. This container is necessary as we are updating the raster that will have been masked (by the first mask). Figure 5.5: Output raster from .mask() and .updateMask() of a previously masked input raster. .updateMask() will only mask areas that have not been masked previously; if .mask() is used for a second mask, areas that have been previously invisible (i.e masked) will then assume the values of the mask used. As a rule of thumb: the first mask applied to the raster is done by .mask() and then use .updateMask() for any subsequent masks. Finally, clip the composite to our area of interest aoi using the container clip: var composite = collection .median() .mask(waterMask) #// mask the composite .updateMask(elevMask) #// update the mask .clip(aoi); 5.1.3 Supervised Classification with Random Forest Strata for Sample Selection As shown in the previous examples, the first step to perform a supervised classification is to select the training samples. One way of selecting the training samples for the Random Forest classifier was shown in the training sample selection section of chapter 3. Alternatively, you can automatically select random points based on a stratification map using .stratifiedSample. In this case, the stratification map will have two classes: Mangroves and Non-mangroves. You can create a mangrove stratum for sample selection using available mangrove datasets, such as: Global Mangrove Forest Distribution dataset (raster) for the year 2000, available through Google Earth Engine (ee.ImageCollection('LANDSAT/MANGROVE_FORESTS')), or; The latest global Mangrove Extent from the Global Mangrove Watch, available for download here. Or any other dataset that you may have available; Mangroves: For this example, we will use the GMW Global mangrove extent dataset that was previously downloaded and added as an asset to Google Earth Engine. First, load the mangrove extent shapefile into a object dataset: var dataset = ee.FeatureCollection(&#39;users/celiohelder/Guinea/Mangroves2016&#39;); To create the mangrove stratification class, simply create an image with ee.Image(1) and clip it using dataset: var mangrove = ee.Image(1).clip(dataset); Non-mangroves: Using .where, create an image of zeros where two (2) will be added where there is a pixel from the composite: var nonmangrove = ee.Image(0).where(composite.select(&#39;B1&#39;),2).selfMask() #// use selfMask() to eliminate mask itselt and eliminate the zeros Finally, to create strata, set this image's pixels to 1 where there is pixels of the mangrove stratum and use .rename to rename it to 'landcover. var strata = nonmangrove.where(mangrove,1).rename(&#39;landcover&#39;); The object strata is an image with one band called 'landcover'. It is good practice to rename this band to something easy to remember because .stratifiedSample requires the image and the band name with which the samples will be stratified. Add strata to the map editor to visualize: Map.addLayer (strata, {palette:[&#39;#B3E283&#39;,&#39;#E8E46E&#39;], min:1, max:2}, &#39;Strata&#39;) Figure 5.6: Stratification map strata showing GMW's 2016 Mangrove extent (landcover:1) and non-mangrove areas (landcover:2). The .stratifiedSample function generates a set of random points to each of these classes. Random training sample selection Now that you have the stratification map strata for mangroves and all other areas, use .stratifiedSample function below to select 1000 points (classPoints) for each of the two classes (classValues): var stratified = strata.addBands(ee.Image.pixelLonLat()).stratifiedSample({ numPoints: 1, classBand: &#39;landcover&#39;, scale: 30, region: coastalprefectures, classValues:[1,2], #// The classes from strata that points will be selected from classPoints:[1000,1000] #// number of points per class. }).map(function(f) { #// set these points to geometry and get their coordinates return f.setGeometry(ee.Geometry.Point([f.get(&#39;longitude&#39;), f.get(&#39;latitude&#39;)])) }); The function above includes: .addBands(ee.Image.pixelLonLat()) to add a band to strata that will have the latitude and longitude for each pixel; numPoints is the default number of points to sample in each class in strata. If numPoints is set to 2000, 1000 points will be selected for each of the two classes in strata. This, however, can be overridden for specific classes using the classValues and classPoints properties. In this case, these properties allow which classes you want to use from your stratification map and how many points for each of these classes you want to select. classBand: 'landcover' to define the band from strata that will be used to select the random samples; scale sets the scale to 30 meters to match Landsat nominal spatial resolution; The rest of the function will set these points to geometry and get their lat/long coordinates. You can use the function below to colorize these point samples based on a color palette for visualization. First, the color pallete for this particular case will be slightly different that the color palettes that have been used throught this tutorial so far: it will be created as a ee.List of colors including a null color: var paletteSamples = ee.List([ &#39;FFFFFF&#39;, #// NULL &#39;01937C&#39;, #// Mangrove &#39;B6C867&#39;, #// Non-Mangrove ]); Then, features will include the colorized version of stratified based on the function: var features = stratified.map(function(f) { var landcover = f.get(&#39;landcover&#39;); return ee.Feature(ee.Geometry.Point([f.get(&#39;longitude&#39;), f.get(&#39;latitude&#39;)]), f.toDictionary()).set({style: {color: paletteSamples.get(landcover) }}); }); Add features to the map editor using Map.addLayer and .style following the formula below: Map.addLayer(features.style({styleProperty: &quot;style&quot;}),{}, &#39;Samples/Location&#39;); Remember, these steps are not necessary to the classification workflow. However, it allows you to visualize the selected samples with a color palette of your choice. Figure 5.7: Stratified random samples. The .stratifiedSample function generates a set of random points to each of these strata. Classification As seen in previous chapters, we first select the predictors to assign to each sample point in the sample set. For this example, lets create an object var bands with three spectral bands ('B5','B6','B7') and four spectral indices ('NDVI','MNDWI','SR'). var bands = [&#39;B5&#39;,&#39;B6&#39;,&#39;B7&#39;,&#39;NDVI&#39;,&#39;MNDWI&#39;,&#39;SR&#39;]; In this example, we will create two mangrove extent maps using two sets of samples: samplesAutomatic, which will include the points automatically created with stratified and samplesManual. To create manualpoints, use the same geometry drawing process described in chapter 3. Draw the geometries MangroveTraining and NonMangroveTraining and use .merge to create manualpoints. var manualpoints = MangroveTraining.merge(NonMangroveTraining); Create the samplesAutomatic and samplesManual training sets by overlaying stratified and manualpoints with the Landsat composite to extract the bands predictors using the functions below: var samplesAutomatic = composite.select(bands).sampleRegions({ collection: stratified, // Automatically created sample points properties: [&#39;landcover&#39;], scale: 30, geometries: true, }); var samplesManual = composite.select(bands).sampleRegions({ collection: manualpoints, // Manually selected geometries properties: [&#39;landcover&#39;], scale: 30, geometries: true, }); A third sample set (groundtruth) will be used to illusrate a validation process for both mangrove extent maps. First, load a pre-selected set of samples using ee.FeatureCollection then create samplesgroundtruth similarly to the previous two set of samples: var groundtruth = ee.FeatureCollection(&#39;users/celiohelder/TutorialAssets/GroundTruth&#39;); var samplesgroundtruth = composite.select(bands).sampleRegions({ collection: groundtruth, // Set of geometries pre-selected properties: [&#39;landcover&#39;], scale: 30, geometries: true, }); Next, train two Random Forest classifiers using both samplesAutomatic and samplesManual training samples. In this example, we will use 200 trees and 5 predictors tested at each tree node: var RandomForest1 = ee.Classifier.smileRandomForest(200,5).train({ features: samplesAutomatic, classProperty: &#39;landcover&#39;, inputProperties: bands }); var RandomForest2 = ee.Classifier.smileRandomForest(200,5).train({ features: samplesManual, classProperty: &#39;landcover&#39;, inputProperties: bands }); Finally, classify the composite into two mangrove extent maps using the trained classifiers and add the outputs to the map editor using a color palette of your choice: // Classify the Landsat 8 Composite using the two classifiers to produce 2 land cover maps var classifiedrf1 = composite.select(bands) // select the predictors .classify(RandomForest1); // apply the Random Forest trained with the automatically selected samples var classifiedrf2 = composite.select(bands) // select the predictors .classify(RandomForest2); // apply the Random Forest classifier trained with mannually selected samples // Color palette for the classification outputs var paletteMAP = [ &#39;01937C&#39;, // Mangrove &#39;B6C867&#39;, // Non-Mangrove ]; // Add the classifications to the map editor Map.addLayer (classifiedrf1, {min: 1, max: 2, palette:paletteMAP}, &#39;Classification Automatic Samples&#39;); Map.addLayer (classifiedrf2, {min: 1, max: 2, palette:paletteMAP}, &#39;Classification Manual Samples&#39;); Figure 5.8: Random forest classification outputs. Each map was produced using two different set of samples. Validation For the validation of the two mangrove extent maps we will use .classify and .errorMatrix. .classify will classify the ground truth samples with the trained random forest classifiers 1 and 2; .errorMatrix will compare the result of this classification with their own class label: var validation1 = samplesgroundtruth.classify(RandomForest1); var validation2 = samplesgroundtruth.classify(RandomForest2); var testAccuracy1 = validation1.errorMatrix(&#39;landcover&#39;, &#39;classification&#39;); var testAccuracy2 = validation2.errorMatrix(&#39;landcover&#39;, &#39;classification&#39;); You can print the error matrices along with the overall accuracy and Kappa values to the console using .accuracy() and kappa(): print(&#39;Overall Accuracy Map 1: &#39;, testAccuracy1.accuracy()); print(&#39;Overall Accuracy Map 2: &#39;, testAccuracy2.accuracy()); print(&#39;Kappa: &#39;, testAccuracy1.kappa()); print(&#39;Kappa: &#39;, testAccuracy2.kappa()); print(&#39;Validation error matrix Map1: &#39;, testAccuracy1); print(&#39;Validation error matrix Map2: &#39;, testAccuracy2); Figure 5.9: Validation results for this example. Ground truth data (in this context it refers to independent samples) were used to calculate the overall accuracy and kappa values. "]]
