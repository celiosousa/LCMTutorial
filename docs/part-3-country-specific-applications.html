<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 3 PART 3 - Country-specific Applications | Supervised Land Cover Classification with Google Earth Engine</title>
  <meta name="description" content="Chapter 3 PART 3 - Country-specific Applications | Supervised Land Cover Classification with Google Earth Engine" />
  <meta name="generator" content="bookdown 0.22 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 3 PART 3 - Country-specific Applications | Supervised Land Cover Classification with Google Earth Engine" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 3 PART 3 - Country-specific Applications | Supervised Land Cover Classification with Google Earth Engine" />
  
  
  

<meta name="author" content="Celio Sousa (celio.h.resendedesousa@nasa.gov) and Miroslav Honzak (mhonzak@conservation.org)" />


<meta name="date" content="2022-07-26" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="part-2-advanced-google-earth-engine.html"/>
<link rel="next" href="part-4-ecosystem-accounting.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>


<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Classification Tutorial</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introduction and overview</a></li>
<li class="chapter" data-level="1" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html"><i class="fa fa-check"></i><b>1</b> Part 1 - Basics &amp; Fundamentals</a><ul>
<li class="chapter" data-level="1.1" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#programming-and-remote-sensing-basics"><i class="fa fa-check"></i><b>1.1</b> Programming and Remote Sensing Basics</a><ul>
<li class="chapter" data-level="1.1.1" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#remote-sensing-language"><i class="fa fa-check"></i><b>1.1.1</b> Remote Sensing Language</a></li>
<li class="chapter" data-level="1.1.2" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#google-earth-engines-application-programming-interface-api-and-java-script"><i class="fa fa-check"></i><b>1.1.2</b> Google Earth Engine's Application Programming Interface (API) and Java Script</a></li>
<li class="chapter" data-level="1.1.3" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#exploring-image-and-image-collection"><i class="fa fa-check"></i><b>1.1.3</b> Exploring Image and Image Collection</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#image-and-image-collection-manipulation"><i class="fa fa-check"></i><b>1.2</b> Image and Image Collection Manipulation</a><ul>
<li class="chapter" data-level="1.2.1" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#imMath"><i class="fa fa-check"></i><b>1.2.1</b> Image Math</a></li>
<li class="chapter" data-level="1.2.2" data-path="part-1-basics-fundamentals.html"><a href="part-1-basics-fundamentals.html#compositing-and-mosaicking-compositing-and-mosaicking"><i class="fa fa-check"></i><b>1.2.2</b> Compositing and Mosaicking {#Compositing and Mosaicking}</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="part-2-advanced-google-earth-engine.html"><a href="part-2-advanced-google-earth-engine.html"><i class="fa fa-check"></i><b>2</b> Part 2 - Advanced Google Earth Engine</a><ul>
<li class="chapter" data-level="2.1" data-path="part-2-advanced-google-earth-engine.html"><a href="part-2-advanced-google-earth-engine.html#advanced-image-manipulation-pre-classification"><i class="fa fa-check"></i><b>2.1</b> Advanced Image Manipulation: Pre-classification</a><ul>
<li class="chapter" data-level="2.1.1" data-path="part-2-advanced-google-earth-engine.html"><a href="part-2-advanced-google-earth-engine.html#cloud-and-cloud-shadow-masking"><i class="fa fa-check"></i><b>2.1.1</b> Cloud and cloud shadow masking</a></li>
<li class="chapter" data-level="2.1.2" data-path="part-2-advanced-google-earth-engine.html"><a href="part-2-advanced-google-earth-engine.html#spectral-indices"><i class="fa fa-check"></i><b>2.1.2</b> Spectral indices</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="part-2-advanced-google-earth-engine.html"><a href="part-2-advanced-google-earth-engine.html#supervised-classification-using-random-forest"><i class="fa fa-check"></i><b>2.2</b> Supervised Classification using Random Forest</a><ul>
<li class="chapter" data-level="2.2.1" data-path="part-2-advanced-google-earth-engine.html"><a href="part-2-advanced-google-earth-engine.html#example-1-land-cover-classification-of-greater-cairo-and-giza-area-egypt---year-2022"><i class="fa fa-check"></i><b>2.2.1</b> Example 1: Land cover classification of Greater Cairo and Giza area, Egypt - Year 2022</a></li>
<li class="chapter" data-level="2.2.2" data-path="part-2-advanced-google-earth-engine.html"><a href="part-2-advanced-google-earth-engine.html#example-2-2015---2022-map-to-map-change-of-greater-cairo-and-giza-area-egypt"><i class="fa fa-check"></i><b>2.2.2</b> Example 2: 2015 - 2022 Map-to-Map change of greater Cairo and Giza area, Egypt</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="part-2-advanced-google-earth-engine.html"><a href="part-2-advanced-google-earth-engine.html#post-classification-processing"><i class="fa fa-check"></i><b>2.3</b> Post-classification processing</a><ul>
<li class="chapter" data-level="2.3.1" data-path="part-2-advanced-google-earth-engine.html"><a href="part-2-advanced-google-earth-engine.html#re-classification"><i class="fa fa-check"></i><b>2.3.1</b> Re-classification</a></li>
<li class="chapter" data-level="2.3.2" data-path="part-2-advanced-google-earth-engine.html"><a href="part-2-advanced-google-earth-engine.html#map-spatial-smoothing"><i class="fa fa-check"></i><b>2.3.2</b> Map spatial smoothing</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html"><i class="fa fa-check"></i><b>3</b> PART 3 - Country-specific Applications</a><ul>
<li class="chapter" data-level="3.1" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html#guinea"><i class="fa fa-check"></i><b>3.1</b> Guinea</a><ul>
<li class="chapter" data-level="3.1.1" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html#mangrove-mapping-in-guinea-west-africa"><i class="fa fa-check"></i><b>3.1.1</b> Mangrove mapping in Guinea, West Africa</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html#liberia"><i class="fa fa-check"></i><b>3.2</b> Liberia</a><ul>
<li class="chapter" data-level="3.2.1" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html#anomaly-based-plantation-detection"><i class="fa fa-check"></i><b>3.2.1</b> Anomaly-based plantation detection</a></li>
<li class="chapter" data-level="3.2.2" data-path="part-3-country-specific-applications.html"><a href="part-3-country-specific-applications.html#class-by-class-land-cover-mapping"><i class="fa fa-check"></i><b>3.2.2</b> Class-by-class land cover mapping</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html"><i class="fa fa-check"></i><b>4</b> Part 4 - Ecosystem Accounting</a><ul>
<li class="chapter" data-level="4.1" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#introduction-to-ecosystem-accounting"><i class="fa fa-check"></i><b>4.1</b> Introduction to Ecosystem Accounting</a><ul>
<li class="chapter" data-level="4.1.1" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#essentials"><i class="fa fa-check"></i><b>4.1.1</b> Essentials</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#ecosystem-extent-account"><i class="fa fa-check"></i><b>4.2</b> Ecosystem Extent Account</a><ul>
<li class="chapter" data-level="4.2.1" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#structure-of-ecosystem-extent-account"><i class="fa fa-check"></i><b>4.2.1</b> Structure of ecosystem extent account</a></li>
<li class="chapter" data-level="4.2.2" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#examples-and-exercises"><i class="fa fa-check"></i><b>4.2.2</b> Examples and exercises</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#tools-for-compiling-ecosystem-extent-account-tables"><i class="fa fa-check"></i><b>4.3</b> Tools for Compiling Ecosystem Extent Account Tables</a><ul>
<li class="chapter" data-level="4.3.1" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#platforms-for-running-python-scripts"><i class="fa fa-check"></i><b>4.3.1</b> Platforms for running Python scripts</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#compiling-ecosystem-extent-account-tables"><i class="fa fa-check"></i><b>4.4</b> Compiling Ecosystem Extent Account Tables</a><ul>
<li class="chapter" data-level="4.4.1" data-path="part-4-ecosystem-accounting.html"><a href="part-4-ecosystem-accounting.html#essentials-1"><i class="fa fa-check"></i><b>4.4.1</b> Essentials</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Supervised Land Cover Classification with Google Earth Engine</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="part-3---country-specific-applications" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> PART 3 - Country-specific Applications</h1>
<p>In this part we will explore examples of class-specific classification using previously used functions as well as useful land cover classification-based analysis.</p>
<div id="guinea" class="section level2">
<h2><span class="header-section-number">3.1</span> Guinea</h2>
<p>Description of Guinea here</p>
<div id="mangrove-mapping-in-guinea-west-africa" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Mangrove mapping in Guinea, West Africa</h3>
<p>In this example, we will use the codes from the previous parts for mangrove mapping in Guinea, in West Africa. We will also introduce the use of other datasets for masking and sample selection to assist in the classification workflow.</p>
<p>We will start by <a href="https://code.earthengine.google.com/" target="_blank">opening a new code editor page</a> and by defining the spatial and temporal parameters of the composite you wish to classify, just like the other examples. For the temporal parameters, let’s use an annual 2021 composite:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var year =<span class="st"> </span><span class="dv">2021</span>;
var startDay =<span class="st"> </span>(year)<span class="op">+</span><span class="st">&#39;-01-01&#39;</span>;
var endDay =<span class="st"> </span>(year)<span class="op">+</span><span class="st">&#39;-12-30&#39;</span>;</code></pre></div>
<p>For the spatial parameters, we can use the <em>Large Scale International Boundary (LSIB)</em> dataset and select Guinea’s national border. First, we will load the dataset into an object called 'countries' using the <code>ee.FeatureCollection()</code> object and the feature collection ID 'USDOS/LSIB/2013'. Secondly, we will filter the dataset using <code>.filterMetadata()</code> and select Guinea from the list of countries and storing it in <code>aoi</code>:</p>
<div class="rmdcomment">
<p>
Note that you can select a any country border by filtering <em>'USDOS/LSIB/2013'</em> dataset by using <em>.filterMetadata('name' , 'equals', 'NAME OF THE COUNTRY IN CAPITAL LETTERS')</em>.
</p>
</div>
<p>Alternatively, you can use any previously uploaded Guinea's boundary datasets available <a href="https://code.earthengine.google.com/16fbfeb335381c203fed98eb81712dda" target="_blank">here.</a> Select a dataset from the list, copy its Asset ID and load it with <code>ee.FeatureCollection</code> into <code>aoi</code>.</p>
<div class="figure"><span id="fig:my-borders"></span>
<img src="images/borders.png" alt="Examples of Guinea's administrative borders." width="1069" />
<p class="caption">
Figure 3.1: Examples of Guinea's administrative borders.
</p>
</div>
<p>In this example, we aim to map of Guinea's mangroves. Therefore, we will chose <code>prefecures5k</code> as it emcompasses the entirety of Guinea's coast:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var aoi =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Guinea/prefectures5k&#39;</span>);</code></pre></div>
<div class="caution">
<p>
<em><strong>Important</strong></em>: All these datasets were made available through our collaboration with our colleagues in Guinea and the World Bank and they were modified with a GIS software for the sole purpose of this exercise. You can upload any geographical dataset (both raster or shapefile) into GEE with the <em><strong>NEW</strong></em> button in the <strong>Assets</strong> table.
</p>
</div>
<p>As auxiliary functions for cloud masking and spectral index calculation, we will use the same functions provided in PART 2:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">function</span> <span class="kw">maskClouds</span>(image) {
  var cloudShadowBitMask =<span class="st"> </span><span class="kw">ee.Number</span>(<span class="dv">2</span>)<span class="kw">.pow</span>(<span class="dv">3</span>)<span class="kw">.int</span>();
  var cloudsBitMask =<span class="st"> </span><span class="kw">ee.Number</span>(<span class="dv">2</span>)<span class="kw">.pow</span>(<span class="dv">4</span>)<span class="kw">.int</span>();
  var QA =<span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;QA_PIXEL&#39;</span>);
  var mask =<span class="st"> </span><span class="kw">QA.bitwiseAnd</span>(cloudShadowBitMask)<span class="kw">.eq</span>(<span class="dv">0</span>)
      <span class="kw">.and</span>(<span class="kw">QA.bitwiseAnd</span>(cloudsBitMask)<span class="kw">.eq</span>(<span class="dv">0</span>));
  return <span class="kw">image.updateMask</span>(mask)<span class="kw">.divide</span>(<span class="dv">100000</span>)<span class="kw">.select</span>(<span class="st">&quot;SR_B[0-9]*&quot;</span>)<span class="kw">.copyProperties</span>(image, [<span class="st">&quot;system:time_start&quot;</span>]);
}

<span class="cf">function</span> <span class="kw">addIndices</span>(image) {
  var ndvi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B4&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NDVI&#39;</span>);
  var nbr =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B7&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NBR&#39;</span>);
  var ndmi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B7&#39;</span>,<span class="st">&#39;SR_B3&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NDMI&#39;</span>);
  var mndwi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B3&#39;</span>,<span class="st">&#39;SR_B6&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;MNDWI&#39;</span>);
  var sr =<span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>)<span class="kw">.divide</span>(<span class="kw">image.select</span>(<span class="st">&#39;SR_B4&#39;</span>))<span class="kw">.rename</span>(<span class="st">&#39;SR&#39;</span>);
  var bare =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B6&#39;</span>,<span class="st">&#39;SR_B7&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;BI&#39;</span>);
  var gcvi =<span class="st"> </span><span class="kw">image.expression</span>(<span class="st">&#39;(NIR/GREEN)-1&#39;</span>,{
    <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>),
    <span class="st">&#39;GREEN&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B3&#39;</span>)
  })<span class="kw">.rename</span>(<span class="st">&#39;GCVI&#39;</span>);
  var evi =<span class="st"> </span><span class="kw">image.expression</span>(
  <span class="st">&#39;2.5 * ((NIR-RED) / (NIR + 6 * RED - 7.5* SR_BLUE +1))&#39;</span>, {
    <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>),
    <span class="st">&#39;RED&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B4&#39;</span>),
    <span class="st">&#39;SR_BLUE&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B2&#39;</span>)
  })<span class="kw">.rename</span>(<span class="st">&#39;EVI&#39;</span>);
  var msavi =<span class="st"> </span><span class="kw">image.expression</span>(
  <span class="st">&#39;(2 * NIR + 1 - sqrt(pow((2 * NIR + 1), 2) - 8 * (NIR - RED)) ) / 2&#39;</span>, {
    <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>), 
    <span class="st">&#39;RED&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;SR_B4&#39;</span>)}
)<span class="kw">.rename</span>(<span class="st">&#39;MSAVI&#39;</span>);
    return image
    <span class="kw">.addBands</span>(ndvi)
    <span class="kw">.addBands</span>(nbr)
    <span class="kw">.addBands</span>(ndmi)
    <span class="kw">.addBands</span>(mndwi)
    <span class="kw">.addBands</span>(sr)
    <span class="kw">.addBands</span>(evi)
    <span class="kw">.addBands</span>(msavi)
    <span class="kw">.addBands</span>(gcvi)
    <span class="kw">.addBands</span>(bare);
}</code></pre></div>
<p><strong>1) Masking</strong></p>
<p>In this example, we will focus on mangrove forest mapping. Therefore, other known classes can be masked from the analysis.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var globalwater =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;JRC/GSW1_0/GlobalSurfaceWater&#39;</span>);</code></pre></div>
<p>The Global Water Dataset <code>'JRC/GSW1_0/GlobalSurfaceWater'</code> has different bands: one of them <code>'occurrence'</code>. This band shows how many times (expressed as %) a given pixel was classified as water relative to the total time span of the dataset. Let’s isolate the <code>'occurrence'</code> band from the globalwater object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var occurrence =<span class="st"> </span><span class="kw">globalwater.select</span>(<span class="st">&#39;occurrence&#39;</span>);</code></pre></div>
<p><strong>Masks</strong> are composed by zeros and non-zero values. When you set or apply a mask to an image, the output image will keep its original values where the mask has non-zero values and pixels will be masked where the mask has zeros:</p>
<div class="figure"><span id="fig:my-mask"></span>
<img src="images/maskexample.png" alt="Masking procedure. In this figure, the mask was applied to the raster image generating an output image where pixels are visible only where the correspondent mask pixel has non-zero values." width="1164" />
<p class="caption">
Figure 3.2: Masking procedure. In this figure, the mask was applied to the raster image generating an output image where pixels are visible only where the correspondent mask pixel has non-zero values.
</p>
</div>
<p>For this example, we want to create a water mask. Thus, the water mask has to have zeros where there is water and non-zero values for non-water pixels. Consequently, when we apply this mask to a Landsat image, pixels of water will be invisible (transparent) while all the other pixels will remain visible in the composite. For the mask using the JRC Global Water dataset, make sure you are selecting &quot;permanent&quot; water. One way of doing this is by filtering the dataset for water pixels that occurred more than 50% of the time over the 35 years time spam for this dataset. You can be more or less restrictive with the water extent by changing the 50% threshold.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var waterMask =<span class="st"> </span><span class="kw">occurrence.lt</span>(<span class="dv">50</span>)<span class="kw">.unmask</span>(<span class="dv">1</span>);</code></pre></div>
<p>Note that <code>.lt(50)</code> was used to select pixels from <code>occurrence</code> that are <strong>smaller</strong> (or lower) than 50%. Automatically, the values above 50% will be set to 0 which is what is needed for this mask. In this particular case, we use <code>.unmask(1)</code> to set to 1 (or unmask) all the other areas that were originally masked in the JRC Global Water dataset.</p>
<div class="figure"><span id="fig:my-watermask"></span>
<img src="images/watermask.png" alt="Global water mask produced with JRC’s Global Surface Water dataset and Guinea's coastal prefectures (`aoi`) in red for reference. You can add this mask to the map editor (and clip for `aoi`) using `Map.addLayer(waterMask.clip(aoi), {}, 'Water Mask')`. Areas in black (0) will be masked in the composite while areas in white (1) will remain." width="1033" />
<p class="caption">
Figure 3.3: Global water mask produced with JRC’s Global Surface Water dataset and Guinea's coastal prefectures (<code>aoi</code>) in red for reference. You can add this mask to the map editor (and clip for <code>aoi</code>) using <code>Map.addLayer(waterMask.clip(aoi), {}, 'Water Mask')</code>. Areas in black (0) will be masked in the composite while areas in white (1) will remain.
</p>
</div>
<ul>
<li><em><strong>Elevation mask</strong></em></li>
</ul>
<p>The purpose of this mask is to further remove pixels that are unlikely to be mangrove forests based on altitude values. Generally, mangroves will occur near shore where elevation and slope are relatively low. Similar to the water mask, we will create a mask using the SRTM Elevation Data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var srtm =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;USGS/SRTMGL1_003&#39;</span>);</code></pre></div>
<p>Similarly to the previous dataset, we will select the band of interest by using the <code>.select()</code> method. The altitude values for the SRTM dataset are stored in the elevation band called 'elevation'. We will create a mask 'elevMask' where pixels that have elevation values <em>greater than 25 meters</em> are removed. For that, you select everything that is <em><strong>lower</strong></em> than (<code>.lte</code>) 25 meters; any other value above 25 meters will be set to 0 automatically when using <code>.select()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var elevation =<span class="st"> </span><span class="kw">srtm.select</span>(<span class="st">&#39;elevation&#39;</span>);
var elevMask =<span class="st"> </span><span class="kw">elevation.lte</span>(<span class="dv">25</span>);</code></pre></div>
<div class="figure"><span id="fig:my-elevmask"></span>
<img src="images/elevmask.PNG" alt="Global elevation (&gt; 25 m) mask produced with the Shuttle Radar Topography Mission dataset and Guinea's coastal prefectures (`aoi`) in red for reference. You can add this mask to the map editor (and clip for `aoi`) using *Map.addLayer(elevMask.clip(aoi), {}, 'Elevation Mask')*. Areas in black (0) will be masked in the composite while areas in white (1) will remain." width="1056" />
<p class="caption">
Figure 3.4: Global elevation (&gt; 25 m) mask produced with the Shuttle Radar Topography Mission dataset and Guinea's coastal prefectures (<code>aoi</code>) in red for reference. You can add this mask to the map editor (and clip for <code>aoi</code>) using <em>Map.addLayer(elevMask.clip(aoi), {}, 'Elevation Mask')</em>. Areas in black (0) will be masked in the composite while areas in white (1) will remain.
</p>
</div>
<p><a href="https://code.earthengine.google.com/62a8bbb4bef12c7c998dd7fe665a6d66" target="_blank">Code Checkpoint</a></p>
<p><strong>2) Landsat 8 Image Collection and Cloud-free Mosaic</strong></p>
<p>Similarly to the examples from PART 2, we will load the Landsat 8 Surface Reflectance data archive into an object called 'collection' by using the container <code>ee.ImageCollection()</code> and the collection ID <code>'LANDSAT/LC08/C02/T1_L2'</code>. Secondly, we will filter this image collection for the temporal parameters by using the method <code>.filterDate()</code>. Finally, we will map the cloud-masking and spectral indices functions to the collection:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var collection =<span class="st"> </span><span class="kw">ee.ImageCollection</span>(<span class="st">&#39;LANDSAT/LC08/C02/T1_L2&#39;</span>)
                   <span class="kw">.filterDate</span>(startDay,endDay)
                   <span class="kw">.map</span>(maskClouds)
                   <span class="kw">.map</span>(addIndices);</code></pre></div>
<p>Then, in an object called 'composite', we will reduce the image collection into an annual composite using the <code>.median()</code> method. Next, we will mask the composite using the masks <code>waterMask</code> and <code>elevMask</code> using <code>.mask()</code> method for the first mask and then <code>.updateMask()</code> for the second. This container is necessary as we are <em><strong>updating</strong></em> the raster that will have been masked by the first mask.</p>
<div class="figure"><span id="fig:my-updatemask"></span>
<img src="images/updatemask.png" alt="Output raster from .`mask()` and `.updateMask()` of a previously masked input raster. `.updateMask()` will only mask areas that have not been masked previously; if `.mask()` is used for a second mask, areas that have been previously invisible (i.e masked) will then assume the values of the mask used." width="1164" />
<p class="caption">
Figure 3.5: Output raster from .<code>mask()</code> and <code>.updateMask()</code> of a previously masked input raster. <code>.updateMask()</code> will only mask areas that have not been masked previously; if <code>.mask()</code> is used for a second mask, areas that have been previously invisible (i.e masked) will then assume the values of the mask used.
</p>
</div>
<div class="rmdcomment">
<p>
As a rule of thumb: the <em>first</em> mask applied to the raster is done by <em>.mask()</em> and then use <em>.updateMask()</em> for any subsequent masks.
</p>
</div>
<p>Finally, we will clip the composite to our area of interest <code>aoi</code> using the container <code>.clip()</code> method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var composite =<span class="st"> </span>collection
                <span class="kw">.median</span>()
                <span class="kw">.mask</span>(waterMask)
                <span class="kw">.updateMask</span>(elevMask)
                <span class="kw">.clip</span>(aoi);</code></pre></div>
<div class="starcomment">
<p>
Setting your code with indents is very helpful!. It will allow you to &quot;turn on&quot; and &quot;turn off&quot; certain portions of a code with comment bars. In the example above, you can turn off any mask by just adding // before the full period.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var composite =<span class="st"> </span>collection
                <span class="kw">.median</span>()
                <span class="op">/</span><span class="er">/</span><span class="kw">.mask</span>(waterMask)
                <span class="op">/</span><span class="er">/</span><span class="kw">.updateMask</span>(elevMask)
                <span class="kw">.clip</span>(aoi);</code></pre></div>
<div class="starcomment">
<p>
The code above is just for illustration purposes! Remember to remove the // from the portion of the code that you want Earth Engine to read.
</p>
</div>
<p>Finally, add the composite to the Map editor using the code below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.centerObject</span>(aoi);
<span class="kw">Map.addLayer</span>(composite, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B6&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>], min<span class="op">:</span><span class="fl">0.1</span>, max<span class="op">:</span><span class="fl">0.2</span>}, <span class="st">&#39;Composite&#39;</span>);</code></pre></div>
<p>This band composition (RGB 564) is a good composition to highlight mangrove forests:</p>
<div class="figure"><span id="fig:CompositeMaskedGuinea"></span>
<img src="images/PartIII-CompositeMaskedGuinea.png" alt="Masked composite displayed with an RGB564 composition highlighting mangrove forests in dark red. Notice that areas of open water and higher altitudes were masked as they are not relevant to our example. Unmasked composite was added for comparison purposes: you can take advantage of indenting to turn masks on/off with // comment bars." width="858" />
<p class="caption">
Figure 3.6: Masked composite displayed with an RGB564 composition highlighting mangrove forests in dark red. Notice that areas of open water and higher altitudes were masked as they are not relevant to our example. Unmasked composite was added for comparison purposes: you can take advantage of indenting to turn masks on/off with // comment bars.
</p>
</div>
<p><a href="https://code.earthengine.google.com/912be20630ba0aa4c86d0d12b3d76f94" target="_blank">Code Checkpoint</a></p>
<p><strong>3) Supervised Classification with Random Forest</strong></p>
<ul>
<li><em><strong>Strata for Sample Selection</strong></em></li>
</ul>
<p>As shown in Part 1 and Part 2, the first step to perform a supervised classification is to select the training samples. One way of selecting the training samples for the Random Forest classifier was shown in the training sample selection section of Part 2. Alternatively, you can automatically select random points based on a stratification map using <code>.stratifiedSample()</code>. In this case, the stratification map will have two classes: Mangroves and Non-mangroves. You can create a mangrove stratum for sample selection using available mangrove datasets, such as:</p>
<ul>
<li><p>Global Mangrove Forest Distribution dataset (raster) for the year 2000, available through Google Earth Engine (<code>ee.ImageCollection('LANDSAT/MANGROVE_FORESTS')</code>), or;</p></li>
<li><p>The latest global Mangrove Extent from the <a href="https://www.globalmangrovewatch.org/country/GIN?map=eyJiYXNlbWFwIjoibGlnaHQiLCJ2aWV3cG9ydCI6eyJsYXRpdHVkZSI6OS45NDcyMTU4OTUwNDI0NzIsImxvbmdpdHVkZSI6LTE1Ljk0Njk3MjgyMzgwNzMzOCwiem9vbSI6Ni4xMzk0MjcyMjU1NDAzMjcsImJlYXJpbmciOjAsInBpdGNoIjowfX0%3D" target="_blank">Global Mangrove Watch</a>, available for download <a href="https://data.unep-wcmc.org/datasets/45" target="_blank">here.</a></p></li>
<li><p>Or any other dataset that you may have available;</p></li>
</ul>
<ol style="list-style-type: lower-alpha">
<li><em>Mangroves</em>: For this example, we will use the GMW Global mangrove extent dataset for 2016 that was previously downloaded and added as an asset to Google Earth Engine. First, load the mangrove extent shapefile into a <code>ee.FeatureCollection</code> object:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var mangroveDataset =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Guinea/Mangroves2016&#39;</span>);</code></pre></div>
<p>As seen in Part 2, to create the mangrove stratification class, we simply create an image with <code>ee.Image(1)</code> and clip it using <code>mangroveDataset</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var mangrove =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>)<span class="kw">.clip</span>(mangroveDataset);</code></pre></div>
<ol start="2" style="list-style-type: lower-alpha">
<li><em>Non-mangroves</em>: Using <code>.where()</code> (See its formula here: <a href="part-2-advanced-google-earth-engine.html#fig:my-where">2.34</a>), we will create an image of zeros where the value two (2) will be added where there is a pixel of any band from the <code>composite</code>:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var nonmangrove =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>)<span class="kw">.where</span>(<span class="kw">composite.select</span>(<span class="st">&#39;SR_B1&#39;</span>),<span class="dv">2</span>)<span class="kw">.selfMask</span>();</code></pre></div>
<div class="starcomment">
<p>
Notice that a new method was used in the code above. The method <code>.selfMask()</code> is an method from an <code>ee.Image()</code> object that is used when you want to mask an image with itself. In other words, when an ee.Image has zeros in it, you can use <code>.selfMask()</code> to remove the zeros, just like an other mask.
</p>
</div>
<p>Finally, to create a stratification classes map called 'strata', we will use <code>.where()</code> to set <code>nonmangrove</code> pixels to <em>1</em> where it overlaps with pixels of the mangrove stratum (<code>mangrove</code>) and use <code>.rename()</code> to rename it to <code>'stratificationClass'</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var strata =<span class="st"> </span><span class="kw">nonmangrove.where</span>(mangrove,<span class="dv">1</span>)<span class="kw">.rename</span>(<span class="st">&#39;stratificationClass&#39;</span>);</code></pre></div>
<p>The object <code>strata</code> is an image with one band called <code>'stratificationClass'</code>, with Mangrove pixes have value of 1 and non-mangrove pixels have value of 2. It is good practice to rename this band to something easy to remember because <code>.stratifiedSample()</code> requires the image and the band name with which the samples will be selected.</p>
<p>Add <code>strata</code> to the map editor to visualize:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span> (strata, {palette<span class="op">:</span>[<span class="st">&#39;#6D8B74&#39;</span>,<span class="st">&#39;#D0C9C0&#39;</span>], min<span class="op">:</span><span class="dv">1</span>, max<span class="op">:</span><span class="dv">2</span>}, <span class="st">&#39;Stratification Map&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:my-strata"></span>
<img src="images/PartIII-StratificationMap.png" alt="Stratification map `strata` showing Global Mangrove Watch's 2016 Mangrove extent (`stratificationClass: 1`) and non-mangrove areas (`stratificationClass: 2`). The `.stratifiedSample()` method will generate a set of random points to each of these classes." width="1027" />
<p class="caption">
Figure 3.7: Stratification map <code>strata</code> showing Global Mangrove Watch's 2016 Mangrove extent (<code>stratificationClass: 1</code>) and non-mangrove areas (<code>stratificationClass: 2</code>). The <code>.stratifiedSample()</code> method will generate a set of random points to each of these classes.
</p>
</div>
<ul>
<li><em><strong>Random training sample selection</strong></em></li>
</ul>
<p>Now that we have the stratification map <code>strata</code> for mangroves and all other areas, we will use <code>.stratifiedSample()</code> method below to select 1000 points (<code>classPoints</code>) for each of the two classes (<code>classValues</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var stratified =<span class="st"> </span><span class="kw">strata.addBands</span>(<span class="kw">ee.Image.pixelLonLat</span>())<span class="kw">.stratifiedSample</span>({
      numPoints<span class="op">:</span><span class="st"> </span><span class="dv">1</span>,
      classBand<span class="op">:</span><span class="st"> &#39;stratificationClass&#39;</span>,
      scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>,
      region<span class="op">:</span><span class="st"> </span>aoi,
      classValues<span class="op">:</span>[<span class="dv">1</span>,<span class="dv">2</span>],       
      classPoints<span class="op">:</span>[<span class="dv">1000</span>,<span class="dv">1000</span>]  
    })<span class="kw">.map</span>(<span class="cf">function</span>(f) {       
       return <span class="kw">f.setGeometry</span>(<span class="kw">ee.Geometry.Point</span>([<span class="kw">f.get</span>(<span class="st">&#39;longitude&#39;</span>), <span class="kw">f.get</span>(<span class="st">&#39;latitude&#39;</span>)]));
    });</code></pre></div>
<p>The code above includes:</p>
<ol style="list-style-type: lower-alpha">
<li><p><code>.addBands(ee.Image.pixelLonLat())</code> to add a band to <code>strata</code> that will have the latitude and longitude for each pixel;</p></li>
<li><p><code>numPoints</code> is the default number of points to sample in each class in <code>strata</code>. If <code>numPoints</code> is set to 2000, 1000 points will be selected for each of the two classes in <code>strata</code>. This, however, can be overridden for specific classes using the <code>classValues</code> and <code>classPoints</code> properties. In this case, these properties allow which classes you want to use from your stratification map and how many points for each of these classes you want to select.</p></li>
<li><p><code>classBand: 'stratificationClass'</code> to define the band from <code>strata</code> that will be used to select the random samples;</p></li>
<li><p><code>scale</code> sets the scale to 30 meters to match Landsat nominal spatial resolution;</p></li>
<li><p>The rest of the code will set these samples as geometry and get their lat/long coordinates.</p></li>
</ol>
<p>You can use the code below to colorize these point samples based on a color palette for visualization. First, the color pallete for this particular case will be slightly different that the color palettes that have been used throught this tutorial so far: it will be created as a <code>ee.List()</code> of colors including a null color:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var paletteSamples =<span class="st"> </span><span class="kw">ee.List</span>([
  <span class="st">&#39;FFFFFF&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="ot">NULL</span>
  <span class="st">&#39;6D8B74&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Mangrove
  <span class="st">&#39;D0C9C0&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span>Non<span class="op">-</span>Mangrove
 ]);</code></pre></div>
<p>Then, a 'features' object will be created to include the colorized version of <code>stratified</code> based on the code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var features =<span class="st"> </span><span class="kw">stratified.map</span>(<span class="cf">function</span>(f) {
  var landcover =<span class="st"> </span><span class="kw">f.get</span>(<span class="st">&#39;stratificationClass&#39;</span>);
  return <span class="kw">ee.Feature</span>(<span class="kw">ee.Geometry.Point</span>([<span class="kw">f.get</span>(<span class="st">&#39;longitude&#39;</span>), <span class="kw">f.get</span>(<span class="st">&#39;latitude&#39;</span>)]), <span class="kw">f.toDictionary</span>())<span class="kw">.set</span>({style<span class="op">:</span><span class="st"> </span>{color<span class="op">:</span><span class="st"> </span><span class="kw">paletteSamples.get</span>(landcover) }}); 
}); </code></pre></div>
<p>Finally, we will add <code>features</code> to the map editor using <code>Map.addLayer</code> and <code>.style()</code> following the formula below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(<span class="kw">features.style</span>({styleProperty<span class="op">:</span><span class="st"> &quot;style&quot;</span>}),{}, <span class="st">&#39;Samples/Location&#39;</span>);</code></pre></div>
<div class="rmdcomment">
<p>
Remember, <strong>these steps are not necessary to the classification workflow</strong>. However, it allows you to visualize the selected samples with a color palette of your choice.
</p>
</div>
<div class="figure"><span id="fig:StratificationSamples"></span>
<img src="images/PartIII-StratificationSamples.png" alt="Stratified random samples. The `.stratifiedSample()` method generates a set of random points to each of these strata." width="856" />
<p class="caption">
Figure 3.8: Stratified random samples. The <code>.stratifiedSample()</code> method generates a set of random points to each of these strata.
</p>
</div>
<p><a href="https://code.earthengine.google.com/9eebb9a441f2e4e6cff74329e8aa9563" target="_blank">Code Checkpoint</a></p>
<ul>
<li><em><strong>Classification</strong></em></li>
</ul>
<p>As seen in in Part 2, one of the first steps to train a Random Forest classifier is select the predictors to assign to each sample point in the sample set. For this example, we will create a list ('bands') with the names of three spectral bands (<code>'SR_B4'</code>,<code>'SR_B5'</code>,<code>'SR_B6'</code>) and the spectral indices (<code>'NDVI'</code>,<code>'NBR'</code>,<code>'MNDWI'</code>,<code>'SR'</code>,<code>'GCVI'</code> and <code>'MSAVI'</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var bands =<span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>,<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B6&#39;</span>,<span class="st">&#39;NDVI&#39;</span>,<span class="st">&#39;NBR&#39;</span>,<span class="st">&#39;MNDWI&#39;</span>,<span class="st">&#39;SR&#39;</span>,<span class="st">&#39;GCVI&#39;</span>,<span class="st">&#39;MSAVI&#39;</span>];</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var samplesAutomatic =<span class="st"> </span><span class="kw">composite.select</span>(bands)<span class="kw">.sampleRegions</span>({
  collection<span class="op">:</span><span class="st"> </span>stratified,   
  properties<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;stratificationClass&#39;</span>],
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>,
  geometries<span class="op">:</span><span class="st"> </span>true,
});</code></pre></div>
<p>A second sample set ('groundtruth') will be used to illusrate a validation process for the mangrove extent map. First, we will load a pre-selected set of samples using <code>ee.FeatureCollection()</code> then create 'samplesgroundtruth' similarly to the previous set of samples:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var groundtruth =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Guinea/Groundtruth&#39;</span>);</code></pre></div>
<p>If you print <code>groundtruth</code> to the <strong>Console</strong> tab, you will see that its property is called <code>landcover</code>. Therefore, in the code below, the argument <code>properties</code> will be a 'landcover':</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var samplesgroundtruth =<span class="st"> </span><span class="kw">composite.select</span>(bands)<span class="kw">.sampleRegions</span>({
  collection<span class="op">:</span><span class="st"> </span>groundtruth,
  properties<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;landcover&#39;</span>],
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>,
  geometries<span class="op">:</span><span class="st"> </span>true,
});</code></pre></div>
<p>Next, we will train a Random Forest classifier using the <code>samplesAutomatic</code> as training samples. In this example, we will use 200 trees and 8 predictors tested at each tree node:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var RandomForest =<span class="st"> </span><span class="kw">ee.Classifier.smileRandomForest</span>(<span class="dv">200</span>,<span class="dv">8</span>)<span class="kw">.train</span>({
  features<span class="op">:</span><span class="st"> </span>samplesAutomatic, 
  classProperty<span class="op">:</span><span class="st"> &#39;stratificationClass&#39;</span>, 
  inputProperties<span class="op">:</span><span class="st"> </span>bands
});</code></pre></div>
<p>Finally, we will classify <code>composite</code> into a mangrove extent map using the trained classifier and add the output to the map editor using a color palette of your choice:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var classification =<span class="st"> </span><span class="kw">composite.select</span>(bands)<span class="kw">.classify</span>(RandomForest);

var paletteMAP =<span class="st"> </span>[
  <span class="st">&#39;01937C&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Mangrove
  <span class="st">&#39;B6C867&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Non<span class="op">-</span>Mangrove
];

<span class="kw">Map.addLayer</span> (classification, {min<span class="op">:</span><span class="st"> </span><span class="dv">1</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">2</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Classification with Automatic Samples&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:my-classficationmangrove"></span>
<img src="images/PartIII-RFMangroveGuinea.png" alt="Random forest classification output produced with automatic sample selection" width="858" />
<p class="caption">
Figure 3.9: Random forest classification output produced with automatic sample selection
</p>
</div>
<p><a href="https://code.earthengine.google.com/0a0e15f94c78cb1516c90de46ec1fe10" target="_blank">Code Checkpoint</a></p>
<ul>
<li><em><strong>Validation</strong></em></li>
</ul>
<p>For the validation of the mangrove extent map we will use <code>.classify()</code> and <code>.errorMatrix()</code>.The <code>.classify</code> method will classify the ground truth samples with the trained random forest classifier; <code>.errorMatrix()</code> will compare the result of this classification with their own class label:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var validation =<span class="st"> </span><span class="kw">samplesgroundtruth.classify</span>(RandomForest);
var testAccuracy =<span class="st"> </span><span class="kw">validation.errorMatrix</span>(<span class="st">&#39;landcover&#39;</span>, <span class="st">&#39;classification&#39;</span>);</code></pre></div>
<p>Print the results to the <strong>Console</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="st">&#39;Map Overall Accuracy: &#39;</span>, <span class="kw">testAccuracy.accuracy</span>());
<span class="kw">print</span>(<span class="st">&#39;Kappa: &#39;</span>, <span class="kw">testAccuracy.kappa</span>());
<span class="kw">print</span>(<span class="st">&#39;Validation error matrix Map: &#39;</span>, testAccuracy);</code></pre></div>
<div class="figure"><span id="fig:ValidationGuinea"></span>
<img src="images/PartIII-ValidationGuinea.png" alt="Validation results for this example. Ground truth data (in this context it refers to independent samples) were used to calculate the overall accuracy and kappa values." width="888" />
<p class="caption">
Figure 3.10: Validation results for this example. Ground truth data (in this context it refers to independent samples) were used to calculate the overall accuracy and kappa values.
</p>
</div>
</div>
</div>
<div id="liberia" class="section level2">
<h2><span class="header-section-number">3.2</span> Liberia</h2>
<p>In this example, we will use the codes from the previous sections for (a) mapping and detecting individual classes such as plantations; (b) a class by class land cover mapping approach.</p>
<div id="anomaly-based-plantation-detection" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Anomaly-based plantation detection</h3>
<p>Spectral confusion between planted tree crops with native vegetation is a well-known challenge in using moderate resolution optical remote sensing data for mapping plantations. Cultivated land in Liberia primarily consists of woody commodity crops (oil palm and rubber trees). Even with the availability of forest concessions datasets to constrain the classification of these crops, the Random Forest relies on spectral predictors that are almost identical to native vegetation. Aditionally, small scale plantations intermixed with evergreen forest will also add to the challenges of separating these classes. However, areas of plantation usually undergo harvesting cycles, which creates a temporal signature that is different than evergreen natural vegetation: every few years, the spectral signature of these areas will show traces of bare soil due to harvesting and replanting. We can take advantage of this interannual differences by doing an <strong>anomaly analysis</strong>. By definition, anomaly is anything that deviates from what is standard, normal, or expected. Usually, anomalies are calculated by subtracting a long-term average of a variable from the actual value of that variable at a given time. For example, if X = actual value of average NDVI for vegetation in 2020, and Y = long-term average NDVI of vegetation (an average over many years), then the anomaly = X − Y. If the anomaly values are zero (or very close to zero), it means that NDVI remained relatively stable in that period, which indicates that there has not been any significant disturbance in that area. On the other hand, a positive anomaly means that the NDVI signal is greater than its long-term average, which indicates that vegetation has shown growth in that area; similarly, a negative anomaly means that the NDVI signal is weaker than its long-term average, indicating a potential loss in the area.</p>
<p>This is a very useful tool to detect changes over time. Depending on where and how these changes happen over time, you can then conclude that that area is being planted and harvested.</p>
<p>Next, we will provide several blocks of code to perform a quick anomaly analysis over Liberia and potentially identifying areas of plantation.</p>
<ul>
<li>Harmonizing Landsat 5/7/8 Image Collections</li>
</ul>
<p>The Landsat TM/ETM+ and OLI sensors present differences between their spectral characteristics. Thus, to ensure inter-sensor harmonized spectral information and temporal continuity, we will harmonize the entire Landsat image archive using the statistical functions presented in Roy et al. (2016). For that, we will start by defining the temporal parameters for the harmonization:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var startYear =<span class="st"> </span><span class="dv">1984</span>;    
var endyear   =<span class="st"> </span><span class="dv">2021</span>;   
var startDay  =<span class="st"> &#39;01-01&#39;</span>;
var endDay    =<span class="st"> &#39;12-31&#39;</span>;</code></pre></div>
<p>Here we used the entire Landsat archive. Next, we will create several functions for the harmonization of the Landsat archive:</p>
<p><strong>Harmonization Function</strong>: <code>harmonizationRoy</code> uses the regression coefficients (slopes and intercepts) retrieved from Roy et al. (2016) and performs a linear transformation of ETM+ spectral space to OLI spectral space:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var harmonizationRoy =<span class="st"> </span><span class="cf">function</span>(oli) {
var slopes =<span class="st"> </span><span class="kw">ee.Image.constant</span>([<span class="fl">0.9785</span>, <span class="fl">0.9542</span>, <span class="fl">0.9825</span>, <span class="fl">1.0073</span>, <span class="fl">1.0171</span>, <span class="fl">0.9949</span>]);        
var itcp =<span class="st"> </span><span class="kw">ee.Image.constant</span>([<span class="op">-</span><span class="fl">0.0095</span>, <span class="op">-</span><span class="fl">0.0016</span>, <span class="op">-</span><span class="fl">0.0022</span>, <span class="op">-</span><span class="fl">0.0021</span>, <span class="op">-</span><span class="fl">0.0030</span>, <span class="fl">0.0029</span>]);     
var y =<span class="st"> </span><span class="kw">oli.select</span>([<span class="st">&#39;B2&#39;</span>,<span class="st">&#39;B3&#39;</span>,<span class="st">&#39;B4&#39;</span>,<span class="st">&#39;B5&#39;</span>,<span class="st">&#39;B6&#39;</span>,<span class="st">&#39;B7&#39;</span>],[<span class="st">&#39;B1&#39;</span>, <span class="st">&#39;B2&#39;</span>, <span class="st">&#39;B3&#39;</span>, <span class="st">&#39;B4&#39;</span>, <span class="st">&#39;B5&#39;</span>, <span class="st">&#39;B7&#39;</span>]) 
            <span class="kw">.resample</span>(<span class="st">&#39;bicubic&#39;</span>)                                                         
            <span class="kw">.subtract</span>(<span class="kw">itcp.multiply</span>(<span class="dv">10000</span>))<span class="kw">.divide</span>(slopes)                                
            <span class="kw">.set</span>(<span class="st">&#39;system:time_start&#39;</span>, <span class="kw">oli.get</span>(<span class="st">&#39;system:time_start&#39;</span>));
return <span class="kw">y.toShort</span>();                                                                       
};</code></pre></div>
<p><strong>Retrieve a Particular Sensor Function</strong>: <code>getSRcollection</code> will be used to retrieve individual sensor collections based on the temporal parameters and the harmonization function above. Additionally, this function will mask cloud, cloud shadow, and snow based on the Landsat quality assessment bands:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var getSRcollection =<span class="st"> </span><span class="cf">function</span>(year, startDay, endYear, endDay, sensor) {
    var srCollection =<span class="st"> </span><span class="kw">ee.ImageCollection</span>(<span class="st">&#39;LANDSAT/&#39;</span><span class="op">+</span><span class="st"> </span>sensor <span class="op">+</span><span class="st"> &#39;/C01/T1_SR&#39;</span>)
                                         <span class="kw">.filterDate</span>(year<span class="op">+</span><span class="st">&#39;-&#39;</span><span class="op">+</span>startDay, endYear<span class="op">+</span><span class="st">&#39;-&#39;</span><span class="op">+</span>endDay);
        srCollection =<span class="st"> </span><span class="kw">srCollection.map</span>(<span class="cf">function</span>(img) {
          var dat =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="kw">ee.Algorithms.If</span>(
                    sensor <span class="op">==</span><span class="st"> &#39;LC08&#39;</span>,                                                  
                    <span class="kw">harmonizationRoy</span>(<span class="kw">img.unmask</span>()),                                    
                    <span class="kw">img.select</span>([<span class="st">&#39;B1&#39;</span>, <span class="st">&#39;B2&#39;</span>, <span class="st">&#39;B3&#39;</span>, <span class="st">&#39;B4&#39;</span>, <span class="st">&#39;B5&#39;</span>, <span class="st">&#39;B7&#39;</span>])
                       <span class="kw">.unmask</span>()  
                       <span class="kw">.resample</span>(<span class="st">&#39;bicubic&#39;</span>)
                       <span class="kw">.set</span>(<span class="st">&#39;system:time_start&#39;</span>, <span class="kw">img.get</span>(<span class="st">&#39;system:time_start&#39;</span>))
                  )
                );
    <span class="op">/</span><span class="er">/</span><span class="st"> </span>Cloud, cloud shadow and snow mask
    var qa =<span class="st"> </span><span class="kw">img.select</span>(<span class="st">&#39;pixel_qa&#39;</span>);                                       
      var mask =<span class="st"> </span><span class="kw">qa.bitwiseAnd</span>(<span class="dv">8</span>)<span class="kw">.eq</span>(<span class="dv">0</span>)<span class="kw">.and</span>(
                 <span class="kw">qa.bitwiseAnd</span>(<span class="dv">16</span>)<span class="kw">.eq</span>(<span class="dv">0</span>))<span class="kw">.and</span>(
                 <span class="kw">qa.bitwiseAnd</span>(<span class="dv">32</span>)<span class="kw">.eq</span>(<span class="dv">0</span>));
      return <span class="kw">dat.mask</span>(mask); 
      });
return srCollection;
};</code></pre></div>
<p><strong>Combining the Collections Function</strong>: <code>getCombinedSRcollection</code> will merge all the individual L5/L7/L8 collections into one:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var getCombinedSRcollection =<span class="st"> </span><span class="cf">function</span>(year, startDay, endYear,endDay) {
  var lt5 =<span class="st"> </span><span class="kw">getSRcollection</span>(year, startDay, endYear, endDay, <span class="st">&#39;LT05&#39;</span>);
  var le7 =<span class="st"> </span><span class="kw">getSRcollection</span>(year, startDay, endYear, endDay, <span class="st">&#39;LE07&#39;</span>);
  var lc8 =<span class="st"> </span><span class="kw">getSRcollection</span>(year, startDay, endYear, endDay, <span class="st">&#39;LC08&#39;</span>);
  var mergedCollection =<span class="st"> </span><span class="kw">ee.ImageCollection</span>(<span class="kw">le7.merge</span>(lc8)<span class="kw">.merge</span>(lt5));
return mergedCollection;
};</code></pre></div>
<p><strong>Vegetation Indices</strong>: <code>addIndices</code> calculates several vegetation/spectral indices based on the harmonized Landsat bands. In this example, we are including the Normalized Difference Vegetation Index (NDVI), the Enhanced Vegetation Index (EVI), the Soil Adjusted Vegetation Index (SAVI), the Normalized Difference Mangrove Index (NDMI), the Normalized Difference Water index (NDWI), the Modified Normalized Difference Water Index (MNDWI) and many others. Here is where you can include your own vegetation indices:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var addIndices =<span class="st"> </span><span class="cf">function</span>(image) {
  var ndvi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;B4&#39;</span>, <span class="st">&#39;B3&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NDVI&#39;</span>);
  var evi =<span class="st"> </span><span class="kw">image.expression</span>(
      <span class="st">&#39;2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))&#39;</span>, {
      <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;B4&#39;</span>),
      <span class="st">&#39;RED&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;B3&#39;</span>),
      <span class="st">&#39;BLUE&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;B1&#39;</span>)
})<span class="kw">.rename</span>(<span class="st">&#39;EVI&#39;</span>);
  var savi =<span class="st"> </span><span class="kw">image.expression</span>(
      <span class="st">&#39;((NIR - RED) / (NIR + RED + 0.5) * (0.5 + 1))&#39;</span>, {
      <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;B4&#39;</span>),
      <span class="st">&#39;RED&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;B3&#39;</span>),
      <span class="st">&#39;BLUE&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;B1&#39;</span>)
})<span class="kw">.rename</span>(<span class="st">&#39;SAVI&#39;</span>);
  var ndmi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;B7&#39;</span>,<span class="st">&#39;B2&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NDMI&#39;</span>);
  var nbr =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;B4&#39;</span>, <span class="st">&#39;B7&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NBR&#39;</span>);
  var ndwi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;B5&#39;</span>,<span class="st">&#39;B4&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NDWI&#39;</span>);
  var mndwi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;B2&#39;</span>,<span class="st">&#39;B5&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;MNDWI&#39;</span>);
return <span class="kw">image.addBands</span>(ndvi)
            <span class="kw">.addBands</span>(evi)
            <span class="kw">.addBands</span>(savi)
            <span class="kw">.addBands</span>(ndmi)
            <span class="kw">.addBands</span>(nbr)
            <span class="kw">.addBands</span>(ndwi)
            <span class="kw">.addBands</span>(mndwi);
};</code></pre></div>
<p>Finally, <code>collectionL5L7L8</code> will include the final harmonized collection with all the sensors based on the temporal parameters defined previously, with all spectral bands and vegetation/spectral indices, filtered to include only scenes over Liberia:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var aoi =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/LiberiaCounties&#39;</span>);
var collectionL5L7L8 =<span class="st"> </span><span class="kw">getCombinedSRcollection</span>(startYear, startDay,
    endyear, endDay)<span class="kw">.map</span>(addIndices)<span class="kw">.filterBounds</span>(aoi);</code></pre></div>
<p><a href="https://code.earthengine.google.com/2b0953555f853f377200d7ed8d3954a4" target="_blank">Code Checkpoint</a></p>
<ul>
<li>Vegetation Index Anomaly</li>
</ul>
<p>To calculate the anomaly, we will start by defining the index we want to compute the anomaly for and the reference period to get the average value of that index over time. In this example, we will use the Normalized Burn Ratio (NBR) index, which is useful to highligh burned / bare areas and</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var index =<span class="st"> &#39;NBR&#39;</span>;
var ref_start =<span class="st"> &#39;1985-01-01&#39;</span>;
var ref_end =<span class="st"> &#39;2010-12-31&#39;</span>;</code></pre></div>
<p>Next, we will create the reference collection using <code>collectionL5L7L8</code> and the parameters above. You can print the size of this reference collection to the console using <code>print()</code> and <code>.size()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var reference =<span class="st"> </span>collectionL5L7L8
    <span class="kw">.filterDate</span>(ref_start, ref_end)
    <span class="kw">.select</span>(index)
    <span class="kw">.sort</span>(<span class="st">&#39;system:time_start&#39;</span>, true);
    
<span class="kw">print</span>(<span class="st">&#39;Number of images in Reference Collection&#39;</span>, <span class="kw">reference.size</span>());</code></pre></div>
<div class="figure"><span id="fig:PartIII-ReferenceColSize"></span>
<img src="images/PartIII-ReferenceColSize.png" alt="Number of scenes in the reference collection that will be used to calculate the reference value for the anomaly." width="781" />
<p class="caption">
Figure 3.11: Number of scenes in the reference collection that will be used to calculate the reference value for the anomaly.
</p>
</div>
<p>We can now calculate the mean value (and other statistics) for the reference collection reference using the <code>.median()</code> and <code>.mean()</code> methods:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var mean =<span class="st"> </span><span class="kw">reference.mean</span>()<span class="kw">.clip</span>(aoi);
var median =<span class="st"> </span><span class="kw">reference.median</span>()<span class="kw">.clip</span>(aoi);</code></pre></div>
<p>Now that we have the long-term reference metrics, we can define the period for which you want to compute the the anomaly. In this example, we will use yearly intervals starting in 2016 until 2020. We are interested to see where we can observe cycles of planting and harvesting for plantations in Liberia. However, any combination of years is possible depending on what period you are interested in. Then, an anomaly function can be created to subtract the metric from the average of your period of interest:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var period_start =<span class="st"> &#39;2016-01-01&#39;</span>;
var period_end =<span class="st">  &#39;2016-12-30&#39;</span>;

var anomalyFunction =<span class="st"> </span><span class="cf">function</span>(image){
              return <span class="kw">image.subtract</span>(median)
              <span class="kw">.set</span>(<span class="st">&#39;system:time_start&#39;</span>, 
              <span class="kw">image.get</span>(<span class="st">&#39;system:time_start&#39;</span>))};</code></pre></div>
<p>Finally, we will map the <code>anomalyFunction</code> to the Landsat collection <code>collectionL5L7L8</code> filtered by the <code>period_start</code> and <code>period_end</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var series =<span class="st"> </span><span class="kw">collectionL5L7L8.filterDate</span>(period_start, period_end)<span class="kw">.map</span>(anomalyFunction);</code></pre></div>
<p>The object <code>series</code> will have all the spectral bands and vegetation/spectral indices for the time period defined above. Their values, however, will be different from the original collection since we subtracted the average value of the reference period. The next step is to sum all the values for the index from series and divide by the number of images available. You can achieve that by using the <code>.sum()</code> and <code>.count()</code> methods:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var seriesSum =<span class="st"> </span><span class="kw">series.select</span>(index)<span class="kw">.sum</span>();
var numImages =<span class="st"> </span><span class="kw">series.select</span>(index)<span class="kw">.count</span>();
var anomaly =<span class="st"> </span><span class="kw">seriesSum.divide</span>(numImages);</code></pre></div>
<p>So far, the steps we have taken were:</p>
<ul>
<li>Created a reference value (median) for the NBR index for the 1985-2010 period;</li>
<li>Then subtracted this median value from every scene in the period of interest (year 2016)</li>
<li>Averaged the anomaly values for that year by adding all values and dividing by the number of observations (images within that period).</li>
</ul>
<p>We can add the object <code>anomaly</code> to the Map Editor using a color ramp:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var visAnom =<span class="st"> </span>{
    min<span class="op">:</span><span class="st"> </span><span class="op">-</span><span class="fl">0.20</span>,
    max<span class="op">:</span><span class="st"> </span><span class="fl">0.20</span>,
    palette<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;#481567FF&#39;</span>, <span class="st">&#39;#482677FF&#39;</span>, <span class="st">&#39;#453781FF&#39;</span>, <span class="st">&#39;#404788FF&#39;</span>,
              <span class="st">&#39;#39568CFF&#39;</span>, <span class="st">&#39;#33638DFF&#39;</span>, <span class="st">&#39;#2D708EFF&#39;</span>, <span class="st">&#39;#287D8EFF&#39;</span>,<span class="st">&#39;#238A8DFF&#39;</span>,
              <span class="st">&#39;#1F968BFF&#39;</span>, <span class="st">&#39;#20A387FF&#39;</span>, <span class="st">&#39;#29AF7FFF&#39;</span>, <span class="st">&#39;#3CBB75FF&#39;</span>,<span class="st">&#39;#55C667FF&#39;</span>,
              <span class="st">&#39;#73D055FF&#39;</span>, <span class="st">&#39;#95D840FF&#39;</span>, <span class="st">&#39;#B8DE29FF&#39;</span>, <span class="st">&#39;#DCE319FF&#39;</span>,<span class="st">&#39;#FDE725FF&#39;</span> ]
};
<span class="kw">Map.addLayer</span>(anomaly, visAnom, index <span class="op">+</span><span class="st"> &#39; anomaly&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:Anomally"></span>
<img src="images/PartIII-Anomally.png" alt="Normalized Burn Ratio (NBR) index anomaly over Liberia. Areas of negative anomaly are shown in purple/dark blue." width="1194" />
<p class="caption">
Figure 3.12: Normalized Burn Ratio (NBR) index anomaly over Liberia. Areas of negative anomaly are shown in purple/dark blue.
</p>
</div>
<p>A negative anomaly (in purple in the figure above) means that the NBR signal in 2016 is weaker than its long-term average, indicating a potential loss in the area for that year. Notice that in some areas you can see regular shapes, which means that those losses are potential harvested plantation. On the other hand, positive anomaly (in yellow) will show areas where soil is no longer exposed, giving us an indication of potential areas being replanted.</p>
<div class="caution">
<p>
<strong>Not every negative anomaly will be harvesting of planted areas nor every positive anomaly will be areas being replanted. The anomaly can give us an indication of where these areas MAY be, based on the pattern observed</strong>.
</p>
</div>
<p>Investigate the following years by changing the values for <code>period_start</code> and <code>period_end</code>. By doing so, we can have an informed idea where these planted areas are, which would be rather challenging to detected using only the Landsat composite.</p>
<p>We will export each anomaly individually. For that, change the values for <code>period_start</code> and <code>period_end</code> for the year 2016 and use the code below to export the anomaly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>anomaly,
  description<span class="op">:</span><span class="st"> &#39;Anomaly2016&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;Anomaly2016&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  region<span class="op">:</span><span class="st"> </span>aoi,
  });</code></pre></div>
<p>Repeat the process for 2017, 2018, 2019 and 2020.</p>
<p><strong>* Planted areas</strong></p>
<p>On a <a href="https://code.earthengine.google.com/" target="_blank">new Code Editor page</a>, import the anomalies to the script.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var nbr16 =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/celiohelder/Liberia/NBR_Anomaly2016&#39;</span>);
var nbr17 =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/celiohelder/Liberia/NBR_Anomaly2017&#39;</span>);
var nbr18 =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/celiohelder/Liberia/NBR_Anomaly2018&#39;</span>);
var nbr19 =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/celiohelder/Liberia/NBR_Anomaly2019&#39;</span>);
var nbr20 =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/celiohelder/Liberia/NBR_Anomaly2020&#39;</span>);</code></pre></div>
<p>As mentioned previously, not every negative anomaly will be harvesting of planted areas nor every positive anomaly will be areas being replanted. The anomaly can give us an indication of where these areas may be, based on the pattern observed. We can also focus on concessions. A concession is a license, permit, or other contract that gives private companies the rights to establish a plantation on public land. Here we will also focus on areas of Rubber and Oil Palm Concessions. The data was previously uploaded into GEE and you can have access to it by loading it into your script with <code>ee.FeatureCollection('users/capacityBuilding/Liberia/Rubber')</code> and <code>ee.FeatureCollection('users/capacityBuilding/Liberia/OilPalm')</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var rubber =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/Rubber&#39;</span>);
var oilpalm =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/OilPalm&#39;</span>);
var concessions =<span class="st"> </span><span class="kw">rubber.merge</span>(oilpalm);</code></pre></div>
<p>Add the anomalies and the concessions data to the <strong>Map Editor</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var visAnom =<span class="st"> </span>{
    min<span class="op">:</span><span class="st"> </span><span class="op">-</span><span class="fl">0.20</span>,
    max<span class="op">:</span><span class="st"> </span><span class="fl">0.20</span>,
    palette<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;#481567FF&#39;</span>, <span class="st">&#39;#482677FF&#39;</span>, <span class="st">&#39;#453781FF&#39;</span>, <span class="st">&#39;#404788FF&#39;</span>,
              <span class="st">&#39;#39568CFF&#39;</span>, <span class="st">&#39;#33638DFF&#39;</span>, <span class="st">&#39;#2D708EFF&#39;</span>, <span class="st">&#39;#287D8EFF&#39;</span>,<span class="st">&#39;#238A8DFF&#39;</span>,
              <span class="st">&#39;#1F968BFF&#39;</span>, <span class="st">&#39;#20A387FF&#39;</span>, <span class="st">&#39;#29AF7FFF&#39;</span>, <span class="st">&#39;#3CBB75FF&#39;</span>,<span class="st">&#39;#55C667FF&#39;</span>,
              <span class="st">&#39;#73D055FF&#39;</span>, <span class="st">&#39;#95D840FF&#39;</span>, <span class="st">&#39;#B8DE29FF&#39;</span>, <span class="st">&#39;#DCE319FF&#39;</span>,<span class="st">&#39;#FDE725FF&#39;</span> ]
};

<span class="kw">Map.addLayer</span>(nbr16,visAnom, <span class="st">&#39;NBR anomaly 2016&#39;</span>);
<span class="kw">Map.addLayer</span>(nbr17,visAnom, <span class="st">&#39;NBR anomaly 2017&#39;</span>);
<span class="kw">Map.addLayer</span>(nbr18,visAnom, <span class="st">&#39;NBR anomaly 2018&#39;</span>);
<span class="kw">Map.addLayer</span>(nbr19,visAnom, <span class="st">&#39;NBR anomaly 2019&#39;</span>);
<span class="kw">Map.addLayer</span>(nbr20,visAnom, <span class="st">&#39;NBR anomaly 2020&#39;</span>);

<span class="kw">Map.addLayer</span>(<span class="kw">ee.Image</span>()<span class="kw">.paint</span>(oilpalm, <span class="dv">0</span>, <span class="dv">2</span>), {palette<span class="op">:</span>[<span class="st">&#39;black&#39;</span>]}, <span class="st">&#39;OilPalm&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">ee.Image</span>()<span class="kw">.paint</span>(rubber, <span class="dv">0</span>, <span class="dv">2</span>), {palette<span class="op">:</span>[<span class="st">&#39;purple&#39;</span>]}, <span class="st">&#39;Rubber&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-Anomally2"></span>
<img src="images/PartIII-Anomally2.png" alt="2016 NBR Anomaly and the oil palm and rubber plantation concessions." width="856" />
<p class="caption">
Figure 3.13: 2016 NBR Anomaly and the oil palm and rubber plantation concessions.
</p>
</div>
<p>Note that even before the addition of the concession dataset, we could outline potential areas of plantation based on the anomaly values. Now, overlaying these concessions borders with the anomaly layer, we have strong evidence that those are indeed planted areas.</p>
<p>Due to their distinct anomaly values compare do their surrounding classes and their distinct pattern (particularly in the area within the concessions), we are able to separate them with value threshold. Using the <strong>Inspector</strong> tab, investigate the anomaly values for the dark blue/purple (negative anomaly) and the yellow (positive anomaly) areas. Upon close inspection, we concluded lower values than -0.1 can capture the areas of losses; on the other hand, values greater than 0.1 capture the areas of gains.</p>
<p>We can apply the conditionals <code>.lte()</code> and <code>.gt()</code> to the NBR Anomaly layers to extract these areas:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var lossanomaly1617 =<span class="st"> </span><span class="kw">nbr16.lt</span>(<span class="op">-</span><span class="fl">0.10</span>);
var gainanomaly1617 =<span class="st"> </span><span class="kw">nbr16.gt</span>(<span class="fl">0.10</span>);

var lossanomaly1718 =<span class="st"> </span><span class="kw">nbr17.lt</span>(<span class="op">-</span><span class="fl">0.10</span>);
var gainanomaly1718 =<span class="st"> </span><span class="kw">nbr17.gt</span>(<span class="fl">0.10</span>);

var lossanomaly1819 =<span class="st"> </span><span class="kw">nbr18.lt</span>(<span class="op">-</span><span class="fl">0.10</span>);
var gainanomaly1819 =<span class="st"> </span><span class="kw">nbr18.gt</span>(<span class="fl">0.10</span>);

var lossanomaly1920 =<span class="st"> </span><span class="kw">nbr19.lt</span>(<span class="op">-</span><span class="fl">0.10</span>);
var gainanomaly1920 =<span class="st"> </span><span class="kw">nbr19.gt</span>(<span class="fl">0.10</span>);

var lossanomaly2021 =<span class="st"> </span><span class="kw">nbr20.lt</span>(<span class="op">-</span><span class="fl">0.10</span>);
var gainanomaly2021 =<span class="st"> </span><span class="kw">nbr20.gt</span>(<span class="fl">0.10</span>);

<span class="kw">Map.addLayer</span>(<span class="kw">lossanomaly1617.selfMask</span>(), {palette<span class="op">:</span><span class="st">&#39;F94C66&#39;</span>}, <span class="st">&#39;LossNBRanomaly2016-2017&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">gainanomaly1617.selfMask</span>(), {palette<span class="op">:</span><span class="st">&#39;F7EC09&#39;</span>}, <span class="st">&#39;GainNBRanomaly2016-2017&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-AnomallyPlantation"></span>
<img src="images/PartIII-AnomallyPlantation.png" alt="Areas of losses/harvest and gains/planting based on threshold values of NBR anomaly." width="1321" />
<p class="caption">
Figure 3.14: Areas of losses/harvest and gains/planting based on threshold values of NBR anomaly.
</p>
</div>
<p>By stacking 2016, 2017, 2018, 2019 and 2020 losses and gains and using the concession datasets as a constraint, we can create a Plantation layer for Liberia. We can construct this layer in a way to include the years where harvest and planting was observed. To do so, we will add the layers together. However, we have to set a flag value to each year. The steps below presents a simplistic way to create this flag:</p>
<p>First, we will multiply each loss and gains layer by 10000,1000,100,10 and 1:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var loss16 =<span class="st"> </span><span class="kw">lossanomaly1617.multiply</span>(<span class="dv">10000</span>);
var loss17 =<span class="st"> </span><span class="kw">lossanomaly1718.multiply</span>(<span class="dv">1000</span>);
var loss18 =<span class="st"> </span><span class="kw">lossanomaly1819.multiply</span>(<span class="dv">100</span>);
var loss19 =<span class="st"> </span><span class="kw">lossanomaly1920.multiply</span>(<span class="dv">10</span>);
var loss20 =<span class="st"> </span><span class="kw">lossanomaly2021.multiply</span>(<span class="dv">1</span>);</code></pre></div>
<p>Now, we can stack these layers using <code>.add()</code>. The result will be a layer with values raging from 1 to 11111, where the position of the digit represents the year and the value 0 and 1 represent absence and presence, respectively. For example, a pixel with value of 10110 in this flag will mean that losses/harvest derived from the negative anomaly were observed in 2016, not in 2017, in 2018 and in 2019 and not in 2020.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var lossFlag =<span class="st"> </span><span class="kw">loss16.add</span>(loss17)
                     <span class="kw">.add</span>(loss18)
                     <span class="kw">.add</span>(loss19)
                     <span class="kw">.add</span>(loss20);</code></pre></div>
<p>Similarly, we can create a gains flag:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var gain16 =<span class="st"> </span><span class="kw">gainanomaly1617.multiply</span>(<span class="dv">10000</span>);
var gain17 =<span class="st"> </span><span class="kw">gainanomaly1718.multiply</span>(<span class="dv">1000</span>);
var gain18 =<span class="st"> </span><span class="kw">gainanomaly1819.multiply</span>(<span class="dv">100</span>);
var gain19 =<span class="st"> </span><span class="kw">gainanomaly1920.multiply</span>(<span class="dv">10</span>);
var gain20 =<span class="st"> </span><span class="kw">gainanomaly2021.multiply</span>(<span class="dv">1</span>);

var recoveryFlag =<span class="st"> </span><span class="kw">gain16.add</span>(gain17)
                     <span class="kw">.add</span>(gain18)
                     <span class="kw">.add</span>(gain19)
                     <span class="kw">.add</span>(gain20);</code></pre></div>
<p>Several information can be inferred based on the combination of years and each individual flag. For example, one can decide that a plantation class will be anything that shows clearing in one year and recovery in the next; or, two consecutive years of exposed soil followed by 3 years of recovery. Also, extending the anomaly analysis to years prior to 2015, increasing the study period. Thus, it is up to the user to come up to a rule to define the final plantation layer. Finally, as you may have noticed, this technique can also be used to inspect changes elsewhere, chief among them <strong>areas of native vegetation that has been cleared</strong>. This is a very versitile analysis that can provide very useful information about vegetation change.</p>
<p>Export these flags (<code>lossFlag</code> and <code>recoveryFlag</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>recoveryFlag,
  description<span class="op">:</span><span class="st"> &#39;RecoveryFlag&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;RecoveryFlag&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  });</code></pre></div>
<p><a href="https://code.earthengine.google.com/1cf253a5bdd30568fd693f89076f11a0" target="_blanket">Code Checkpoint</a></p>
<hr />
</div>
<div id="class-by-class-land-cover-mapping" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Class-by-class land cover mapping</h3>
<p>We will start by <a href="https://code.earthengine.google.com/" target="_blank">opening a new code editor page</a> and by defining the spatial and temporal parameters of the composite you wish to classify, just like the other examples. As explained in Part 1, GEE’s cloud screening algorithm based on quality assessment bands (QA) can be applied to remove cloud and cloud shadow contaminated pixels for each of the Landsat scene covering y. This method greatly improves the final composite (See <a href="part-2-advanced-google-earth-engine.html#fig:CompositesMasked">2.2</a>). However, creating an annual <em>completely cloud-free</em> imagery composition for Liberia is a challenging task because of the west African monsoon, which causes constant clouds across the Gulf of Guinea most of the time. The rainy season in Liberia ranges from May to October and it frequently rains in other months, except in the short dry season that runs from December to February/March. Hence, <strong>multi-year composites are necessary in attaining wall-to-wall cloud-free mosaics over Liberia</strong>.</p>
<p>In order to ensure that an adequate cloud-free composite is achieved, we will use a composite circa 2021-2022. Then the temporal parameters can be defined as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var year =<span class="st"> </span><span class="dv">2021</span>;
var startDay =<span class="st"> </span>(year)<span class="op">+</span><span class="st">&#39;-01-01&#39;</span>;
var endDay =<span class="st"> </span>(year<span class="op">+</span><span class="dv">1</span>)<span class="op">+</span><span class="st">&#39;-05-30&#39;</span>;</code></pre></div>
<p>Note that this time range will include all available Landsat 8 Surface Reflectance images from January 2021 through May 2022 (<code>year+1</code>).</p>
<p>For the spatial parameters, we can use the <em>Large Scale International Boundary (LSIB)</em> dataset and select Liberia’s national border. First, we will load the dataset into an object called 'countries' using the <code>ee.FeatureCollection()</code> object and the feature collection ID 'USDOS/LSIB/2013'. Secondly, we will filter the dataset using <code>.filterMetadata()</code> and select Liberia from the list of countries and storing it in <code>nationalBorder</code>:</p>
<div class="rmdcomment">
<p>
Note that you can select a any country border by filtering <em>'USDOS/LSIB/2013'</em> dataset by using <em>.filterMetadata('name' , 'equals', 'NAME OF THE COUNTRY IN CAPITAL LETTERS')</em>.
</p>
</div>
<p>If you want to visualize your feature collection, you can add it to the map using the <code>Map.addLayer()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var countries =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;USDOS/LSIB/2013&#39;</span>);
var nationalBorder =<span class="st"> </span><span class="kw">countries.filterMetadata</span>(<span class="st">&#39;name&#39;</span> , <span class="st">&#39;equals&#39;</span>, <span class="st">&#39;LIBERIA&#39;</span>);
<span class="kw">Map.centerObject</span>(nationalBorder);
<span class="kw">Map.addLayer</span>(nationalBorder, {color<span class="op">:</span><span class="st"> &#39;Blue&#39;</span>}, <span class="st">&#39;Liberia National Borders&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:LiberiaBorder"></span>
<img src="images/PartIII-LiberiaBorder.png" alt="Liberia border extracted from the *Large Scale International Boundary (LSIB)* dataset." width="857" />
<p class="caption">
Figure 3.15: Liberia border extracted from the <em>Large Scale International Boundary (LSIB)</em> dataset.
</p>
</div>
<p>Alternatively, you can import your own border shapefile to your assets using the <strong>NEW</strong> button in the <strong>Assets</strong> tab. (See Earth Engine's <a href="https://developers.google.com/earth-engine/guides/image_upload" target="_blank">Importing Raster Data</a> for instructions on uploading an image to your assets or <a href="https://developers.google.com/earth-engine/guides/table_upload" target="_blank">Importing Table/Shapefile Data</a> for more details).</p>
<p>In this example, we imported a shapefile containing all of Liberia's counties to our assets:</p>
<div class="figure"><span id="fig:ImportingShapefile"></span>
<img src="images/PartIII-ImportingShapefile.png" alt="Importing shapefiles to your assets." width="340" />
<p class="caption">
Figure 3.16: Importing shapefiles to your assets.
</p>
</div>
<p>Once the upload is completed, the imported dataset can be accessed in the <strong>Assets</strong> tab. We will import it to the script using its 'ID' and add to the map editor:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var aoi =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/LiberiaCounties&#39;</span>);
<span class="kw">Map.addLayer</span>(aoi, {color<span class="op">:</span><span class="st"> &#39;red&#39;</span>}, <span class="st">&#39;LiberiaCounties&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:Counties"></span>
<img src="images/PartIII-Counties.png" alt="`aoi` and its multiple features (counties)" width="856" />
<p class="caption">
Figure 3.17: <code>aoi</code> and its multiple features (counties)
</p>
</div>
<p>In this particular case, this dataset includes multiple features (or polygons) with several properties for each feature. One of them is called 'NAME_1', which includes the names of each county in Liberia:</p>
<div class="figure"><span id="fig:AssetDetail"></span>
<img src="images/PartIII-AssetDetail.png" alt="Asset information. This imported dataset includes multiple features." width="886" />
<p class="caption">
Figure 3.18: Asset information. This imported dataset includes multiple features.
</p>
</div>
<p>You can also print <code>aoi</code> to the <strong>Console</strong> tab:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(aoi);</code></pre></div>
<div class="figure"><span id="fig:FCProperties"></span>
<img src="images/PartIII-FCProperties.png" alt="Feature collection information printed to the console. This imported dataset includes multiple features." width="683" />
<p class="caption">
Figure 3.19: Feature collection information printed to the console. This imported dataset includes multiple features.
</p>
</div>
<p>This type of metadata can be used to filter a feature collection. The <code>ee.Filter.inList()</code> method is very helpful when you want to filter multiple properties at once. First, we will create an object called 'filterCounties' with a list of 4 of the 15 counties in Liberia. In this example, we selected the counties of Bomi, Montserrado, Margibi and Grand Bassa. Finally, we use <code>filter()</code> to filter <code>aoi</code> for the list of counties provided in <code>filterCounties</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var filterCounties =<span class="st"> </span><span class="kw">ee.Filter.inList</span>(<span class="st">&#39;NAME_1&#39;</span>, [<span class="st">&#39;Bomi&#39;</span>, <span class="st">&#39;Montserrado&#39;</span>,<span class="st">&#39;Margibi&#39;</span>,<span class="st">&#39;GrandBassa&#39;</span>]);
var filteredAOI =<span class="st"> </span><span class="kw">aoi.filter</span>(filterCounties);
<span class="kw">Map.addLayer</span>(filteredAOI, {color<span class="op">:</span><span class="st"> &#39;green&#39;</span>}, <span class="st">&#39;filteredArea&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:FilteredCounties"></span>
<img src="images/PartIII-FilteredCounties.png" alt="The `aoi` feature collection filtered by metadata. Here, a filter to select the counties of Bomi, Montserrado, Margibi and Grand Bassa was used. " width="856" />
<p class="caption">
Figure 3.20: The <code>aoi</code> feature collection filtered by metadata. Here, a filter to select the counties of Bomi, Montserrado, Margibi and Grand Bassa was used.
</p>
</div>
<p>Now that both temporal and spatial parameters are defined, As auxiliary functions for cloud masking and spectral index calculation, we will use the same functions provided in PART 2:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">function</span> <span class="kw">maskClouds</span>(image) {
  var cloudShadowBitMask =<span class="st"> </span><span class="kw">ee.Number</span>(<span class="dv">2</span>)<span class="kw">.pow</span>(<span class="dv">3</span>)<span class="kw">.int</span>();
  var cloudsBitMask =<span class="st"> </span><span class="kw">ee.Number</span>(<span class="dv">2</span>)<span class="kw">.pow</span>(<span class="dv">4</span>)<span class="kw">.int</span>();
  var QA =<span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;QA_PIXEL&#39;</span>);
  var mask =<span class="st"> </span><span class="kw">QA.bitwiseAnd</span>(cloudShadowBitMask)<span class="kw">.eq</span>(<span class="dv">0</span>)
      <span class="kw">.and</span>(<span class="kw">QA.bitwiseAnd</span>(cloudsBitMask)<span class="kw">.eq</span>(<span class="dv">0</span>));
  return <span class="kw">image.updateMask</span>(mask)<span class="kw">.divide</span>(<span class="dv">100000</span>)<span class="kw">.select</span>(<span class="st">&quot;SR_B[0-9]*&quot;</span>)<span class="kw">.copyProperties</span>(image, [<span class="st">&quot;system:time_start&quot;</span>]);
}

<span class="cf">function</span> <span class="kw">addIndices</span>(image) {
  var ndvi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B4&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NDVI&#39;</span>);
  var nbr =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B7&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NBR&#39;</span>);
  var ndmi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B7&#39;</span>,<span class="st">&#39;SR_B3&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;NDMI&#39;</span>);
  var mndwi =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B3&#39;</span>,<span class="st">&#39;SR_B6&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;MNDWI&#39;</span>);
  var sr =<span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>)<span class="kw">.divide</span>(<span class="kw">image.select</span>(<span class="st">&#39;SR_B4&#39;</span>))<span class="kw">.rename</span>(<span class="st">&#39;SR&#39;</span>);
  var bare =<span class="st"> </span><span class="kw">image.normalizedDifference</span>([<span class="st">&#39;SR_B6&#39;</span>,<span class="st">&#39;SR_B7&#39;</span>])<span class="kw">.rename</span>(<span class="st">&#39;BI&#39;</span>);
  var gcvi =<span class="st"> </span><span class="kw">image.expression</span>(<span class="st">&#39;(NIR/GREEN)-1&#39;</span>,{
    <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>),
    <span class="st">&#39;GREEN&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B3&#39;</span>)
  })<span class="kw">.rename</span>(<span class="st">&#39;GCVI&#39;</span>);
  var evi =<span class="st"> </span><span class="kw">image.expression</span>(
  <span class="st">&#39;2.5 * ((NIR-RED) / (NIR + 6 * RED - 7.5* SR_BLUE +1))&#39;</span>, {
    <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>),
    <span class="st">&#39;RED&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B4&#39;</span>),
    <span class="st">&#39;SR_BLUE&#39;</span><span class="op">:</span><span class="kw">image.select</span>(<span class="st">&#39;SR_B2&#39;</span>)
  })<span class="kw">.rename</span>(<span class="st">&#39;EVI&#39;</span>);
  var msavi =<span class="st"> </span><span class="kw">image.expression</span>(
  <span class="st">&#39;(2 * NIR + 1 - sqrt(pow((2 * NIR + 1), 2) - 8 * (NIR - RED)) ) / 2&#39;</span>, {
    <span class="st">&#39;NIR&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;SR_B5&#39;</span>), 
    <span class="st">&#39;RED&#39;</span><span class="op">:</span><span class="st"> </span><span class="kw">image.select</span>(<span class="st">&#39;SR_B4&#39;</span>)}
)<span class="kw">.rename</span>(<span class="st">&#39;MSAVI&#39;</span>);
    return image
    <span class="kw">.addBands</span>(ndvi)
    <span class="kw">.addBands</span>(nbr)
    <span class="kw">.addBands</span>(ndmi)
    <span class="kw">.addBands</span>(mndwi)
    <span class="kw">.addBands</span>(sr)
    <span class="kw">.addBands</span>(evi)
    <span class="kw">.addBands</span>(msavi)
    <span class="kw">.addBands</span>(gcvi)
    <span class="kw">.addBands</span>(bare);
}</code></pre></div>
<p><strong>1) Landsat 8 Image Collection and Cloud-free Mosaic</strong></p>
<p>Similarly to the examples from PART 2 and PART 3.1, we will load the Landsat 8 Surface Reflectance data archive into an object called 'collection' by using the container <code>ee.ImageCollection()</code> and the collection ID <code>'LANDSAT/LC08/C02/T1_L2'</code>. Secondly, we will filter this image collection for the temporal parameters by using the method <code>.filterDate()</code>. Finally, we will map the cloud-masking and spectral indices functions to the collection:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var collection =<span class="st"> </span><span class="kw">ee.ImageCollection</span>(<span class="st">&#39;LANDSAT/LC08/C02/T1_L2&#39;</span>)
                   <span class="kw">.filterDate</span>(startDay,endDay)
                   <span class="kw">.map</span>(maskClouds)
                   <span class="kw">.map</span>(addIndices);</code></pre></div>
<p>Then, in an object called 'composite', we will reduce the image collection into a 2021/2022 composite using the <code>.median()</code> method. Finally, we will clip the composite to our area of interest <code>filteredAOI</code> using the container <code>.clip()</code> method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var composite =<span class="st"> </span>collection
                <span class="kw">.median</span>()
                <span class="kw">.clip</span>(filteredAOI);</code></pre></div>
<p>We will add <code>composite</code> to the Map editor:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(composite, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B6&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>], min<span class="op">:</span><span class="fl">0.1</span>, max<span class="op">:</span><span class="fl">0.2</span>}, <span class="st">&#39;Composite&#39;</span>,false);</code></pre></div>
<div class="figure"><span id="fig:LiberiaComposite"></span>
<img src="images/PartIII-LiberiaComposite.png" alt="A RGB564 composition of `composite`. " width="856" />
<p class="caption">
Figure 3.21: A RGB564 composition of <code>composite</code>.
</p>
</div>
<p>Finally, we can export this composite as an asset. This will save you some time in the next steps where we will be using this same composite for classifying multiple land cover. For this example, we will use the <code>Export.image.toAsset()</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>composite,
  description<span class="op">:</span><span class="st"> &#39;CompositeLiberia2021&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;CompositeLiberia2021&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  });</code></pre></div>
<p>The code above will export the <code>composite</code> to your asset folder using the coordinate reference system (crs) and its affine. This is a necessary step to avoid a 15 meter pixel shift when using the default export parameters. Choose your folder and your asset ID anc click run:</p>
<div class="figure"><span id="fig:PartIII-CompositeExport"></span>
<img src="images/PartIII-CompositeExport.png" alt="Exporting the composite as an asset. " width="580" />
<p class="caption">
Figure 3.22: Exporting the composite as an asset.
</p>
</div>
<p><a href="https://code.earthengine.google.com/714db6d9b8c8d00fd4473ac627b7cf3b" target="_blank">Code Checkpoint</a></p>
<p><strong>2) Classification: Class-by-class</strong></p>
<p>A class-by-class classification approach will follow the steps depicted in the figure below:</p>
<div class="figure"><span id="fig:ClassificationApproach"></span>
<img src="images/PartIII-ClassByClassApproach.png" alt="A class by class classification approach. " width="900" />
<p class="caption">
Figure 3.23: A class by class classification approach.
</p>
</div>
<p>So, far we have covered a multi-class classification approach. This is the most common way to perform a classification of multiple classes: feed the classifier all the samples from the different classes and post-process the outputs. However, we can include a pre-classification step to isolate the class of interest and then perform the classification for that particular land cover. Later, we will mask this class from the composite in order to exclude those pixels from the classification process and potentially avoid comission and omission errors. Why is this relevant/important? - Answer: Pixel-based classification may generate a large number of misclassified pixels (the &quot;salt-and-pepper effect&quot;) due to the spectral diversity within the same land cover type and spectral confusion between land cover types. For that, a spectral signature analysis can be performed for identifying potential spectral bands and reflectance-based spectral indices thresholds for differentiating between two classes: the land cover class being mapped and the remaining land cover classes merged as a single class called “Other”.</p>
<p><strong><em>Water bodies</em></strong></p>
<p>Water bodies are usually the easiest class to start with. Not many other land cover classes will have a similar spectral signature. Therefore, it is good practice to start with classes that are easily classifiable. As mentioned previously, we will use a pre-classification step to isolate the class of interest and then perform the classification for that particular land cover. We can do that by using a Masking Phase (Se Figure <a href="part-3-country-specific-applications.html#fig:ClassificationApproach">3.23</a>). In this phase, we use a band/ index threshold analysis to create a mask that will remove most pixels that are unlikely to be the class of interest - in this particular case, water bodies. In this example we will use the Modified Normalized Difference Water Index (MNDWI) that was calculated and added as a separate band to the <code>composite</code> using the <code>addIndices</code> function. This index will usually have mostly positive values for wet areas and negative values for other land cover classes. Therefore we can creat a 'wetMask' using a value thresold:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var wetMask =<span class="st"> </span><span class="kw">composite.select</span>(<span class="st">&#39;MNDWI&#39;</span>)<span class="kw">.gte</span>(<span class="op">-</span><span class="fl">0.1</span>)<span class="kw">.clip</span>(filteredAOI);</code></pre></div>
<p>The code above is selecting the pixels from the band &quot;MNDWI&quot; from <code>composite</code> that has values that are equal or greater than -0.1. Automatically, <code>wetMask</code> will be an image of ones (1) where the pixels meet the criteria above (MNDWI values greater than -0.1) and zeros (0) everywhere else. You can add <code>wetMask</code> to the map to check how constrictive your threshold values are:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(<span class="kw">wetMask.selfMask</span>(), {palette<span class="op">:</span><span class="st">&#39;blue&#39;</span>}, <span class="st">&#39;WetMask&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-Watermask"></span>
<img src="images/PartIII-Watermask.png" alt="A mask created based on the MNDWI values that are equal or greater than -0.1. " width="568" />
<p class="caption">
Figure 3.24: A mask created based on the MNDWI values that are equal or greater than -0.1.
</p>
</div>
<p>Note that this mask includes all the water pixels (in black as seen in the RGB 564 color composition) plus other areas that area not open water bodies but include some level of wetness to them (usually mangroves and wetlands). The objective of this phase <em><strong>IS NOT</strong></em> to remove <em><strong>ALL</strong></em> pixels that are not water; rather, is to remove <em><strong>MOST</strong></em> pixels that are not water. You can think of this as a classification process that preceeds the actual random forest classification. Instead of having to classify the entire composite into two classes, this way you can reduce the number of pixels going into the Random Forest Classification, speeding up the process. Also, this process already eliminated pixels that are unlikely to be water, reducing even further the chances of missclassification.</p>
<p>We will use this mask to mask <code>composite</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var compositemasked =<span class="st"> </span><span class="kw">composite.mask</span>(wetMask);
<span class="kw">Map.addLayer</span>(compositemasked, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B6&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>], min<span class="op">:</span><span class="fl">0.1</span>, max<span class="op">:</span><span class="fl">0.2</span>}, <span class="st">&#39;Composite Masked&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-MaskedComposite"></span>
<img src="images/PartIII-MaskedComposite.png" alt="`composite` masked using `wetMask`. " width="853" />
<p class="caption">
Figure 3.25: <code>composite</code> masked using <code>wetMask</code>.
</p>
</div>
<p>This is the resulting Landsat composite that will be used in this first classification iteration! The next steps should be familiar to you: * Selecting training samples - here we will create the two geometries to hold the 'water' and 'other' samples. Remember to set a property called 'landcover':</p>
<div class="figure"><span id="fig:PartIII-WaterSamples"></span>
<img src="images/PartIII-WaterSamples.png" alt=" Geometry imports to hold the training samples. " width="1166" />
<p class="caption">
Figure 3.26:  Geometry imports to hold the training samples.
</p>
</div>
<p><a href="https://code.earthengine.google.com/4a32727cbaefeb2d4f60037073884618" target="_blank">Code Checkpoint</a></p>
<ul>
<li>Training a random forest classifier:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var classes =<span class="st"> </span><span class="kw">Water.merge</span>(Other);
var bands =<span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>,<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B6&#39;</span>,<span class="st">&#39;NDVI&#39;</span>,<span class="st">&#39;NBR&#39;</span>,<span class="st">&#39;MNDWI&#39;</span>,<span class="st">&#39;SR&#39;</span>,<span class="st">&#39;GCVI&#39;</span>,<span class="st">&#39;MSAVI&#39;</span>];

var samples =<span class="st"> </span><span class="kw">compositemasked.select</span>(bands)<span class="kw">.sampleRegions</span>({
  collection<span class="op">:</span><span class="st"> </span>classes,       
  properties<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;landcover&#39;</span>],
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>                  
})<span class="kw">.randomColumn</span>(<span class="st">&#39;random&#39;</span>);

var split =<span class="st"> </span><span class="fl">0.8</span>;
var training =<span class="st"> </span><span class="kw">samples.filter</span>(<span class="kw">ee.Filter.lt</span>(<span class="st">&#39;random&#39;</span>, split));
var testing =<span class="st"> </span><span class="kw">samples.filter</span>(<span class="kw">ee.Filter.gte</span>(<span class="st">&#39;random&#39;</span>, split));

<span class="kw">print</span>(<span class="st">&#39;Samples n =&#39;</span>, <span class="kw">samples.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));
<span class="kw">print</span>(<span class="st">&#39;Training n =&#39;</span>, <span class="kw">training.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));
<span class="kw">print</span>(<span class="st">&#39;Testing n =&#39;</span>, <span class="kw">testing.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));

var classifier =<span class="st"> </span><span class="kw">ee.Classifier.smileRandomForest</span>(<span class="dv">100</span>,<span class="dv">5</span>)<span class="kw">.train</span>({
  features<span class="op">:</span><span class="st"> </span>training,
  classProperty<span class="op">:</span><span class="st"> &#39;landcover&#39;</span>, 
  inputProperties<span class="op">:</span><span class="st"> </span>bands
});

var validation =<span class="st"> </span><span class="kw">testing.classify</span>(classifier);
var testAccuracy =<span class="st"> </span><span class="kw">validation.errorMatrix</span>(<span class="st">&#39;landcover&#39;</span>, <span class="st">&#39;classification&#39;</span>);

<span class="kw">print</span>(<span class="st">&#39;Validation error matrix RF: &#39;</span>, testAccuracy);
<span class="kw">print</span>(<span class="st">&#39;Validation overall accuracy RF in %: &#39;</span>, <span class="kw">testAccuracy.accuracy</span>()<span class="kw">.multiply</span>(<span class="dv">100</span>));</code></pre></div>
<ul>
<li>Classifying <code>compositemasked</code> into 'Water' and 'Others'.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var classification =<span class="st"> </span><span class="kw">compositemasked.select</span>(bands)<span class="kw">.classify</span>(classifier);

var paletteMAP =<span class="st"> </span>[
  <span class="st">&#39;#35ff17&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="kw">Other</span> (Class value <span class="dv">0</span>)
  <span class="st">&#39;#1c48d6&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="kw">Water</span> (Class value <span class="dv">1</span>)
];

<span class="kw">Map.addLayer</span> (classification, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">1</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Classification&#39;</span>);</code></pre></div>
<p>You should get something similar to this:</p>
<div class="figure"><span id="fig:PartIII-WaterClass"></span>
<img src="images/PartIII-WaterClass.png" alt=" Classification output. " width="862" />
<p class="caption">
Figure 3.27:  Classification output.
</p>
</div>
<p>Finally, we will save this output to our Assets folder using the <code>Export.image.toAsset()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>classification,
  description<span class="op">:</span><span class="st"> &#39;WaterClassification&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;1-Water&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  });</code></pre></div>
<p>This export may take several minutes. This asset will be used in the next classification to mask the composite for this class!</p>
<p><a href="https://code.earthengine.google.com/8487823c78141fce13374e5c060902e0" target="_blank">Code Checkpoint</a></p>
<p><strong><em>Mangroves</em></strong></p>
<p>Congratulations! You have classified your first land cover class! Next on the list is 'Mangroves'. This one is fairly straighforward to classify as this type of vegetation will have traces of the water spectral signature. We can use a similar index threshold approach for this class. Adittionally, we can use other datasets to mask other pixels that are unlikely to be Mangroves, such as elevation (Please refer to the Guinea section of this chapter for more information).</p>
<p>First, we will open a <a href="https://code.earthengine.google.com/" target="_blank">new Code Editor page</a> and import the Landsat composite, the feature collection of Liberia counties and the water classification:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var composite =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/CompositeLiberia2021&#39;</span>);
var aoi =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/LiberiaCounties&#39;</span>);
var filterCounties =<span class="st"> </span><span class="kw">ee.Filter.inList</span>(<span class="st">&#39;NAME_1&#39;</span>, [<span class="st">&#39;Bomi&#39;</span>, <span class="st">&#39;Montserrado&#39;</span>,<span class="st">&#39;Margibi&#39;</span>,<span class="st">&#39;GrandBassa&#39;</span>]);
var filteredAOI =<span class="st"> </span><span class="kw">aoi.filter</span>(filterCounties);
var waterClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/1-Water&#39;</span>);
<span class="kw">Map.addLayer</span>(composite, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B6&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>], min<span class="op">:</span><span class="fl">0.1</span>, max<span class="op">:</span><span class="fl">0.2</span>}, <span class="st">&#39;Composite&#39;</span>);</code></pre></div>
<p>In this step, we will create three masks: one based the class we already have (water class),one based on elevation (mangroves tend to ocurr in flat areas near the shore. Thus an elevation cut off can be use to eliminate most of other pixels) and, finally, one based on spectral threshold (similarly to what we have done in the previous step). The resulting composite will be what we will use for classifying Mangroves:</p>
<ol style="list-style-type: upper-alpha">
<li>Mask I - Water Class</li>
</ol>
<p>Here, we will create a mask based on the water classification. For that, we will create a <code>ee.Image</code> populate it with 1 and where it overlaps with the water class, populate it with 0. This way, when we apply this mask to the <code>composite</code>, the classified water pixels will be masked, leaving only the other pixels available for classification:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var waterMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">waterClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
<span class="kw">Map.addLayer</span>(<span class="kw">waterMask.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;yellow&#39;</span>]}, <span class="st">&#39;Water Mask&#39;</span>);</code></pre></div>
<p>Note that the value provided within <code>eq()</code> needs to match the value of your class.</p>
<ol start="2" style="list-style-type: upper-alpha">
<li>Mask II - Elevation (See <a href="part-3-country-specific-applications.html#fig:my-elevmask">3.4</a>)</li>
</ol>
<p>For the elevation mask, we will take advantage of the Shuttle Radar Topography Mission's elevation data available on GEE. We will use an elevation cut off of 25 meters: the composite will be masked where pixels have values &gt; 25 m of elevation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var elevation =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;USGS/SRTMGL1_003&#39;</span>)<span class="kw">.select</span>(<span class="st">&#39;elevation&#39;</span>);
var elevationMask =<span class="st"> </span><span class="kw">elevation.lte</span>(<span class="dv">25</span>)<span class="kw">.clip</span>(filteredAOI);
<span class="kw">Map.addLayer</span>(<span class="kw">elevationMask.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;pink&#39;</span>]}, <span class="st">&#39;Elevation Mask&#39;</span>);</code></pre></div>
<ol start="3" style="list-style-type: upper-alpha">
<li>Mask III - Index Threshold For the threshold mask, we will use the same index we used in the Water classification masking phase:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var wetMask =<span class="st"> </span><span class="kw">composite.select</span>(<span class="st">&#39;MNDWI&#39;</span>)<span class="kw">.gte</span>(<span class="op">-</span><span class="fl">0.12</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">wetMask.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;blue&#39;</span>]}, <span class="st">&#39;Wet Mask&#39;</span>);</code></pre></div>
<p>These are the three masks that will be applied to <code>composite</code>:</p>
<div class="figure"><span id="fig:PartIII-MASKS"></span>
<img src="images/PartIII-MASKS.png" alt="When applying these three masks to the composite, pixels will only remain where the three masks overlap." width="854" />
<p class="caption">
Figure 3.28: When applying these three masks to the composite, pixels will only remain where the three masks overlap.
</p>
</div>
<p>Finally, we will apply these masks to the <code>composite</code> using <code>.mask()</code> for the first mask and <code>.updateMask()</code> for the others:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var compositemasked =<span class="st"> </span><span class="kw">composite.mask</span>(waterMask)
                               <span class="kw">.updateMask</span>(elevationMask)
                               <span class="kw">.updateMask</span>(wetMask);

<span class="kw">Map.addLayer</span>(compositemasked, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B6&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>], min<span class="op">:</span><span class="fl">0.1</span>, max<span class="op">:</span><span class="fl">0.2</span>}, <span class="st">&#39;Composite Masked&#39;</span>);</code></pre></div>
<p>You should achieve something like this:</p>
<div class="figure"><span id="fig:PartIII-CompositeMaskedII"></span>
<img src="images/PartIII-CompositeMaskedII.png" alt="Masked composite." width="866" />
<p class="caption">
Figure 3.29: Masked composite.
</p>
</div>
<p>Next, we will repeat the sampling selection and classification. As a tip for selection accurate samples, mangroves will be in a darker shade of red/orange in this RGB 564 color composition while other vegetative classes (e.g. evergreen forests) will have a lighter red/orange shade. Make sure to take advantage of the high resolution imagery using the <strong>Satellite</strong> button:</p>
<div class="figure"><span id="fig:PartIII-Mangrove"></span>
<img src="images/PartIII-Mangrove.png" alt="Mangroves and other vegetation classes in Liberia." width="862" />
<p class="caption">
Figure 3.30: Mangroves and other vegetation classes in Liberia.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var classes =<span class="st"> </span><span class="kw">Mangrove.merge</span>(Other);
var bands =<span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>,<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B6&#39;</span>,<span class="st">&#39;NDVI&#39;</span>,<span class="st">&#39;NBR&#39;</span>,<span class="st">&#39;MNDWI&#39;</span>,<span class="st">&#39;SR&#39;</span>,<span class="st">&#39;GCVI&#39;</span>,<span class="st">&#39;MSAVI&#39;</span>];

var samples =<span class="st"> </span><span class="kw">compositemasked.select</span>(bands)<span class="kw">.sampleRegions</span>({
  collection<span class="op">:</span><span class="st"> </span>classes,       
  properties<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;landcover&#39;</span>],
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>                  
})<span class="kw">.randomColumn</span>(<span class="st">&#39;random&#39;</span>);

var split =<span class="st"> </span><span class="fl">0.8</span>;
var training =<span class="st"> </span><span class="kw">samples.filter</span>(<span class="kw">ee.Filter.lt</span>(<span class="st">&#39;random&#39;</span>, split));
var testing =<span class="st"> </span><span class="kw">samples.filter</span>(<span class="kw">ee.Filter.gte</span>(<span class="st">&#39;random&#39;</span>, split));

<span class="kw">print</span>(<span class="st">&#39;Samples n =&#39;</span>, <span class="kw">samples.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));
<span class="kw">print</span>(<span class="st">&#39;Training n =&#39;</span>, <span class="kw">training.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));
<span class="kw">print</span>(<span class="st">&#39;Testing n =&#39;</span>, <span class="kw">testing.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));

var classifier =<span class="st"> </span><span class="kw">ee.Classifier.smileRandomForest</span>(<span class="dv">100</span>,<span class="dv">5</span>)<span class="kw">.train</span>({
  features<span class="op">:</span><span class="st"> </span>training,
  classProperty<span class="op">:</span><span class="st"> &#39;landcover&#39;</span>, 
  inputProperties<span class="op">:</span><span class="st"> </span>bands
});

var validation =<span class="st"> </span><span class="kw">testing.classify</span>(classifier);
var testAccuracy =<span class="st"> </span><span class="kw">validation.errorMatrix</span>(<span class="st">&#39;landcover&#39;</span>, <span class="st">&#39;classification&#39;</span>);

<span class="kw">print</span>(<span class="st">&#39;Validation error matrix RF: &#39;</span>, testAccuracy);
<span class="kw">print</span>(<span class="st">&#39;Validation overall accuracy RF in %: &#39;</span>, <span class="kw">testAccuracy.accuracy</span>()<span class="kw">.multiply</span>(<span class="dv">100</span>));

var classification =<span class="st"> </span><span class="kw">compositemasked.select</span>(bands)<span class="kw">.classify</span>(classifier);

var paletteMAP =<span class="st"> </span>[
  <span class="st">&#39;#35ff17&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="kw">Other</span> (Class value <span class="dv">0</span>)
  <span class="st">&#39;#ce0dd6&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="kw">Mangroves</span> (Class value <span class="dv">1</span>)
];

<span class="kw">Map.addLayer</span> (classification, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">1</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Classification&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-Mangroves"></span>
<img src="images/PartIII-Mangroves.png" alt="Classification output." width="862" />
<p class="caption">
Figure 3.31: Classification output.
</p>
</div>
<p>Finally, we will export the classification:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>classification,
  description<span class="op">:</span><span class="st"> &#39;MangroveClassification&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;2-Mangroves&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  });</code></pre></div>
<p><a href="https://code.earthengine.google.com/91448c680e2b1a24414c6f97984edf1d" target="_blank">Code Checkpoint</a></p>
<p><strong><em>Settlements</em></strong></p>
<p>Now, we are moving into classes that require not only a spectral analysis but also a contextual one to be accurately classified. A good example is the artificial surfaces/ settlements class. In the case of Liberia, these areas will have very similar spectral behavior as exposed soil and bare areas, as most of the villages and small towns are usually located within these land cover classes. Therefore, a contextual evaluation needs to be included to ensure that bare areas are not being missclassified as settlements. In this case, we can use datasets like the location of these settlements and population density. These are extra pieces of information that we can use to constrain the classification to the correct area. In this example, we will use the <a href="https://energydata.info/dataset/liberia-populated-settlements" target="_blank">Liberia census population dataset from 2007-2008</a> created by Liberia Institute of Statistics and Geo-Information Services (LISGIS). The dataset contains a list of all the settlements that are geo-located and have attributes with their administrative units and population data (total, male, female and number of households). Additionally, we can use the Global Population Density dataset to further refine our classification.</p>
<p>Similarly to the last classification, we will open a <a href="https://code.earthengine.google.com/" target="_blank">new Code Editor page</a> and import the Landsat composite, the feature collection of Liberia counties, the feature collection of Liberia settlements, the global population density dataset (available through GEE) and the water and mangrove classification outputs:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var composite =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/CompositeLiberia2021&#39;</span>);
var aoi =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/LiberiaCounties&#39;</span>);
var filterCounties =<span class="st"> </span><span class="kw">ee.Filter.inList</span>(<span class="st">&#39;NAME_1&#39;</span>, [<span class="st">&#39;Bomi&#39;</span>, <span class="st">&#39;Montserrado&#39;</span>,<span class="st">&#39;Margibi&#39;</span>,<span class="st">&#39;GrandBassa&#39;</span>]);
var filteredAOI =<span class="st"> </span><span class="kw">aoi.filter</span>(filterCounties);

var settlements =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/PopulatedSettlements2007&#39;</span>);
var PopulationCount =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;JRC/GHSL/P2016/POP_GPW_GLOBE_V1/2015&#39;</span>);

var waterClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/1-Water&#39;</span>);
var mangroveClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/2-Mangroves&#39;</span>);</code></pre></div>
<p>You can add these layers to the Map Editor for inspection:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(composite, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B6&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>], min<span class="op">:</span><span class="fl">0.1</span>, max<span class="op">:</span><span class="fl">0.2</span>}, <span class="st">&#39;Composite&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">PopulationCount.clip</span>(filteredAOI), {palette<span class="op">:</span>[<span class="st">&quot;ffffe7&quot;</span>,<span class="st">&quot;FFc869&quot;</span>,<span class="st">&quot;ffac1d&quot;</span>,<span class="st">&quot;e17735&quot;</span>,<span class="st">&quot;f2552c&quot;</span>,<span class="st">&quot;9f0c21&quot;</span>], min<span class="op">:</span><span class="dv">0</span>, max<span class="op">:</span><span class="dv">500</span>}, <span class="st">&#39;Population Count&#39;</span>);
<span class="kw">Map.addLayer</span>(settlements, {}, <span class="st">&#39;Settlements&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-Pop"></span>
<img src="images/PartIII-Pop.png" alt="Ancillary datasets for classification of human settlements in Liberia. The population density and small settlement locations is helpful to constrain the classification in certain areas and help reduce misclassification errors with spectrally similar classes such as bare soil." width="1458" />
<p class="caption">
Figure 3.32: Ancillary datasets for classification of human settlements in Liberia. The population density and small settlement locations is helpful to constrain the classification in certain areas and help reduce misclassification errors with spectrally similar classes such as bare soil.
</p>
</div>
<p>Similarly to the previous classification, we will create the masks based on these datasets to apply to the composite:</p>
<ol style="list-style-type: upper-alpha">
<li>Mask I - Water and Mangrove class masks</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var waterMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">waterClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var mangroveMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">mangroveClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);</code></pre></div>
<ol start="2" style="list-style-type: upper-alpha">
<li>Mask II - Population Masks</li>
</ol>
<p>In this particular case, we are using two different datasets: one is an <code>ee.Image()</code> (<code>PopulationCount</code>) and the other is a <code>ee.FeatureCollection()</code> (<code>settlements</code>). Fot that we will create two different masks and merge them together as a single mask. First, we will create a population count mask based on the number of people per pixel. Using the same construction as before, we will create a <code>ee.Image()</code> of value 1 and populate it with zeros where <code>PopulationCount</code> is equal or lower than 100 people. In other words, we are creating a mask to remove pixels where there is less than 100 people, which is an indication that this area may not be a fully established settlement:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var popMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">PopulationCount.select</span>([<span class="st">&#39;population_count&#39;</span>])<span class="kw">.lte</span>(<span class="dv">100</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
<span class="kw">Map.addLayer</span>(<span class="kw">popMask.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;green&#39;</span>]}, <span class="st">&#39;Population Mask&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-PopMask"></span>
<img src="images/PartIII-PopMask.png" alt="Population mask created by selecting areas that have more than 100 people/pixel. Once this mask is applied, areas with less than 100 people per pixel will be masked." width="858" />
<p class="caption">
Figure 3.33: Population mask created by selecting areas that have more than 100 people/pixel. Once this mask is applied, areas with less than 100 people per pixel will be masked.
</p>
</div>
<p>Next, we will use <code>settlements</code>. As you may have noticed, <code>settlements</code> contains the location of each small human settlement based on the 2007 census. We can then create a buffer of a certain size around each of these locations to create areas of likelihood for human settlements. We will first create a function to apply a buffer of a 1000 meters around the feature and then map it to <code>settlements</code> using <code>.map()</code> method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var bufferSet =<span class="st"> </span><span class="cf">function</span>(feature) {
  return <span class="kw">feature.buffer</span>(<span class="dv">1000</span>);   
};
var setLocation =<span class="st"> </span><span class="kw">settlements.map</span>(bufferSet);
<span class="kw">Map.addLayer</span>(setLocation, {color<span class="op">:</span><span class="st">&#39;purple&#39;</span>}, <span class="st">&#39;Settlements&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-SetBuffer"></span>
<img src="images/PartIII-SetBuffer.png" alt="1000 m buffer around each settlement location." width="856" />
<p class="caption">
Figure 3.34: 1000 m buffer around each settlement location.
</p>
</div>
<p>Now, we can merge them into a final mask by creating an <code>ee.Image()</code> of 1 and clip it using the buffered locations, the <code>.clip()</code> method and add it to <code>popMask</code> using <code>.add()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var populationMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>)<span class="kw">.clip</span>(setLocation)<span class="kw">.unmask</span>()<span class="kw">.add</span>(popMask);
<span class="kw">Map.addLayer</span>(<span class="kw">populationMask.selfMask</span>(), {palette<span class="op">:</span><span class="st">&#39;blue&#39;</span>}, <span class="st">&#39;Population Mask Final&#39;</span>);</code></pre></div>
<div class="starcomment">
<p>
Note that the code above used <code>.unmask()</code> after <code>.clip()</code>. In order to mathematically add two images, they have to have values. <code>.clip()</code> will cut an image for the extent of the feature used. Therefore, the rest will be automatically masked. Using <code>.unmask()</code> allows you to reaply 0 values to the masked areas, allowing you to do mathematical operations with it!
</p>
</div>
<div class="figure"><span id="fig:PartIII-PopMaskFinal"></span>
<img src="images/PartIII-PopMaskFinal.png" alt="Final population Mask." width="858" />
<p class="caption">
Figure 3.35: Final population Mask.
</p>
</div>
<p>Finally, we will apply these masks to the composite:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var compositemasked =<span class="st"> </span><span class="kw">composite.mask</span>(waterMask)
                              <span class="kw">.updateMask</span>(mangroveMask)
                              <span class="kw">.updateMask</span>(populationMask);

<span class="kw">Map.addLayer</span>(compositemasked, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B6&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>], min<span class="op">:</span><span class="fl">0.1</span>, max<span class="op">:</span><span class="fl">0.2</span>}, <span class="st">&#39;Composite Masked&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-MaskedCompositeII"></span>
<img src="images/PartIII-MaskedCompositeII.png" alt="Masked composite using `waterMask`, `mangroveMask` and `populationMask`." width="856" />
<p class="caption">
Figure 3.36: Masked composite using <code>waterMask</code>, <code>mangroveMask</code> and <code>populationMask</code>.
</p>
</div>
<ol start="3" style="list-style-type: upper-alpha">
<li>Mask III - Index Threshold</li>
</ol>
<p>As an additional mask, you can create a NBR-based mask to only highlight areas that are exposed and has no vegetation to it. Since we already applied the population and location based masks, this one can further remove extra pixels that are not likely to be human settlements, for instance, highly vegetated areas:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var bareMask =<span class="st"> </span><span class="kw">compositemasked.select</span>(<span class="st">&#39;NBR&#39;</span>)<span class="kw">.lte</span>(<span class="fl">0.25</span>);
var compositeMasked =<span class="st"> </span><span class="kw">compositemasked.updateMask</span>(bareMask);
<span class="kw">Map.addLayer</span>(compositeMasked, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B6&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>], min<span class="op">:</span><span class="fl">0.1</span>, max<span class="op">:</span><span class="fl">0.2</span>}, <span class="st">&#39;Composite Masked Final&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-MaskedCompositeIII"></span>
<img src="images/PartIII-MaskedCompositeIII.png" alt="Masked composite using `waterMask`, `mangroveMask` and `populationMask` and `bareMask` showing areas of higher likelihood to be human settlements." width="859" />
<p class="caption">
Figure 3.37: Masked composite using <code>waterMask</code>, <code>mangroveMask</code> and <code>populationMask</code> and <code>bareMask</code> showing areas of higher likelihood to be human settlements.
</p>
</div>
<p><a href="https://code.earthengine.google.com/d60cf84c3a0e870b51c7c9f469c96139" target="_blank">Code Checkpoint</a></p>
<p>Similarly to the other classes, we will collect samples of urban areas and other classes and train a classifier. Finally, We can apply the random forest classifier to this resulting composite.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var classes =<span class="st"> </span><span class="kw">City.merge</span>(Other);
var bands =<span class="st"> </span>[<span class="st">&#39;SR_B4&#39;</span>,<span class="st">&#39;SR_B5&#39;</span>,<span class="st">&#39;SR_B6&#39;</span>,<span class="st">&#39;NDVI&#39;</span>,<span class="st">&#39;NBR&#39;</span>,<span class="st">&#39;MNDWI&#39;</span>,<span class="st">&#39;SR&#39;</span>,<span class="st">&#39;GCVI&#39;</span>,<span class="st">&#39;MSAVI&#39;</span>];

var samples =<span class="st"> </span><span class="kw">compositeMasked.select</span>(bands)<span class="kw">.sampleRegions</span>({
  collection<span class="op">:</span><span class="st"> </span>classes,       
  properties<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;landcover&#39;</span>],
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>                  
})<span class="kw">.randomColumn</span>(<span class="st">&#39;random&#39;</span>);

var split =<span class="st"> </span><span class="fl">0.8</span>;
var training =<span class="st"> </span><span class="kw">samples.filter</span>(<span class="kw">ee.Filter.lt</span>(<span class="st">&#39;random&#39;</span>, split));
var testing =<span class="st"> </span><span class="kw">samples.filter</span>(<span class="kw">ee.Filter.gte</span>(<span class="st">&#39;random&#39;</span>, split));

<span class="kw">print</span>(<span class="st">&#39;Samples n =&#39;</span>, <span class="kw">samples.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));
<span class="kw">print</span>(<span class="st">&#39;Training n =&#39;</span>, <span class="kw">training.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));
<span class="kw">print</span>(<span class="st">&#39;Testing n =&#39;</span>, <span class="kw">testing.aggregate_count</span>(<span class="st">&#39;landcover&#39;</span>));

var classifier =<span class="st"> </span><span class="kw">ee.Classifier.smileRandomForest</span>(<span class="dv">100</span>,<span class="dv">5</span>)<span class="kw">.train</span>({
  features<span class="op">:</span><span class="st"> </span>training,
  classProperty<span class="op">:</span><span class="st"> &#39;landcover&#39;</span>, 
  inputProperties<span class="op">:</span><span class="st"> </span>bands
});

var validation =<span class="st"> </span><span class="kw">testing.classify</span>(classifier);
var testAccuracy =<span class="st"> </span><span class="kw">validation.errorMatrix</span>(<span class="st">&#39;landcover&#39;</span>, <span class="st">&#39;classification&#39;</span>);

<span class="kw">print</span>(<span class="st">&#39;Validation error matrix RF: &#39;</span>, testAccuracy);
<span class="kw">print</span>(<span class="st">&#39;Validation overall accuracy RF in %: &#39;</span>, <span class="kw">testAccuracy.accuracy</span>()<span class="kw">.multiply</span>(<span class="dv">100</span>));

var classification =<span class="st"> </span><span class="kw">compositeMasked.select</span>(bands)<span class="kw">.classify</span>(classifier);

var paletteMAP =<span class="st"> </span>[
  <span class="st">&#39;#ffc82d&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="kw">Other</span> (Class value <span class="dv">0</span>)
  <span class="st">&#39;#0c4f95&#39;</span>,  <span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="kw">Settlements</span> (Class value <span class="dv">1</span>)
];

<span class="kw">Map.addLayer</span> (classification, {min<span class="op">:</span><span class="st"> </span><span class="dv">0</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">1</span>, palette<span class="op">:</span>paletteMAP}, <span class="st">&#39;Classification&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-Settlements"></span>
<img src="images/PartIII-Settlements.png" alt="Classification Output." width="856" />
<p class="caption">
Figure 3.38: Classification Output.
</p>
</div>
<p><a href="https://code.earthengine.google.com/6c955c227802dd65606864f4792392b7" target="_blank">Code Checkpoint</a></p>
<p><strong><em>Grasslands/ Herbaceous Vegetation</em></strong></p>
<p>After classifying Human Settlements, the next class we will be focusing on is Grasslands/ Herbaceous Vegetation. Similarly to the previous class, this one have a spectral signature that follows the overall behavior of bare soil. Barren Lands and Grasslands are likely to be very heterogeneous and often show intermixing with other land cover classes and with each other. In this case, we can take advantage of bareness-related indices to highlight these areas and use them as potential masks to assist in the classification. For example, the Normalized Burn Ratio is often used to highlight burned and bare areas:</p>
<div class="figure"><span id="fig:PartIII-Grasslands"></span>
<img src="images/PartIII-Grasslands.png" alt="The Normalized Burn Ratio and Grasslands. Areas with little to no vegetation cover is shown in black." width="857" />
<p class="caption">
Figure 3.39: The Normalized Burn Ratio and Grasslands. Areas with little to no vegetation cover is shown in black.
</p>
</div>
<p>First, we will start importing the same assets as before and the classes we have so far: water bodies, mangroves and human settlements:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var composite =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/CompositeLiberia2021&#39;</span>);
var aoi =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/LiberiaCounties&#39;</span>);
var filterCounties =<span class="st"> </span><span class="kw">ee.Filter.inList</span>(<span class="st">&#39;NAME_1&#39;</span>, [<span class="st">&#39;Bomi&#39;</span>, <span class="st">&#39;Montserrado&#39;</span>,<span class="st">&#39;Margibi&#39;</span>,<span class="st">&#39;GrandBassa&#39;</span>]);
var filteredAOI =<span class="st"> </span><span class="kw">aoi.filter</span>(filterCounties);

var waterClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/1-Water&#39;</span>);
var mangroveClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/2-Mangroves&#39;</span>);
var settlementClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/3-Settlements&#39;</span>);</code></pre></div>
<p>Next, we will create the masks based on the classes we have so far and applying to the <code>composite</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var waterMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">waterClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var mangroveMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">mangroveClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var settlementMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">settlementClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var compositemasked =<span class="st"> </span><span class="kw">composite.mask</span>(waterMask)
                               <span class="kw">.updateMask</span>(mangroveMask)
                               <span class="kw">.updateMask</span>(settlementMask);
<span class="kw">Map.addLayer</span>(compositemasked, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B6&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>], min<span class="op">:</span><span class="fl">0.1</span>, max<span class="op">:</span><span class="fl">0.2</span>}, <span class="st">&#39;Composite Masked&#39;</span>);</code></pre></div>
<p>At this point, the composite is masked for three classes and what is left is mostly vegetative classes (ever green forests and plantation) with the exception of little to no vegetation cover classes such as herbaceous vegetation/ grasslands and bare areas. For these low biomass/bare classes, we can still use the random forest classification route: collecting training samples and classifying <code>composite</code>. However, due to their distinct spectral signature compare do their surrounding classes and their distinct pattern (particularly in the area highlighted in this example), you may even be able to separate them with index threshold. In this example, we will use this technique for the sake of demonstration. We will use the NBR index as an example:</p>
<p><strong>The lower the values of NBR, the more exposed/bare that particular area is. Therefore, after inspecting the values over areas of bare soil and grasslands, we concluded that bare soil had, in average, lower values than 0.05, while grasslands had between 0.05 and 0.2. Remember to always use the Inspector tab if you want to learn more about the values of a particular pixel in that image!</strong></p>
<div class="starcomment">
<p>
You can check the average value of pixels within a region by using <code>ee.ReduceRegions()</code> and <code>ee.Reducer.mean()</code>:
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var averageNBR =<span class="st"> </span><span class="kw">compositemasked.select</span>(<span class="st">&#39;NBR&#39;</span>)<span class="kw">.reduceRegions</span>({
  collection<span class="op">:</span><span class="st"> </span><span class="kw">Bare.geometry</span>(),
  reducer<span class="op">:</span><span class="st"> </span><span class="kw">ee.Reducer.mean</span>(),
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>,
});

<span class="kw">print</span>(averageNBR)</code></pre></div>
<p>Thus we can apply the conditionals <code>.lte()</code> and <code>.gt()</code> to the NBR band from <code>composite</code> to extract these classes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var bareClass =<span class="st"> </span><span class="kw">compositemasked.select</span>(<span class="st">&#39;NBR&#39;</span>)<span class="kw">.lte</span>(<span class="fl">0.05</span>)<span class="kw">.rename</span>(<span class="st">&#39;bare&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">bareClass.selfMask</span>(), {palette<span class="op">:</span><span class="st">&#39;red&#39;</span>}, <span class="st">&#39;bareClass&#39;</span>);</code></pre></div>
<p>For grasslands, we can combine conditionals using <code>.and()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var grassClass =<span class="st"> </span><span class="kw">compositemasked.select</span>(<span class="st">&#39;NBR&#39;</span>)<span class="kw">.gt</span>(<span class="fl">0.05</span>)<span class="kw">.and</span>(<span class="kw">compositemasked.select</span>(<span class="st">&#39;NBR&#39;</span>)<span class="kw">.lte</span>(<span class="fl">0.2</span>))<span class="kw">.rename</span>(<span class="st">&#39;grass&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">grassClass.selfMask</span>(), {palette<span class="op">:</span><span class="st">&#39;green&#39;</span>}, <span class="st">&#39;grassClass&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-GrasslandsandBare"></span>
<img src="images/PartIII-GrasslandsandBare.png" alt="Extracting the herbaceous vegetation/grass and bare areas using NBR thresholds." width="1452" />
<p class="caption">
Figure 3.40: Extracting the herbaceous vegetation/grass and bare areas using NBR thresholds.
</p>
</div>
<p>Finally, we will export these classes to the assets following the same code as before:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>bareClass,
  description<span class="op">:</span><span class="st"> &#39;BareClassification&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;4-Bareareas&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  });

<span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>grassClass,
  description<span class="op">:</span><span class="st"> &#39;GrassClassification&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;5-Grasslands&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  });</code></pre></div>
<p><a href="https://code.earthengine.google.com/6bbff33c6ccde7e494b36f5f3205ece2" target="_blank">Code Checkpoint</a></p>
<p><strong><em>Plantation</em></strong></p>
<p>Cultivated land in Liberia primarily consists of woody commodity crops (oil palm and rubber trees).</p>
<div class="figure"><span id="fig:PartIII-Concessions"></span>
<img src="images/PartIII-Concessions.png" alt="Rubber (red) and Oil Palm (green) concessions in Liberia. The spectral signature of these woody crops are identical with those of natural vegetation making it very challenging to classify." width="856" />
<p class="caption">
Figure 3.41: Rubber (red) and Oil Palm (green) concessions in Liberia. The spectral signature of these woody crops are identical with those of natural vegetation making it very challenging to classify.
</p>
</div>
<p>As seen in the previous section (3.2.1), areas of plantation usually undergo harvesting cycles, which creates a temporal signature that is different than evergreen natural vegetation. We took the advantage of this interannual differences by doing an anomaly analysis and creating losses/harvest and gains/planting flag layers.</p>
<p>We will start by opening a <a href="https://code.earthengine.google.com/" target="_blank">new Code Editor page</a> and importing the flag layers, the composite and the Liberia counties feature collection:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var lossFlag =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/LossFlag&#39;</span>);
var recoveryFlag =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/RecoveryFlag&#39;</span>);

var composite =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/CompositeLiberia2021&#39;</span>);
var aoi =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/LiberiaCounties&#39;</span>);
var filterCounties =<span class="st"> </span><span class="kw">ee.Filter.inList</span>(<span class="st">&#39;NAME_1&#39;</span>, [<span class="st">&#39;Bomi&#39;</span>, <span class="st">&#39;Montserrado&#39;</span>,<span class="st">&#39;Margibi&#39;</span>,<span class="st">&#39;GrandBassa&#39;</span>]);
var filteredAOI =<span class="st"> </span><span class="kw">aoi.filter</span>(filterCounties);</code></pre></div>
<p>These flag layers have pixels with 5 digit combinations of 0 and 1 value representing absence and presence, respectively It is up to the user to come up to a rule to define the final plantation layer based on the combination of years (see section (3.2.1)). Examples of this would be pixels that showed losses for at least 2 consecutive years, no matter what year:</p>
<ul>
<li><p>11000 - 2016 and 2017</p></li>
<li><p>01100 - 2017 and 2018</p></li>
<li><p>00110 - 2018 and 2019</p></li>
<li><p>00011 - 2019 and 2020</p></li>
<li><p>11100 - 2016, 2017 and 2018</p></li>
<li><p>01110 - 2017, 2018 and 2019</p></li>
<li><p>00111 - 2018, 2019 and 2020</p></li>
<li><p>11110 - 2016, 2017, 2018 and 2019</p></li>
<li><p>01111 - 2017, 2018, 2019 and 2020</p></li>
</ul>
<p>Or selecting pixels that showed losses on consecutive years:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var disturbance1year =<span class="st"> </span><span class="kw">lossFlag.eq</span>(<span class="dv">10000</span>); <span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="dv">2016</span>
var disturbance2years =<span class="st"> </span><span class="kw">lossFlag.eq</span>(<span class="dv">11000</span>);<span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="dv">2016</span>, <span class="dv">2017</span>
var disturbance3years =<span class="st"> </span><span class="kw">lossFlag.eq</span>(<span class="dv">11100</span>);<span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="dv">2016</span>, <span class="dv">2017</span>, <span class="dv">2018</span>
var disturbance4years =<span class="st"> </span><span class="kw">lossFlag.eq</span>(<span class="dv">11110</span>);<span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="dv">2016</span>, <span class="dv">2017</span>, <span class="dv">2018</span>, <span class="dv">2019</span>
var disturbance5years =<span class="st"> </span><span class="kw">lossFlag.eq</span>(<span class="dv">11111</span>);<span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="dv">2016</span>, <span class="dv">2017</span>, <span class="dv">2018</span>, <span class="dv">2019</span>, <span class="dv">2020</span>

<span class="kw">Map.addLayer</span>(<span class="kw">lossFlag.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;white&#39;</span>]}, <span class="st">&#39;LossFlag&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">disturbance1year.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;E0C097&#39;</span>]}, <span class="st">&#39;Disturbance 1 Year&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">disturbance2years.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;D79771&#39;</span>]}, <span class="st">&#39;Disturbance 2 Years&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">disturbance3years.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;B85C38&#39;</span>]}, <span class="st">&#39;Disturbance 3 Years&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">disturbance4years.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;753422&#39;</span>]}, <span class="st">&#39;Disturbance 4 Years&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">disturbance5years.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;2D2424&#39;</span>]}, <span class="st">&#39;Disturbance All Years&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-PlantationS"></span>
<img src="images/PartIII-PlantationS.png" alt="The loss flag (in white) and selected flag values." width="858" />
<p class="caption">
Figure 3.42: The loss flag (in white) and selected flag values.
</p>
</div>
<p>For this example, we will consider plantation, every pixel that showed at least 1 year of loss/harvest and at least 1 year of gain/planting in those flags. In other words, both loss/harvest and gain/planting flags. Thus, we will add <code>lossFlag</code> and <code>recoveryFlag</code>, create an image of 0 and where the sum overlaps this image, populate it with 1. Finally clip it for the area of study (<code>filteredAOI</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var plantations =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>)<span class="kw">.where</span>(<span class="kw">lossFlag.add</span>(recoveryFlag),<span class="dv">1</span>)<span class="kw">.clip</span>(filteredAOI);
<span class="kw">Map.addLayer</span>(<span class="kw">plantations.selfMask</span>(), {palette<span class="op">:</span>[<span class="st">&#39;green&#39;</span>]}, <span class="st">&#39;Plantation&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-PlantationClassI"></span>
<img src="images/PartIII-PlantationClassI.png" alt="Plantation class derived from the `lossFlag` and `recoveryFlag`" width="1313" />
<p class="caption">
Figure 3.43: Plantation class derived from the <code>lossFlag</code> and <code>recoveryFlag</code>
</p>
</div>
<p><em><strong>One last step remains to finalize the plantation class layer</strong></em>: Remember that every other class prior to this one was created from a classified Landsat composite that was masked each time using the previous class. Therefore, we need to mask <code>plantations</code> so it matches with how it would have been if it were created with the Landsat composite. Similarly to the previous classes, we will add the class assets, and use them to create masks for <code>plantations</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var waterClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/1-Water&#39;</span>);
var mangroveClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/2-Mangroves&#39;</span>);
var settlementClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/3-Settlements&#39;</span>);
var bareClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/4-Bareareas&#39;</span>);
var grassClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/5-Grasslands&#39;</span>);

var waterMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">waterClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var mangroveMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">mangroveClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var settlementMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">settlementClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var bareMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">bareClass.select</span>([<span class="st">&#39;bare&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var grassMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">grassClass.select</span>([<span class="st">&#39;grass&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);</code></pre></div>
<p>Then, mask <code>plantations</code> using the masks with the method <code>mask()</code> for the first and <code>.updateMask()</code> for the rest:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var plantationClass =<span class="st"> </span><span class="kw">plantations.mask</span>(waterMask)
                                 <span class="kw">.updateMask</span>(mangroveMask)
                                 <span class="kw">.updateMask</span>(settlementMask)
                                 <span class="kw">.updateMask</span>(bareMask)
                                 <span class="kw">.updateMask</span>(grassMask)
                                 <span class="kw">.rename</span> (<span class="st">&#39;plantations&#39;</span>);</code></pre></div>
<div class="rmdcomment">
<p>
It is a good practice to use <code>.rename()</code> to give a name to the image you just created. If you choose not to rename your image, its band name will default to 'constant'.
</p>
</div>
<p>Finally, export this layer as an asset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>plantationClass,
  description<span class="op">:</span><span class="st"> &#39;plantationClass&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;6-Plantations&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  region<span class="op">:</span><span class="st"> </span>filteredAOI,
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  });</code></pre></div>
<p><a href="https://code.earthengine.google.com/4a7d0eef77edecce93805485a8b3a6f6" target="_blank">Code checkpoint</a></p>
<p><em><strong>Forests</strong></em></p>
<p>According to a <a href="https://openknowledge.worldbank.org/handle/10986/34438" target="_blank">report by the World Bank</a>, &quot;<em>Liberia is one of the most forested countries in West Africa, with more than two thirds of its land surface covered by forest. The National Forest Inventory, conducted by the Liberia Forestry Development Authority in 2018 and 2019, estimates the forest cover in Liberia to be 6.69 million hectares which is approximately 69 percent of the total landmass.</em>&quot;</p>
<p>Thus, it comes as no surprise that the vast majority of the Landsat composite we have been using is comprised of tree covered areas. So far, we have have 6 land cover and land-use classes: <em>water bodies</em>, <em>mangroves</em>, <em>human settlements</em>, <em>bare areas</em>, <em>grasslands</em> and <em>plantations</em>. Then, the remaining of the composite is covered by trees. According to Liberia's forest definition, <em>forests are areas of at least 0.5 ha covered by trees that have more than 30% canopy cover and are at least 5 meters of height</em>. Forests can be classified in different ways and to different degrees of specificity.</p>
<p>For this example, we will categorize the tree-cover/forest class in Liberia into three sub-classes: <strong>primary/dense</strong>, <strong>secondary/open</strong> and <strong>degraded/sparse</strong>.</p>
<p>Separating different types of forests and/or different forest condition (e.g. primary and secondary) can become increasingly challenging because: (1) sometimes it requires the incorporation of complex physical models associated with specific forest types, making it difficult for widespread use, and (2) it requires multi-source high resolution auxiliary data such as 3D vegetation structure data. However, 3D vegetation structure datasets are vastly more scarce than spaceborne 2D data and, in most cases, only covers certain periods of time.</p>
<p>In a previous study, we investigated the integrity of forests in Liberia in 2018, using the Global Ecosystem Dynamics Investigation (GEDI)'s L2B Canopy Cover and Vertical Profile metrics acquired between April 2018 and November 2020, available from the NASA/USGS Land Processes Distributed Active Archive Center (DAAC). At each GEDI footprint we extracted the relative height metric RH100 (100th percentile of beam return height in meters relative to the ground) and total canopy cover (percent) gridded to the Landsat 30-meter pixel. Using these metrics, we observed that the distribution of canopy height values of open/secondary forests will be shorter than older dense/primary forests. Similarly, open/secondary forests will be characterized by lower values of canopy cover compared to dense/primary forests. Finally, spase/degraded forests will have lower canopy cover and height values compared to the other classes:</p>
<div class="figure"><span id="fig:PartIII-GEDIForests"></span>
<img src="images/PartIII-GEDI%20Forests.png" alt="GEDI-based measurements of Liberia’s forest’s integrity. Canopy height (in meters) and canopy cover (in %) was extracted from each GEDI footprint within dense tree-covered areas (a), open tree-covered areas (b), mixed vegetation (c) and all other classes (d). The summary statistics for the canopy cover and canopy height values for each class (and all other classes) is also shown (SD = standard deviation; N = count; SE = standard error of the mean)." width="1294" />
<p class="caption">
Figure 3.44: GEDI-based measurements of Liberia’s forest’s integrity. Canopy height (in meters) and canopy cover (in %) was extracted from each GEDI footprint within dense tree-covered areas (a), open tree-covered areas (b), mixed vegetation (c) and all other classes (d). The summary statistics for the canopy cover and canopy height values for each class (and all other classes) is also shown (SD = standard deviation; N = count; SE = standard error of the mean).
</p>
</div>
<p>We can use the information above to derive <strong>primary/dense</strong>, <strong>secondary/open</strong> and <strong>degraded/sparse</strong> based on height values or canopy cover.</p>
<p>The <a href="https://glad.umd.edu/dataset/gedi" target="_blank">2019 Potapov’s (University of Maryland) global canopy height dataset</a> offers a 30-m spatial resolution global forest canopy height map and was developed through the integration of the Global Ecosystem Dynamics Investigation (GEDI) lidar forest structure measurements and Landsat analysis-ready data time-series. Our previous study on forest structure in Liberia and this dataset are a good starting point to categorize the tree-cover/forest classes in Liberia.</p>
<p>First, we will start by importing all the relevant datasets into a <a href="https://code.earthengine.google.com/" target="_blank">new Code Editor</a> and creating their respective masks:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var composite =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/CompositeLiberia2021&#39;</span>);
var aoi =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/LiberiaCounties&#39;</span>);
var filterCounties =<span class="st"> </span><span class="kw">ee.Filter.inList</span>(<span class="st">&#39;NAME_1&#39;</span>, [<span class="st">&#39;Bomi&#39;</span>, <span class="st">&#39;Montserrado&#39;</span>,<span class="st">&#39;Margibi&#39;</span>,<span class="st">&#39;GrandBassa&#39;</span>]);
var filteredAOI =<span class="st"> </span><span class="kw">aoi.filter</span>(filterCounties);

<span class="kw">Map.addLayer</span>(composite, {bands<span class="op">:</span><span class="st"> </span>[<span class="st">&#39;SR_B5&#39;</span>, <span class="st">&#39;SR_B6&#39;</span>, <span class="st">&#39;SR_B4&#39;</span>], min<span class="op">:</span><span class="fl">0.1</span>, max<span class="op">:</span><span class="fl">0.2</span>}, <span class="st">&#39;Composite&#39;</span>, false);

var waterClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/1-Water&#39;</span>);
var mangroveClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/2-Mangroves&#39;</span>);
var settlementClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/3-Settlements&#39;</span>);
var bareClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/4-Bareareas&#39;</span>);
var grassClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/5-Grasslands&#39;</span>);
var plantationClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/6-Plantations&#39;</span>);

var waterMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">waterClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var mangroveMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">mangroveClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var settlementMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">settlementClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var bareMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">bareClass.select</span>([<span class="st">&#39;bare&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var grassMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">grassClass.select</span>([<span class="st">&#39;grass&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);
var plantationMask =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">1</span>). <span class="kw">where</span>(<span class="kw">plantationClass.select</span>([<span class="st">&#39;plantations&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">0</span>)<span class="kw">.clip</span>(filteredAOI);</code></pre></div>
<p>Next, we will import the <a href="https://glad.umd.edu/dataset/gedi" target="_blank">2019 Potapov’s (University of Maryland) global canopy height dataset</a> available through <code>'users/potapovpeter/GEDI_V27/GEDI_SAFR_v27'</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var potapovTreeHeight =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/potapovpeter/GEDI_V27/GEDI_SAFR_v27&#39;</span>)<span class="kw">.clip</span>(filteredAOI);</code></pre></div>
<p>This dataset needs to match the projection we are using for our composite and land cover classes. Thus, we will use <code>.reproject()</code> to adjust for their projection differences.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var treeHeight =<span class="st"> </span><span class="kw">potapovTreeHeight.reproject</span>(<span class="kw">composite.projection</span>());</code></pre></div>
<p>The <code>.projection()</code> method above retrives an image projection and affine transformation parameters. Thus, here we are using the Landsat composite projection information and reprojecting <code>potapovTreeHeight</code> to match it.</p>
<p>Add <code>treeHeight</code> to the <strong>Map Editor</strong> using the parameters below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(treeHeight, {min<span class="op">:</span><span class="dv">0</span>, max<span class="op">:</span><span class="dv">30</span>, palette<span class="op">:</span><span class="st">&#39;ffffcc,c7e9b4,7fcdbb,41b6c4,1d91c0,225ea8,0c2c84&#39;</span>}, <span class="st">&#39;Tree Height Potapov&#39;</span>,false);</code></pre></div>
<div class="figure"><span id="fig:PartIII-TreeHeight"></span>
<img src="images/PartIII-TreeHeight.png" alt="2019 Potapov’s (University of Maryland) global canopy height dataset over the study region in Liberia. Tree heights values straches from low (white) to high (dark blue)." width="850" />
<p class="caption">
Figure 3.45: 2019 Potapov’s (University of Maryland) global canopy height dataset over the study region in Liberia. Tree heights values straches from low (white) to high (dark blue).
</p>
</div>
<p>Similarly to what was done to the plantation class, we need to mask this dataset for the classes that we already have:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var TreeHeightMasked =<span class="st"> </span><span class="kw">treeHeight.mask</span>(waterMask)
                                 <span class="kw">.updateMask</span>(mangroveMask)
                                 <span class="kw">.updateMask</span>(settlementMask)
                                 <span class="kw">.updateMask</span>(bareMask)
                                 <span class="kw">.updateMask</span>(grassMask)
                                 <span class="kw">.updateMask</span>(plantationMask)</code></pre></div>
<p>We can now extract potential areas of <strong>primary/dense</strong>, <strong>secondary/open</strong> and <strong>degraded/sparse</strong> forests based on the canopy height thresholds identified in our previous study: primary/dense forests are taller than 20 meters, secondary/open ranging from 10 to 20 meters, and degraded/sparse forests ar shorter than 10 meters:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var denseForest =<span class="st"> </span><span class="kw">TreeHeightMasked.gte</span>(<span class="dv">20</span>)<span class="kw">.rename</span>(<span class="st">&#39;dense&#39;</span>);
var openForest =<span class="st"> </span><span class="kw">TreeHeightMasked.gte</span>(<span class="dv">10</span>)<span class="kw">.and</span>(<span class="kw">TreeHeightMasked.lt</span>(<span class="dv">20</span>))<span class="kw">.rename</span>(<span class="st">&#39;open&#39;</span>);
var degradedForest =<span class="st"> </span><span class="kw">TreeHeightMasked.lte</span>(<span class="dv">10</span>)<span class="kw">.rename</span>(<span class="st">&#39;degraded&#39;</span>);

<span class="kw">Map.addLayer</span>(<span class="kw">denseForest.selfMask</span>(), {palette<span class="op">:</span><span class="st">&#39;287300&#39;</span>},<span class="st">&#39;Potential Mature&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">openForest.selfMask</span>(), {palette<span class="op">:</span><span class="st">&#39;73B473&#39;</span>},<span class="st">&#39;Potential Secondary&#39;</span>);
<span class="kw">Map.addLayer</span>(<span class="kw">degradedForest.selfMask</span>(), {palette<span class="op">:</span><span class="st">&#39;EBFFBE&#39;</span>},<span class="st">&#39;Potential Degraded&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-Forests"></span>
<img src="images/PartIII-Forests.png" alt="Primary/dense, secondary/open and degraded/sparse forests based on the canopy height thresholds." width="854" />
<p class="caption">
Figure 3.46: Primary/dense, secondary/open and degraded/sparse forests based on the canopy height thresholds.
</p>
</div>
<p>Export these classes following the steps we used so far:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>denseForest,
  description<span class="op">:</span><span class="st"> &#39;DenseForest&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;7-DenseForests&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  region<span class="op">:</span><span class="st"> </span>filteredAOI,
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  });
  
<span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>openForest,
  description<span class="op">:</span><span class="st"> &#39;OpenForest&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;8-OpenForests&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  region<span class="op">:</span><span class="st"> </span>filteredAOI,
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  });
  
<span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>degradedForest,
  description<span class="op">:</span><span class="st"> &#39;DegradedForest&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;9-DegradedForests&#39;</span>,
  crs<span class="op">:</span><span class="st">&#39;EPSG:4326&#39;</span>,
  crsTransform<span class="op">:</span>[<span class="fl">0.0002777777777777778</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">180.0001388888889</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">0.0002777777777777778</span>,<span class="fl">60.00013888888889</span>],
  region<span class="op">:</span><span class="st"> </span>filteredAOI,
  maxPixels<span class="op">:</span><span class="fl">1e13</span>,
  });  </code></pre></div>
<p><a href="https://code.earthengine.google.com/69b830b8f755a1ddb9294615ebc1661b">Code Checkpoint</a>{target=&quot;_blank&quot;&quot;}</p>
<p><strong>Post Classification I - Map Composition</strong></p>
<p>Now that all the individual class maps were created, we can combine them into a final land cover map. We will start by opening a <a href="https://code.earthengine.google.com/" target="_blank">New Code Editor page</a> and adding all the assets we created so far:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var aoi =<span class="st"> </span><span class="kw">ee.FeatureCollection</span>(<span class="st">&#39;users/capacityBuilding/Liberia/LiberiaCounties&#39;</span>);
var filterCounties =<span class="st"> </span><span class="kw">ee.Filter.inList</span>(<span class="st">&#39;NAME_1&#39;</span>, [<span class="st">&#39;Bomi&#39;</span>, <span class="st">&#39;Montserrado&#39;</span>,<span class="st">&#39;Margibi&#39;</span>,<span class="st">&#39;GrandBassa&#39;</span>]);
var filteredAOI =<span class="st"> </span><span class="kw">aoi.filter</span>(filterCounties);

var waterClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/1-Water&#39;</span>);
var mangroveClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/2-Mangroves&#39;</span>);
var settlementClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/3-Settlements&#39;</span>);
var bareClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/4-Bareareas&#39;</span>);
var grassClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/5-Grasslands&#39;</span>);
var plantationClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/6-Plantations&#39;</span>);
var denseClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/7-DenseForests&#39;</span>);
var openClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/8-OpenForests&#39;</span>);
var degradedClass =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/9-DegradedForests&#39;</span>);</code></pre></div>
<p>Using the same logic we used to create the masks for masking the composites, we will create each individual class layer and assign a class value to each one of them. First we will create an <code>ee.Image()</code> of zeros where a different value will be assigned where a particular class overlaps it. For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var WATER =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>)<span class="kw">.where</span>(<span class="kw">waterClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">1</span>)<span class="kw">.clip</span>(filteredAOI);
var MANGROVES =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>). <span class="kw">where</span>(<span class="kw">mangroveClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">2</span>)<span class="kw">.clip</span>(filteredAOI);
var SETTLEMENTS =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>). <span class="kw">where</span>(<span class="kw">settlementClass.select</span>([<span class="st">&#39;classification&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">3</span>)<span class="kw">.clip</span>(filteredAOI);
var BARE =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>). <span class="kw">where</span>(<span class="kw">bareClass.select</span>([<span class="st">&#39;bare&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">4</span>)<span class="kw">.clip</span>(filteredAOI);
var GRASSLAND =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>). <span class="kw">where</span>(<span class="kw">grassClass.select</span>([<span class="st">&#39;grass&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">5</span>)<span class="kw">.clip</span>(filteredAOI);
var PLANTATION =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>). <span class="kw">where</span>(<span class="kw">plantationClass.select</span>([<span class="st">&#39;plantations&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">6</span>)<span class="kw">.clip</span>(filteredAOI);
var DENSE =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>). <span class="kw">where</span>(<span class="kw">denseClass.select</span>([<span class="st">&#39;dense&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">7</span>)<span class="kw">.clip</span>(filteredAOI);
var OPEN =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>). <span class="kw">where</span>(<span class="kw">openClass.select</span>([<span class="st">&#39;open&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">8</span>)<span class="kw">.clip</span>(filteredAOI);
var DEGRADED =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="dv">0</span>). <span class="kw">where</span>(<span class="kw">degradedClass.select</span>([<span class="st">&#39;degraded&#39;</span>])<span class="kw">.eq</span>(<span class="dv">1</span>),<span class="dv">9</span>)<span class="kw">.clip</span>(filteredAOI);</code></pre></div>
<p>In the code above, two things are worth noting:</p>
<ol style="list-style-type: decimal">
<li><p>The <code>.select()</code> method will need the name of the output in which to select the value. If the output was created using the Random Forest, its default name will be <code>'classification'</code>. The first three classes were created using the classifier. The following classes were created using value thresholds of other datasets. In this case their name defaults to <code>'constant'</code>. However, during the process, we used <code>.rename()</code> method to rename 'constant' to the name of the class.</p></li>
<li><p>We are assigning consecutive integer values from 1 to 9 to each individual classes. This way, we can colorize the map using a color palette</p></li>
</ol>
<p>A final map can be achieved by adding all these layers together using <code>.add()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var finalMap =<span class="st"> </span><span class="kw">WATER.add</span>(MANGROVES)
                    <span class="kw">.add</span>(SETTLEMENTS)
                    <span class="kw">.add</span>(BARE)
                    <span class="kw">.add</span>(GRASSLAND)
                    <span class="kw">.add</span>(PLANTATION)
                    <span class="kw">.add</span>(DENSE)
                    <span class="kw">.add</span>(OPEN)
                    <span class="kw">.add</span>(DEGRADED);</code></pre></div>
<p>Finally, using a color palette of your choice, we will add the map to the <strong>Map Editor</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var palette =<span class="st"> </span>[
  <span class="st">&#39;006EFA&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Water Bodies
  <span class="st">&#39;C800FF&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Mangroves and Wetlands
  <span class="st">&#39;FF0000&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Artificial Surfaces
  <span class="st">&#39;828282&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Baresoil
  <span class="st">&#39;A5FF73&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Grasslands
  <span class="st">&#39;FFAA00&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Woody Crops
  <span class="st">&#39;287300&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Dense Forests 
  <span class="st">&#39;73B473&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Open Forests
  <span class="st">&#39;EBFFBE&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Degraded Forests
];

<span class="kw">Map.addLayer</span>(finalMap, {min<span class="op">:</span><span class="st"> </span><span class="dv">1</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">9</span>, palette<span class="op">:</span><span class="st"> </span>palette}, <span class="st">&#39;Map&#39;</span>);</code></pre></div>
<p>As an add-on, you can add a legend to the <strong>Map Editor</strong> using the code below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var legend =<span class="st"> </span><span class="kw">ui.Panel</span>({
  style<span class="op">:</span><span class="st"> </span>{
    position<span class="op">:</span><span class="st"> &#39;bottom-left&#39;</span>,
    padding<span class="op">:</span><span class="st"> &#39;8px 15px&#39;</span>
  }
});
var legendTitle =<span class="st"> </span><span class="kw">ui.Label</span>({
  value<span class="op">:</span><span class="st"> &#39;Land cover classes&#39;</span>,
  style<span class="op">:</span><span class="st"> </span>{
    fontWeight<span class="op">:</span><span class="st"> &#39;bold&#39;</span>,
    fontSize<span class="op">:</span><span class="st"> &#39;15px&#39;</span>,
    margin<span class="op">:</span><span class="st"> &#39;0 0 4px 0&#39;</span>,
    padding<span class="op">:</span><span class="st"> &#39;0&#39;</span>,
    }
});
<span class="kw">legend.add</span>(legendTitle);
var makeRow =<span class="st"> </span><span class="cf">function</span>(color, name) {
      var colorBox =<span class="st"> </span><span class="kw">ui.Label</span>({
        style<span class="op">:</span><span class="st"> </span>{
          backgroundColor<span class="op">:</span><span class="st"> </span>color,
          padding<span class="op">:</span><span class="st"> &#39;8px&#39;</span>,
          margin<span class="op">:</span><span class="st"> &#39;0 0 4px 0&#39;</span>
        }
      });
      var description =<span class="st"> </span><span class="kw">ui.Label</span>({
        value<span class="op">:</span><span class="st"> </span>name,
        style<span class="op">:</span><span class="st"> </span>{margin<span class="op">:</span><span class="st"> &#39;0 0 4px 6px&#39;</span>}
      });
      return <span class="kw">ui.Panel</span>({
        widgets<span class="op">:</span><span class="st"> </span>[colorBox, description],
        layout<span class="op">:</span><span class="st"> </span><span class="kw">ui.Panel.Layout.Flow</span>(<span class="st">&#39;horizontal&#39;</span>)
      });
};

var names =<span class="st"> </span>[<span class="st">&#39;Water Bodies&#39;</span>, 
             <span class="st">&#39;Mangroves and Wetlands&#39;</span>, 
             <span class="st">&#39;Artificial Surfaces&#39;</span>, 
             <span class="st">&#39;Bare Soil&#39;</span>,
             <span class="st">&#39;Grasslands&#39;</span>,
             <span class="st">&#39;Woody Crops&#39;</span>,             
             <span class="st">&#39;Dense Forests&#39;</span>,
             <span class="st">&#39;Open Forests&#39;</span>,
             <span class="st">&#39;Degraded Forests&#39;</span>,
];

<span class="cf">for</span> (var <span class="dt">i =</span> <span class="dv">0</span>; i <span class="op">&lt;</span><span class="st"> </span><span class="dv">9</span>; i<span class="op">++</span>) {
  <span class="kw">legend.add</span>(<span class="kw">makeRow</span>(palette[i], names[i]));
  }  
  
<span class="kw">Map.add</span>(legend);</code></pre></div>
<div class="figure"><span id="fig:PartIII-FinalMap1"></span>
<img src="images/PartIII-FinalMap1.png" alt="Final land cover map for the study area in Liberia. The classes were created individually and composed into a final map." width="857" />
<p class="caption">
Figure 3.47: Final land cover map for the study area in Liberia. The classes were created individually and composed into a final map.
</p>
</div>
<p>For the following step, we will export this final map using the code below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Export.image.toAsset</span>({
  image<span class="op">:</span><span class="st"> </span>finalMap,
  description<span class="op">:</span><span class="st"> &#39;ExportingLCM&#39;</span>,
  assetId<span class="op">:</span><span class="st"> &#39;CompositedMap&#39;</span>,
  scale<span class="op">:</span><span class="st"> </span><span class="dv">30</span>,
  region<span class="op">:</span><span class="st"> </span>filteredAOI,
  maxPixels<span class="op">:</span><span class="fl">1e13</span>
});</code></pre></div>
<p><a href="https://code.earthengine.google.com/27d0c4d997729dda184e1b83b1d5d3d9" target="_blank">Code Checkpoint</a></p>
<p><strong>Post Classification II - Map Refinement</strong></p>
<p>As mentioned in section 2.3.2, a common issue that arises from the pixel-based classification of fine/medium spatial resolution imagery is the “salt-and-pepper” effect. This happens when individual pixels are classified differently from their neighbors, creating speckles of isolated pixels of different classes. In this section, we will focus on a post-classification technique to reduce the salt and pepper effect and edge roughness of the map we have just created.</p>
<p>Opening a <a href="https://code.earthengine.google.com/" target="_blank">New Code Editor</a> page, we will add the exported land cover map and add it to the <strong>Map Editor</strong> using the color palette:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var landcovermap =<span class="st"> </span><span class="kw">ee.Image</span>(<span class="st">&#39;users/capacityBuilding/Liberia/CompositedMap&#39;</span>);

var palette =<span class="st"> </span>[
  <span class="st">&#39;006EFA&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Water Bodies
  <span class="st">&#39;C800FF&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Mangroves and Wetlands
  <span class="st">&#39;FF0000&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Artificial Surfaces
  <span class="st">&#39;828282&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Baresoil
  <span class="st">&#39;A5FF73&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Grasslands
  <span class="st">&#39;FFAA00&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Woody Crops
  <span class="st">&#39;287300&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Dense Forests 
  <span class="st">&#39;73B473&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Open Forests
  <span class="st">&#39;EBFFBE&#39;</span>, <span class="op">/</span><span class="er">/</span><span class="st"> </span>Degraded Forests
];

<span class="kw">Map.addLayer</span>(landcovermap, {min<span class="op">:</span><span class="st"> </span><span class="dv">1</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">9</span>, palette<span class="op">:</span><span class="st"> </span>palette}, <span class="st">&#39;Map&#39;</span>);</code></pre></div>
<p>Zooming in, you will notice the “salt-and-pepper” effect:</p>
<div class="figure"><span id="fig:PartIII-SaltPepper"></span>
<img src="images/PartIII-SaltPepper.png" alt="Final land cover map for the study area in Liberia. The the “salt-and-pepper” effect is a common issue that arises from the pixel-based classification of fine/medium spatial resolution imagery." width="857" />
<p class="caption">
Figure 3.48: Final land cover map for the study area in Liberia. The the “salt-and-pepper” effect is a common issue that arises from the pixel-based classification of fine/medium spatial resolution imagery.
</p>
</div>
<p>Using the techniques discussed in section 2.3.2, we will remove the salt and pepper effect in three steps:</p>
<ol style="list-style-type: decimal">
<li>First, we will use the <code>.connectedPixelCount()</code> method. This generates an image where each pixel contains the number of 4- or 8-connected neighbors (including itself). 4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var patchsize =<span class="st"> </span><span class="kw">landcovermap.connectedPixelCount</span>(<span class="dv">4</span>, false);</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Second, we will use the <code>.focal_median()</code> method. This method is a simple sliding-window spatial filter that replaces the center value (or class) in the window with the median of all the pixel values in the window.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var filtered =<span class="st"> </span><span class="kw">landcovermap.focal_median</span>({
    radius<span class="op">:</span><span class="st"> </span><span class="dv">1</span>,
    kernelType<span class="op">:</span><span class="st"> &#39;square&#39;</span>,
    units<span class="op">:</span><span class="st"> &#39;pixels&#39;</span>,
});</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Finally, we will replace isolated pixels in <code>landcovermap</code> based on the <code>patchsize</code> value of 1: this value means that this pixel have only 1 type (or class) neighbors which, in turn, means that it is surrounded by a single class. We will use the <code>.where()</code> and <code>.eq()</code> methods. The <code>.focal_median(1, 'square', 'pixels')</code> will only achieve the intended final result if you reproject it back to the original scale and projection from the original map. Note that this technique while effective in removing the &quot;salt-and-pepper&quot; effect from the original map, it creates edges that are not in the same resolution and projection as the original map. Therefore, creating fairly rounded boundaries for the classes. This is not ideal as it is usually intended for these maps to keep the same resolution as the original map, as well as to preserve the boundaries between classes. To account for this issue, you can reproject this output back the original scale so it is formed by 30 x 30 meter pixels using <code>.reproject()</code></li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var filteredMap =<span class="st">  </span><span class="kw">landcovermap.where</span>(<span class="kw">patchsize.eq</span>(<span class="dv">1</span>),filtered)<span class="kw">.reproject</span>(<span class="kw">ee.Image</span>(<span class="kw">landcovermap.projection</span>()));</code></pre></div>
<p>Add <code>filteredMap</code> to the <strong>Map Editor</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Map.addLayer</span>(filteredMap, {min<span class="op">:</span><span class="st"> </span><span class="dv">1</span>, max<span class="op">:</span><span class="st"> </span><span class="dv">9</span>, palette<span class="op">:</span><span class="st"> </span>palette}, <span class="st">&#39;Filtered Map&#39;</span>);</code></pre></div>
<div class="figure"><span id="fig:PartIII-MapFiltered"></span>
<img src="images/PartIII-MapFiltered.png" alt="Final land cover map for the study area in Liberia filtered to remove salt and pepper effect." width="570" />
<p class="caption">
Figure 3.49: Final land cover map for the study area in Liberia filtered to remove salt and pepper effect.
</p>
</div>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="part-2-advanced-google-earth-engine.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="part-4-ecosystem-accounting.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/celiosousa/LCMTutorial/edit/master/03-PART_III.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": "https://github.com/celiosousa/LCMTutorial/blob/master/03-PART_III.Rmd",
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
